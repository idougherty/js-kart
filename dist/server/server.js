/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/avsc/lib/containers.js":
/*!*********************************************!*\
  !*** ./node_modules/avsc/lib/containers.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\n\n// TODO: Add streams which prefix each record with its length.\n\n\n\n/**\n * This module defines custom streams to write and read Avro files.\n *\n * In particular, the `Block{En,De}coder` streams are able to deal with Avro\n * container files. None of the streams below depend on the filesystem however,\n * this way they can also be used in the browser (for example to parse HTTP\n * responses).\n */\n\nvar types = __webpack_require__(/*! ./types */ \"./node_modules/avsc/lib/types.js\"),\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\n    stream = __webpack_require__(/*! stream */ \"stream\"),\n    util = __webpack_require__(/*! util */ \"util\"),\n    zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\n\nvar OPTS = {namespace: 'org.apache.avro.file'};\n\nvar LONG_TYPE = types.Type.forSchema('long', OPTS);\n\nvar MAP_BYTES_TYPE = types.Type.forSchema({type: 'map', values: 'bytes'}, OPTS);\n\nvar HEADER_TYPE = types.Type.forSchema({\n  name: 'Header',\n  type: 'record',\n  fields : [\n    {name: 'magic', type: {type: 'fixed', name: 'Magic', size: 4}},\n    {name: 'meta', type: MAP_BYTES_TYPE},\n    {name: 'sync', type: {type: 'fixed', name: 'Sync', size: 16}}\n  ]\n}, OPTS);\n\nvar BLOCK_TYPE = types.Type.forSchema({\n  name: 'Block',\n  type: 'record',\n  fields : [\n    {name: 'count', type: 'long'},\n    {name: 'data', type: 'bytes'},\n    {name: 'sync', type: 'Sync'}\n  ]\n}, OPTS);\n\n// First 4 bytes of an Avro object container file.\nvar MAGIC_BYTES = utils.bufferFrom('Obj\\x01');\n\n// Convenience.\nvar f = util.format;\nvar Tap = utils.Tap;\n\n\n/** Duplex stream for decoding fragments. */\nfunction RawDecoder(schema, opts) {\n  opts = opts || {};\n\n  var noDecode = !!opts.noDecode;\n  stream.Duplex.call(this, {\n    readableObjectMode: !noDecode,\n    allowHalfOpen: false\n  });\n\n  this._type = types.Type.forSchema(schema);\n  this._tap = new Tap(utils.newBuffer(0));\n  this._writeCb = null;\n  this._needPush = false;\n  this._readValue = createReader(noDecode, this._type);\n  this._finished = false;\n\n  this.on('finish', function () {\n    this._finished = true;\n    this._read();\n  });\n}\nutil.inherits(RawDecoder, stream.Duplex);\n\nRawDecoder.prototype._write = function (chunk, encoding, cb) {\n  // Store the write callback and call it when we are done decoding all records\n  // in this chunk. If we call it right away, we risk loading the entire input\n  // in memory. We only need to store the latest callback since the stream API\n  // guarantees that `_write` won't be called again until we call the previous.\n  this._writeCb = cb;\n\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\n  tap.pos = 0;\n  if (this._needPush) {\n    this._needPush = false;\n    this._read();\n  }\n};\n\nRawDecoder.prototype._read = function () {\n  this._needPush = false;\n\n  var tap = this._tap;\n  var pos = tap.pos;\n  var val = this._readValue(tap);\n  if (tap.isValid()) {\n    this.push(val);\n  } else if (!this._finished) {\n    tap.pos = pos;\n    this._needPush = true;\n    if (this._writeCb) {\n      // This should only ever be false on the first read, and only if it\n      // happens before the first write.\n      this._writeCb();\n    }\n  } else {\n    this.push(null);\n  }\n};\n\n\n/** Duplex stream for decoding object container files. */\nfunction BlockDecoder(opts) {\n  opts = opts || {};\n\n  var noDecode = !!opts.noDecode;\n  stream.Duplex.call(this, {\n    allowHalfOpen: true, // For async decompressors.\n    readableObjectMode: !noDecode\n  });\n\n  this._rType = opts.readerSchema !== undefined ?\n    types.Type.forSchema(opts.readerSchema) :\n    undefined;\n  this._wType = null;\n  this._codecs = opts.codecs;\n  this._codec = undefined;\n  this._parseHook = opts.parseHook;\n  this._tap = new Tap(utils.newBuffer(0));\n  this._blockTap = new Tap(utils.newBuffer(0));\n  this._syncMarker = null;\n  this._readValue = null;\n  this._noDecode = noDecode;\n  this._queue = new utils.OrderedQueue();\n  this._decompress = null; // Decompression function.\n  this._index = 0; // Next block index.\n  this._remaining = undefined; // In the current block.\n  this._needPush = false;\n  this._finished = false;\n\n  this.on('finish', function () {\n    this._finished = true;\n    if (this._needPush) {\n      this._read();\n    }\n  });\n}\nutil.inherits(BlockDecoder, stream.Duplex);\n\nBlockDecoder.defaultCodecs = function () {\n  return {\n    'null': function (buf, cb) { cb(null, buf); },\n    'deflate': zlib.inflateRaw\n  };\n};\n\nBlockDecoder.getDefaultCodecs = BlockDecoder.defaultCodecs;\n\nBlockDecoder.prototype._decodeHeader = function () {\n  var tap = this._tap;\n  if (tap.buf.length < MAGIC_BYTES.length) {\n    // Wait until more data arrives.\n    return false;\n  }\n\n  if (!MAGIC_BYTES.equals(tap.buf.slice(0, MAGIC_BYTES.length))) {\n    this.emit('error', new Error('invalid magic bytes'));\n    return false;\n  }\n\n  var header = HEADER_TYPE._read(tap);\n  if (!tap.isValid()) {\n    return false;\n  }\n\n  this._codec = (header.meta['avro.codec'] || 'null').toString();\n  var codecs = this._codecs || BlockDecoder.getDefaultCodecs();\n  this._decompress = codecs[this._codec];\n  if (!this._decompress) {\n    this.emit('error', new Error(f('unknown codec: %s', this._codec)));\n    return;\n  }\n\n  try {\n    var schema = JSON.parse(header.meta['avro.schema'].toString());\n    if (this._parseHook) {\n      schema = this._parseHook(schema);\n    }\n    this._wType = types.Type.forSchema(schema);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n\n  try {\n    this._readValue = createReader(this._noDecode, this._wType, this._rType);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n\n  this._syncMarker = header.sync;\n  this.emit('metadata', this._wType, this._codec, header);\n  return true;\n};\n\nBlockDecoder.prototype._write = function (chunk, encoding, cb) {\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf, chunk]);\n  tap.pos = 0;\n\n  if (!this._decodeHeader()) {\n    process.nextTick(cb);\n    return;\n  }\n\n  // We got the header, switch to block decoding mode. Also, call it directly\n  // in case we already have all the data (in which case `_write` wouldn't get\n  // called anymore).\n  this._write = this._writeChunk;\n  this._write(utils.newBuffer(0), encoding, cb);\n};\n\nBlockDecoder.prototype._writeChunk = function (chunk, encoding, cb) {\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\n  tap.pos = 0;\n\n  var nBlocks = 1;\n  var block;\n  while ((block = tryReadBlock(tap))) {\n    if (!this._syncMarker.equals(block.sync)) {\n      this.emit('error', new Error('invalid sync marker'));\n      return;\n    }\n    nBlocks++;\n    this._decompress(\n      block.data,\n      this._createBlockCallback(block.data.length, block.count, chunkCb)\n    );\n  }\n  chunkCb();\n\n  function chunkCb() {\n    if (!--nBlocks) {\n      cb();\n    }\n  }\n};\n\nBlockDecoder.prototype._createBlockCallback = function (size, count, cb) {\n  var self = this;\n  var index = this._index++;\n\n  return function (cause, data) {\n    if (cause) {\n      var err = new Error(f('%s codec decompression error', self._codec));\n      err.cause = cause;\n      self.emit('error', err);\n      cb();\n    } else {\n      self.emit('block', new BlockInfo(count, data.length, size));\n      self._queue.push(new BlockData(index, data, cb, count));\n      if (self._needPush) {\n        self._read();\n      }\n    }\n  };\n};\n\nBlockDecoder.prototype._read = function () {\n  this._needPush = false;\n\n  var tap = this._blockTap;\n  if (!this._remaining) {\n    var data = this._queue.pop();\n    if (!data || !data.count) {\n      if (this._finished) {\n        this.push(null);\n      } else {\n        this._needPush = true;\n      }\n      if (data) {\n        data.cb();\n      }\n      return; // Wait for more data.\n    }\n    data.cb();\n    this._remaining = data.count;\n    tap.buf = data.buf;\n    tap.pos = 0;\n  }\n\n  this._remaining--;\n  var val;\n  try {\n    val = this._readValue(tap);\n    if (!tap.isValid()) {\n      throw new Error('truncated block');\n    }\n  } catch (err) {\n    this._remaining = 0;\n    this.emit('error', err); // Corrupt data.\n    return;\n  }\n  this.push(val);\n};\n\n\n/** Duplex stream for encoding. */\nfunction RawEncoder(schema, opts) {\n  opts = opts || {};\n\n  stream.Transform.call(this, {\n    writableObjectMode: true,\n    allowHalfOpen: false\n  });\n\n  this._type = types.Type.forSchema(schema);\n  this._writeValue = function (tap, val) {\n    try {\n      this._type._write(tap, val);\n    } catch (err) {\n      this.emit('typeError', err, val, this._type);\n    }\n  };\n  this._tap = new Tap(utils.newBuffer(opts.batchSize || 65536));\n\n  this.on('typeError', function (err) { this.emit('error', err); });\n}\nutil.inherits(RawEncoder, stream.Transform);\n\nRawEncoder.prototype._transform = function (val, encoding, cb) {\n  var tap = this._tap;\n  var buf = tap.buf;\n  var pos = tap.pos;\n\n  this._writeValue(tap, val);\n  if (!tap.isValid()) {\n    if (pos) {\n      // Emit any valid data.\n      this.push(copyBuffer(tap.buf, 0, pos));\n    }\n    var len = tap.pos - pos;\n    if (len > buf.length) {\n      // Not enough space for last written object, need to resize.\n      tap.buf = utils.newBuffer(2 * len);\n    }\n    tap.pos = 0;\n    this._writeValue(tap, val); // Rewrite last failed write.\n  }\n\n  cb();\n};\n\nRawEncoder.prototype._flush = function (cb) {\n  var tap = this._tap;\n  var pos = tap.pos;\n  if (pos) {\n    // This should only ever be false if nothing is written to the stream.\n    this.push(tap.buf.slice(0, pos));\n  }\n  cb();\n};\n\n\n/**\n * Duplex stream to write object container files.\n *\n * @param schema\n * @param opts {Object}\n *\n *  + `blockSize`, uncompressed.\n *  + `codec`\n *  + `codecs`\n *  + `metadata``\n *  + `noCheck`\n *  + `omitHeader`, useful to append to an existing block file.\n */\nfunction BlockEncoder(schema, opts) {\n  opts = opts || {};\n\n  stream.Duplex.call(this, {\n    allowHalfOpen: true, // To support async compressors.\n    writableObjectMode: true\n  });\n\n  var type;\n  if (types.Type.isType(schema)) {\n    type = schema;\n    schema = undefined;\n  } else {\n    // Keep full schema to be able to write it to the header later.\n    type = types.Type.forSchema(schema);\n  }\n\n  this._schema = schema;\n  this._type = type;\n  this._writeValue = function (tap, val) {\n    try {\n      this._type._write(tap, val);\n    } catch (err) {\n      this.emit('typeError', err, val, this._type);\n      return false;\n    }\n    return true;\n  };\n  this._blockSize = opts.blockSize || 65536;\n  this._tap = new Tap(utils.newBuffer(this._blockSize));\n  this._codecs = opts.codecs;\n  this._codec = opts.codec || 'null';\n  this._blockCount = 0;\n  this._syncMarker = opts.syncMarker || new utils.Lcg().nextBuffer(16);\n  this._queue = new utils.OrderedQueue();\n  this._pending = 0;\n  this._finished = false;\n  this._needHeader = false;\n  this._needPush = false;\n\n  this._metadata = opts.metadata || {};\n  if (!MAP_BYTES_TYPE.isValid(this._metadata)) {\n    throw new Error('invalid metadata');\n  }\n\n  var codec = this._codec;\n  this._compress = (this._codecs || BlockEncoder.getDefaultCodecs())[codec];\n  if (!this._compress) {\n    throw new Error(f('unsupported codec: %s', codec));\n  }\n\n  if (opts.omitHeader !== undefined) { // Legacy option.\n    opts.writeHeader = opts.omitHeader ? 'never' : 'auto';\n  }\n  switch (opts.writeHeader) {\n    case false:\n    case 'never':\n      break;\n    case undefined: // Backwards-compatibility (eager default would be better).\n    case 'auto':\n      this._needHeader = true;\n      break;\n    default:\n      this._writeHeader();\n  }\n\n  this.on('finish', function () {\n    this._finished = true;\n    if (this._blockCount) {\n      this._flushChunk();\n    } else if (this._finished && this._needPush) {\n      // We don't need to check `_isPending` since `_blockCount` is always\n      // positive after the first flush.\n      this.push(null);\n    }\n  });\n\n  this.on('typeError', function (err) { this.emit('error', err); });\n}\nutil.inherits(BlockEncoder, stream.Duplex);\n\nBlockEncoder.defaultCodecs = function () {\n  return {\n    'null': function (buf, cb) { cb(null, buf); },\n    'deflate': zlib.deflateRaw\n  };\n};\n\nBlockEncoder.getDefaultCodecs = BlockEncoder.defaultCodecs;\n\nBlockEncoder.prototype._writeHeader = function () {\n  var schema = JSON.stringify(\n    this._schema ? this._schema : this._type.getSchema({exportAttrs: true})\n  );\n  var meta = utils.copyOwnProperties(\n    this._metadata,\n    {'avro.schema': utils.bufferFrom(schema), 'avro.codec': utils.bufferFrom(this._codec)},\n    true // Overwrite.\n  );\n  var Header = HEADER_TYPE.getRecordConstructor();\n  var header = new Header(MAGIC_BYTES, meta, this._syncMarker);\n  this.push(header.toBuffer());\n};\n\nBlockEncoder.prototype._write = function (val, encoding, cb) {\n  if (this._needHeader) {\n    this._writeHeader();\n    this._needHeader = false;\n  }\n\n  var tap = this._tap;\n  var pos = tap.pos;\n  var flushing = false;\n\n  if (this._writeValue(tap, val)) {\n    if (!tap.isValid()) {\n      if (pos) {\n        this._flushChunk(pos, cb);\n        flushing = true;\n      }\n      var len = tap.pos - pos;\n      if (len > this._blockSize) {\n        // Not enough space for last written object, need to resize.\n        this._blockSize = len * 2;\n      }\n      tap.buf = utils.newBuffer(this._blockSize);\n      tap.pos = 0;\n      this._writeValue(tap, val); // Rewrite last failed write.\n    }\n    this._blockCount++;\n  } else {\n    tap.pos = pos;\n  }\n\n  if (!flushing) {\n    cb();\n  }\n};\n\nBlockEncoder.prototype._flushChunk = function (pos, cb) {\n  var tap = this._tap;\n  pos = pos || tap.pos;\n  this._compress(tap.buf.slice(0, pos), this._createBlockCallback(pos, cb));\n  this._blockCount = 0;\n};\n\nBlockEncoder.prototype._read = function () {\n  var self = this;\n  var data = this._queue.pop();\n  if (!data) {\n    if (this._finished && !this._pending) {\n      process.nextTick(function () { self.push(null); });\n    } else {\n      this._needPush = true;\n    }\n    return;\n  }\n\n  this.push(LONG_TYPE.toBuffer(data.count, true));\n  this.push(LONG_TYPE.toBuffer(data.buf.length, true));\n  this.push(data.buf);\n  this.push(this._syncMarker);\n\n  if (!this._finished) {\n    data.cb();\n  }\n};\n\nBlockEncoder.prototype._createBlockCallback = function (size, cb) {\n  var self = this;\n  var index = this._index++;\n  var count = this._blockCount;\n  this._pending++;\n\n  return function (cause, data) {\n    if (cause) {\n      var err = new Error(f('%s codec compression error', self._codec));\n      err.cause = cause;\n      self.emit('error', err);\n      return;\n    }\n    self._pending--;\n    self.emit('block', new BlockInfo(count, size, data.length));\n    self._queue.push(new BlockData(index, data, cb, count));\n    if (self._needPush) {\n      self._needPush = false;\n      self._read();\n    }\n  };\n};\n\n\n// Helpers.\n\n/** Summary information about a block. */\nfunction BlockInfo(count, raw, compressed) {\n  this.valueCount = count;\n  this.rawDataLength = raw;\n  this.compressedDataLength = compressed;\n}\n\n/**\n * An indexed block.\n *\n * This can be used to preserve block order since compression and decompression\n * can cause some some blocks to be returned out of order.\n */\nfunction BlockData(index, buf, cb, count) {\n  this.index = index;\n  this.buf = buf;\n  this.cb = cb;\n  this.count = count | 0;\n}\n\n/** Maybe get a block. */\nfunction tryReadBlock(tap) {\n  var pos = tap.pos;\n  var block = BLOCK_TYPE._read(tap);\n  if (!tap.isValid()) {\n    tap.pos = pos;\n    return null;\n  }\n  return block;\n}\n\n/** Create bytes consumer, either reading or skipping records. */\nfunction createReader(noDecode, writerType, readerType) {\n  if (noDecode) {\n    return (function (skipper) {\n      return function (tap) {\n        var pos = tap.pos;\n        skipper(tap);\n        return tap.buf.slice(pos, tap.pos);\n      };\n    })(writerType._skip);\n  } else if (readerType) {\n    var resolver = readerType.createResolver(writerType);\n    return function (tap) { return resolver._read(tap); };\n  } else {\n    return function (tap) { return writerType._read(tap); };\n  }\n}\n\n/** Copy a buffer. This avoids creating a slice of the original buffer. */\nfunction copyBuffer(buf, pos, len) {\n  var copy = utils.newBuffer(len);\n  buf.copy(copy, 0, pos, pos + len);\n  return copy;\n}\n\n\nmodule.exports = {\n  BLOCK_TYPE: BLOCK_TYPE, // For tests.\n  HEADER_TYPE: HEADER_TYPE, // Idem.\n  MAGIC_BYTES: MAGIC_BYTES, // Idem.\n  streams: {\n    BlockDecoder: BlockDecoder,\n    BlockEncoder: BlockEncoder,\n    RawDecoder: RawDecoder,\n    RawEncoder: RawEncoder\n  }\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/containers.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/files.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/files.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\n\n\n\n/**\n * Filesystem specifics.\n *\n * This module contains functions only used by node.js. It is shimmed by\n * another module when `avsc` is required from `browserify`.\n */\n\nvar fs = __webpack_require__(/*! fs */ \"fs\"),\n    path = __webpack_require__(/*! path */ \"path\");\n\n/** Default (asynchronous) file loading function for assembling IDLs. */\nfunction createImportHook() {\n  var imports = {};\n  return function (fpath, kind, cb) {\n    fpath = path.resolve(fpath);\n    if (imports[fpath]) {\n      // Already imported, return nothing to avoid duplicating attributes.\n      process.nextTick(cb);\n      return;\n    }\n    imports[fpath] = true;\n    fs.readFile(fpath, {encoding: 'utf8'}, cb);\n  };\n}\n\n/**\n * Synchronous file loading function for assembling IDLs.\n *\n * This is only for internal use (inside `specs.parse`). The returned\n * hook should only be called on paths that are guaranteed to exist (where\n * `fs.readFileSync` will not throw, otherwise the calling `assemble` call will\n * throw rather than return the error to the callback).\n */\nfunction createSyncImportHook() {\n  var imports = {};\n  return function (fpath, kind, cb) {\n    fpath = path.resolve(fpath);\n    if (imports[fpath]) {\n      cb();\n    } else {\n      imports[fpath] = true;\n      cb(null, fs.readFileSync(fpath, {encoding: 'utf8'}));\n    }\n  };\n}\n\n\nmodule.exports = {\n  createImportHook: createImportHook,\n  createSyncImportHook: createSyncImportHook,\n  // Proxy a few methods to better shim them for browserify.\n  existsSync: fs.existsSync,\n  readFileSync: fs.readFileSync\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/files.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\n\n\n\n/**\n * Node.js entry point (see `etc/browser/` for browserify's entry points).\n *\n * It also adds Node.js specific functionality (for example a few convenience\n * functions to read Avro files from the local filesystem).\n */\n\nvar containers = __webpack_require__(/*! ./containers */ \"./node_modules/avsc/lib/containers.js\"),\n    services = __webpack_require__(/*! ./services */ \"./node_modules/avsc/lib/services.js\"),\n    specs = __webpack_require__(/*! ./specs */ \"./node_modules/avsc/lib/specs.js\"),\n    types = __webpack_require__(/*! ./types */ \"./node_modules/avsc/lib/types.js\"),\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\n    fs = __webpack_require__(/*! fs */ \"fs\"),\n    util = __webpack_require__(/*! util */ \"util\");\n\n\n/** Parse a schema and return the corresponding type or service. */\nfunction parse(any, opts) {\n  var schemaOrProtocol = specs.read(any);\n  return schemaOrProtocol.protocol ?\n    services.Service.forProtocol(schemaOrProtocol, opts) :\n    types.Type.forSchema(schemaOrProtocol, opts);\n}\n\n/** Extract a container file's header synchronously. */\nfunction extractFileHeader(path, opts) {\n  opts = opts || {};\n\n  var decode = opts.decode === undefined ? true : !!opts.decode;\n  var size = Math.max(opts.size || 4096, 4);\n  var buf = utils.newBuffer(size);\n  var fd = fs.openSync(path, 'r');\n\n  try {\n    var pos = fs.readSync(fd, buf, 0, size);\n    if (pos < 4 || !containers.MAGIC_BYTES.equals(buf.slice(0, 4))) {\n      return null;\n    }\n\n    var tap = new utils.Tap(buf);\n    var header = null;\n    do {\n      header = containers.HEADER_TYPE._read(tap);\n    } while (!isValid());\n    if (decode !== false) {\n      var meta = header.meta;\n      meta['avro.schema'] = JSON.parse(meta['avro.schema'].toString());\n      if (meta['avro.codec'] !== undefined) {\n        meta['avro.codec'] = meta['avro.codec'].toString();\n      }\n    }\n    return header;\n  } finally {\n    fs.closeSync(fd);\n  }\n\n  function isValid() {\n    if (tap.isValid()) {\n      return true;\n    }\n    var len = 2 * tap.buf.length;\n    var buf = utils.newBuffer(len);\n    len = fs.readSync(fd, buf, 0, len);\n    tap.buf = Buffer.concat([tap.buf, buf]);\n    tap.pos = 0;\n    return false;\n  }\n}\n\n/** Readable stream of records from a local Avro file. */\nfunction createFileDecoder(path, opts) {\n  return fs.createReadStream(path)\n    .pipe(new containers.streams.BlockDecoder(opts));\n}\n\n/** Writable stream of records to a local Avro file. */\nfunction createFileEncoder(path, schema, opts) {\n  var encoder = new containers.streams.BlockEncoder(schema, opts);\n  encoder.pipe(fs.createWriteStream(path, {defaultEncoding: 'binary'}));\n  return encoder;\n}\n\n\nmodule.exports = {\n  Service: services.Service,\n  Type: types.Type,\n  assembleProtocol: specs.assembleProtocol,\n  createFileDecoder: createFileDecoder,\n  createFileEncoder: createFileEncoder,\n  discoverProtocol: services.discoverProtocol,\n  extractFileHeader: extractFileHeader,\n  parse: parse,\n  readProtocol: specs.readProtocol,\n  readSchema: specs.readSchema,\n  streams: containers.streams,\n  types: types.builtins,\n  // Deprecated exports.\n  Protocol: services.Service,\n  assemble: util.deprecate(\n    specs.assembleProtocol,\n    'use `assembleProtocol` instead'\n  ),\n  combine: util.deprecate(\n    types.Type.forTypes,\n    'use `Type.forTypes` intead'\n  ),\n  infer: util.deprecate(\n    types.Type.forValue,\n    'use `Type.forValue` instead'\n  )\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/index.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/services.js":
/*!*******************************************!*\
  !*** ./node_modules/avsc/lib/services.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\n\n// TODO: Add broadcast option to client `_emitMessage`, accessible for one-way\n// messages.\n// TODO: Add `server.mount` method to allow combining servers. The API is as\n// follows: a mounted server's (i.e. the method's argument) handlers have lower\n// precedence than the original server (i.e. `this`); the mounted server's\n// middlewares are only invoked for its handlers.\n// TODO: Change `objectMode` client and server channel option to `encoding`\n// (accepting `'netty'`, `'standard'`, and `null` or `undefined`). Perhaps also\n// expose encoders (API TBD).\n\n\n\n/** This module implements Avro's IPC/RPC logic. */\n\nvar types = __webpack_require__(/*! ./types */ \"./node_modules/avsc/lib/types.js\"),\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\n    events = __webpack_require__(/*! events */ \"events\"),\n    stream = __webpack_require__(/*! stream */ \"stream\"),\n    util = __webpack_require__(/*! util */ \"util\");\n\n\n// A few convenience imports.\nvar Tap = utils.Tap;\nvar Type = types.Type;\nvar debug = util.debuglog('avsc:services');\nvar f = util.format;\n\n// Various useful types. We instantiate options once, to share the registry.\nvar OPTS = {namespace: 'org.apache.avro.ipc'};\n\nvar BOOLEAN_TYPE = Type.forSchema('boolean', OPTS);\n\nvar MAP_BYTES_TYPE = Type.forSchema({type: 'map', values: 'bytes'}, OPTS);\n\nvar STRING_TYPE = Type.forSchema('string', OPTS);\n\nvar HANDSHAKE_REQUEST_TYPE = Type.forSchema({\n  name: 'HandshakeRequest',\n  type: 'record',\n  fields: [\n    {name: 'clientHash', type: {name: 'MD5', type: 'fixed', size: 16}},\n    {name: 'clientProtocol', type: ['null', 'string'], 'default': null},\n    {name: 'serverHash', type: 'MD5'},\n    {name: 'meta', type: ['null', MAP_BYTES_TYPE], 'default': null}\n  ]\n}, OPTS);\n\nvar HANDSHAKE_RESPONSE_TYPE = Type.forSchema({\n  name: 'HandshakeResponse',\n  type: 'record',\n  fields: [\n    {\n      name: 'match',\n      type: {\n        name: 'HandshakeMatch',\n        type: 'enum',\n        symbols: ['BOTH', 'CLIENT', 'NONE']\n      }\n    },\n    {name: 'serverProtocol', type: ['null', 'string'], 'default': null},\n    {name: 'serverHash', type: ['null', 'MD5'], 'default': null},\n    {name: 'meta', type: ['null', MAP_BYTES_TYPE], 'default': null}\n  ]\n}, OPTS);\n\n// Prefix used to differentiate between messages when sharing a stream. This\n// length should be smaller than 16. The remainder is used for disambiguating\n// between concurrent messages (the current value, 16, therefore supports ~64k\n// concurrent messages).\nvar PREFIX_LENGTH = 16;\n\n// Internal message, used to check protocol compatibility.\nvar PING_MESSAGE = new Message(\n  '', // Empty name (invalid for other \"normal\" messages).\n  Type.forSchema({name: 'PingRequest', type: 'record', fields: []}, OPTS),\n  Type.forSchema(['string'], OPTS),\n  Type.forSchema('null', OPTS)\n);\n\n/** An Avro message, containing its request, response, etc. */\nfunction Message(name, reqType, errType, resType, oneWay, doc) {\n  this.name = name;\n  if (!Type.isType(reqType, 'record')) {\n    throw new Error('invalid request type');\n  }\n  this.requestType = reqType;\n  if (\n    !Type.isType(errType, 'union') ||\n    !Type.isType(errType.getTypes()[0], 'string')\n  ) {\n    throw new Error('invalid error type');\n  }\n  this.errorType = errType;\n  if (oneWay) {\n    if (!Type.isType(resType, 'null') || errType.getTypes().length > 1) {\n      throw new Error('inapplicable one-way parameter');\n    }\n  }\n  this.responseType = resType;\n  this.oneWay = !!oneWay;\n  this.doc = doc !== undefined ? '' + doc : undefined;\n  Object.freeze(this);\n}\n\nMessage.forSchema = function (name, schema, opts) {\n  opts = opts || {};\n  if (!utils.isValidName(name)) {\n    throw new Error(f('invalid message name: %s', name));\n  }\n  // We use a record with a placeholder name here (the user might have set\n  // `noAnonymousTypes`, so we can't use an anonymous one). We remove it from\n  // the registry afterwards to avoid exposing it outside.\n  if (!Array.isArray(schema.request)) {\n    throw new Error(f('invalid message request: %s', name));\n  }\n  var recordName = f('%s.%sRequest', OPTS.namespace, utils.capitalize(name));\n  var reqType = Type.forSchema({\n    name: recordName,\n    type: 'record',\n    namespace: opts.namespace || '', // Don't leak request namespace.\n    fields: schema.request\n  }, opts);\n  delete opts.registry[recordName];\n  if (!schema.response) {\n    throw new Error(f('invalid message response: %s', name));\n  }\n  var resType = Type.forSchema(schema.response, opts);\n  if (schema.errors !== undefined && !Array.isArray(schema.errors)) {\n    throw new Error(f('invalid message errors: %s', name));\n  }\n  var errType = Type.forSchema(['string'].concat(schema.errors || []), opts);\n  var oneWay = !!schema['one-way'];\n  return new Message(name, reqType, errType, resType, oneWay, schema.doc);\n};\n\nMessage.prototype.schema = Type.prototype.getSchema;\n\nMessage.prototype._attrs = function (opts) {\n  var reqSchema = this.requestType._attrs(opts);\n  var schema = {\n    request: reqSchema.fields,\n    response: this.responseType._attrs(opts)\n  };\n  var msgDoc = this.doc;\n  if (msgDoc !== undefined) {\n    schema.doc = msgDoc;\n  }\n  var errSchema = this.errorType._attrs(opts);\n  if (errSchema.length > 1) {\n    schema.errors = errSchema.slice(1);\n  }\n  if (this.oneWay) {\n    schema['one-way'] = true;\n  }\n  return schema;\n};\n\n// Deprecated.\n\nutils.addDeprecatedGetters(\n  Message,\n  ['name', 'errorType', 'requestType', 'responseType']\n);\n\nMessage.prototype.isOneWay = util.deprecate(\n  function () { return this.oneWay; },\n  'use `.oneWay` directly instead of `.isOneWay()`'\n);\n\n/**\n * An Avro RPC service.\n *\n * This constructor shouldn't be called directly, but via the\n * `Service.forProtocol` method. This function performs little logic to better\n * support efficient copy.\n */\nfunction Service(name, messages, types, ptcl, server) {\n  if (typeof name != 'string') {\n    // Let's be helpful in case this class is instantiated directly.\n    return Service.forProtocol(name, messages);\n  }\n\n  this.name = name;\n  this._messagesByName = messages || {};\n  this.messages = Object.freeze(utils.objectValues(this._messagesByName));\n\n  this._typesByName = types || {};\n  this.types = Object.freeze(utils.objectValues(this._typesByName));\n\n  this.protocol = ptcl;\n  // We cache a string rather than a buffer to not retain an entire slab.\n  this._hashStr = utils.getHash(JSON.stringify(ptcl)).toString('binary');\n  this.doc = ptcl.doc ? '' + ptcl.doc : undefined;\n\n  // We add a server to each protocol for backwards-compatibility (to allow the\n  // use of `protocol.on`). This covers all cases except the use of the\n  // `strictErrors` option, which requires moving to the new API.\n  this._server = server || this.createServer({silent: true});\n  Object.freeze(this);\n}\n\nService.Client = Client;\n\nService.Server = Server;\n\nService.compatible = function (clientSvc, serverSvc) {\n  try {\n    createReaders(clientSvc, serverSvc);\n  } catch (err) {\n    return false;\n  }\n  return true;\n};\n\nService.forProtocol = function (ptcl, opts) {\n  opts = opts || {};\n\n  var name = ptcl.protocol;\n  if (!name) {\n    throw new Error('missing protocol name');\n  }\n  if (ptcl.namespace !== undefined) {\n    opts.namespace = ptcl.namespace;\n  } else {\n    var match = /^(.*)\\.[^.]+$/.exec(name);\n    if (match) {\n      opts.namespace = match[1];\n    }\n  }\n  name = utils.qualify(name, opts.namespace);\n\n  if (ptcl.types) {\n    ptcl.types.forEach(function (obj) { Type.forSchema(obj, opts); });\n  }\n  var msgs;\n  if (ptcl.messages) {\n    msgs = {};\n    Object.keys(ptcl.messages).forEach(function (key) {\n      msgs[key] = Message.forSchema(key, ptcl.messages[key], opts);\n    });\n  }\n\n  return new Service(name, msgs, opts.registry, ptcl);\n};\n\nService.isService = function (any) {\n  // Not fool-proof but likely sufficient.\n  return !!any && any.hasOwnProperty('_hashStr');\n};\n\nService.prototype.createClient = function (opts) {\n  var client = new Client(this, opts);\n  process.nextTick(function () {\n    // We delay this processing such that we can attach handlers to the client\n    // before any channels get created.\n    if (opts && opts.server) {\n      // Convenience in-memory client. This can be useful to make requests\n      // relatively efficiently to an in-process server. Note that it is still\n      // is less efficient than direct method calls (because of the\n      // serialization, which does provide \"type-safety\" though).\n      var obj = {objectMode: true};\n      var pts = [new stream.PassThrough(obj), new stream.PassThrough(obj)];\n      opts.server.createChannel({readable: pts[0], writable: pts[1]}, obj);\n      client.createChannel({readable: pts[1], writable: pts[0]}, obj);\n    } else if (opts && opts.transport) {\n      // Convenience functionality for the common single channel use-case: we\n      // add a single channel using default options to the client.\n      client.createChannel(opts.transport);\n    }\n  });\n  return client;\n};\n\nService.prototype.createServer = function (opts) {\n  return new Server(this, opts);\n};\n\nObject.defineProperty(Service.prototype, 'hash', {\n  enumerable: true,\n  get: function () { return utils.bufferFrom(this._hashStr, 'binary'); }\n});\n\nService.prototype.message = function (name) {\n  return this._messagesByName[name];\n};\n\nService.prototype.type = function (name) {\n  return this._typesByName[name];\n};\n\nService.prototype.inspect = function () {\n  return f('<Service %j>', this.name);\n};\n\n// Deprecated methods.\n\nutils.addDeprecatedGetters(\n  Service,\n  ['message', 'messages', 'name', 'type', 'types']\n);\n\nService.prototype.createEmitter = util.deprecate(\n  function (transport, opts) {\n    opts = opts || {};\n    var client = this.createClient({\n      cache: opts.cache,\n      buffering: false,\n      strictTypes: opts.strictErrors,\n      timeout: opts.timeout\n    });\n    var channel = client.createChannel(transport, opts);\n    forwardErrors(client, channel);\n    return channel;\n  },\n  'use `.createClient()` instead of `.createEmitter()`'\n);\n\nService.prototype.createListener = util.deprecate(\n  function (transport, opts) {\n    if (opts && opts.strictErrors) {\n      throw new Error('use `.createServer()` to support strict errors');\n    }\n    return this._server.createChannel(transport, opts);\n  },\n  'use `.createServer().createChannel()` instead of `.createListener()`'\n);\n\nService.prototype.emit = util.deprecate(\n  function (name, req, channel, cb) {\n    if (!channel || !this.equals(channel.client._svc$)) {\n      throw new Error('invalid emitter');\n    }\n\n    var client = channel.client;\n    // In case the method is overridden.\n    Client.prototype.emitMessage.call(client, name, req, cb && cb.bind(this));\n    return channel.getPending();\n  },\n  'create a client via `.createClient()` to emit messages instead of `.emit()`'\n);\n\nService.prototype.equals = util.deprecate(\n  function (any) {\n    return (\n      Service.isService(any) &&\n      this.getFingerprint().equals(any.getFingerprint())\n    );\n  },\n  'equality testing is deprecated, compare the `.protocol`s instead'\n);\n\nService.prototype.getFingerprint = util.deprecate(\n  function (algorithm) {\n    return utils.getHash(JSON.stringify(this.protocol), algorithm);\n  },\n  'use `.hash` instead of `.getFingerprint()`'\n);\n\nService.prototype.getSchema = util.deprecate(\n  Type.prototype.getSchema,\n  'use `.protocol` instead of `.getSchema()`'\n);\n\nService.prototype.on = util.deprecate(\n  function (name, handler) {\n    var self = this; // This protocol.\n    this._server.onMessage(name, function (req, cb) {\n      return handler.call(self, req, this.channel, cb);\n    });\n    return this;\n  },\n  'use `.createServer().onMessage()` instead of `.on()`'\n);\n\nService.prototype.subprotocol = util.deprecate(\n  function () {\n    var parent = this._server;\n    var opts = {strictTypes: parent._strict, cache: parent._cache};\n    var server = new Server(parent.service, opts);\n    server._handlers = Object.create(parent._handlers);\n    return new Service(\n      this.name,\n      this._messagesByName,\n      this._typesByName,\n      this.protocol,\n      server\n    );\n  },\n  '`.subprotocol()` will be removed in 5.1'\n);\n\nService.prototype._attrs = function (opts) {\n  var ptcl = {protocol: this.name};\n\n  var types = [];\n  this.types.forEach(function (t) {\n    if (t.getName() === undefined) {\n      // Don't include any unnamed types (e.g. primitives).\n      return;\n    }\n    var typeSchema = t._attrs(opts);\n    if (typeof typeSchema != 'string') {\n      // Some of the named types might already have been defined in a\n      // previous type, in this case we don't include its reference.\n      types.push(typeSchema);\n    }\n  });\n  if (types.length) {\n    ptcl.types = types;\n  }\n\n  var msgNames = Object.keys(this._messagesByName);\n  if (msgNames.length) {\n    ptcl.messages = {};\n    msgNames.forEach(function (name) {\n      ptcl.messages[name] = this._messagesByName[name]._attrs(opts);\n    }, this);\n  }\n\n  if (opts && opts.exportAttrs && this.doc !== undefined) {\n    ptcl.doc = this.doc;\n  }\n  return ptcl;\n};\n\n/** Function to retrieve a remote service's protocol. */\nfunction discoverProtocol(transport, opts, cb) {\n  if (cb === undefined && typeof opts == 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n\n  var svc = new Service({protocol: 'Empty'}, OPTS);\n  var ptclStr;\n  svc.createClient({timeout: opts && opts.timeout})\n    .createChannel(transport, {\n      scope: opts && opts.scope,\n      endWritable: typeof transport == 'function' // Stateless transports only.\n    }).once('handshake', function (hreq, hres) {\n        ptclStr = hres.serverProtocol;\n        this.destroy(true);\n      })\n      .once('eot', function (pending, err) {\n        // Stateless transports will throw an interrupted error when the\n        // channel is destroyed, we ignore it here.\n        if (err && !/interrupted/.test(err)) {\n          cb(err); // Likely timeout.\n        } else {\n          cb(null, JSON.parse(ptclStr));\n        }\n      });\n}\n\n/** Load-balanced message sender. */\nfunction Client(svc, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  // We have to suffix all client properties to be safe, since the message\n  // names aren't prefixed with clients (unlike servers).\n  this._svc$ = svc;\n  this._channels$ = []; // Active channels.\n  this._fns$ = []; // Middleware functions.\n\n  this._buffering$ = !!opts.buffering;\n  this._cache$ = opts.cache || {}; // For backwards compatibility.\n  this._policy$ = opts.channelPolicy;\n  this._strict$ = !!opts.strictTypes;\n  this._timeout$ = utils.getOption(opts, 'timeout', 10000);\n\n  if (opts.remoteProtocols) {\n    insertRemoteProtocols(this._cache$, opts.remoteProtocols, svc, true);\n  }\n\n  this._svc$.messages.forEach(function (msg) {\n    this[msg.name] = this._createMessageHandler$(msg);\n  }, this);\n}\nutil.inherits(Client, events.EventEmitter);\n\nClient.prototype.activeChannels = function () {\n  return this._channels$.slice();\n};\n\nClient.prototype.createChannel = function (transport, opts) {\n  var objectMode = opts && opts.objectMode;\n  var channel;\n  if (typeof transport == 'function') {\n    var writableFactory;\n    if (objectMode) {\n      writableFactory = transport;\n    } else {\n      // We provide a default standard-compliant codec. This should support\n      // most use-cases (for example when speaking to the official Java and\n      // Python implementations over HTTP, or when this library is used for\n      // both the emitting and listening sides).\n      writableFactory = function (cb) {\n        var encoder = new FrameEncoder();\n        var writable = transport(function (err, readable) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          // Since the decoder isn't exposed (so can't have an error handler\n          // attached, we forward any errors to the client). Since errors would\n          // only get thrown when the decoder flushes (if there is trailing\n          // data), at which point the source will have ended, there is no need\n          // to add re-piping logic (destination errors trigger an unpipe).\n          var decoder = new FrameDecoder()\n            .once('error', function (err) { channel.destroy(err); });\n          cb(null, readable.pipe(decoder));\n        });\n        if (writable) {\n          encoder.pipe(writable);\n          return encoder;\n        }\n      };\n    }\n    channel = new StatelessClientChannel(this, writableFactory, opts);\n  } else {\n    var readable, writable;\n    if (isStream(transport)) {\n      readable = writable = transport;\n    } else {\n      readable = transport.readable;\n      writable = transport.writable;\n    }\n    if (!objectMode) {\n      // To ease communication with Java servers, we provide a default codec\n      // compatible with Java servers' `NettyTransportCodec`'s implementation.\n      var decoder = new NettyDecoder();\n      readable = readable.pipe(decoder);\n      var encoder = new NettyEncoder();\n      encoder.pipe(writable);\n      writable = encoder;\n    }\n    channel = new StatefulClientChannel(this, readable, writable, opts);\n    if (!objectMode) {\n      // Since we never expose the automatically created encoder and decoder,\n      // we release them ourselves here when the channel ends. (Unlike for\n      // stateless channels, it is conceivable for the underlying stream to be\n      // reused afterwards).\n      channel.once('eot', function () {\n        readable.unpipe(decoder);\n        encoder.unpipe(writable);\n      });\n      // We also forward any (trailing data) error.\n      decoder.once('error', function (err) { channel.destroy(err); });\n    }\n  }\n  var channels = this._channels$;\n  channels.push(channel);\n  channel.once('_drain', function () {\n    // Remove the channel from the list of active ones.\n    channels.splice(channels.indexOf(this), 1);\n  });\n  // We restrict buffering to startup, otherwise we risk silently hiding errors\n  // (especially since channel timeouts don't apply yet).\n  this._buffering$ = false;\n  this.emit('channel', channel);\n  return channel;\n};\n\nClient.prototype.destroyChannels = function (opts) {\n  this._channels$.forEach(function (channel) {\n    channel.destroy(opts && opts.noWait);\n  });\n};\n\nClient.prototype.emitMessage = function (name, req, opts, cb) {\n  var msg = getExistingMessage(this._svc$, name);\n  var wreq = new WrappedRequest(msg, {}, req);\n  this._emitMessage$(wreq, opts, cb);\n};\n\nClient.prototype.remoteProtocols = function () {\n  return getRemoteProtocols(this._cache$, true);\n};\n\nObject.defineProperty(Client.prototype, 'service', {\n  enumerable: true,\n  get: function () { return this._svc$; }\n});\n\nClient.prototype.use = function (/* fn ... */) {\n  var i, l, fn;\n  for (i = 0, l = arguments.length; i < l; i++) {\n    fn = arguments[i];\n    this._fns$.push(fn.length < 3 ? fn(this) : fn);\n  }\n  return this;\n};\n\nClient.prototype._emitMessage$ = function (wreq, opts, cb) {\n  // Common logic between `client.emitMessage` and the \"named\" message methods.\n  if (!cb && typeof opts === 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  var self = this;\n  var channels = this._channels$;\n  var numChannels = channels.length;\n  if (!numChannels) {\n    if (this._buffering$) {\n      debug('no active client channels, buffering call');\n      this.once('channel', function () {\n        this._emitMessage$(wreq, opts, cb);\n      });\n    } else {\n      var err = new Error('no active channels');\n      process.nextTick(function () {\n        if (cb) {\n          cb.call(new CallContext(wreq._msg), err);\n        } else {\n          self.emit('error', err);\n        }\n      });\n    }\n    return;\n  }\n\n  opts = opts || {};\n  if (opts.timeout === undefined) {\n    opts.timeout = this._timeout$;\n  }\n\n  var channel;\n  if (numChannels === 1) {\n    // Common case, optimized away.\n    channel = channels[0];\n  } else if (this._policy$) {\n    channel = this._policy$(this._channels$.slice());\n    if (!channel) {\n      debug('policy returned no channel, skipping call');\n      return;\n    }\n  } else {\n    // Random selection, cheap and likely good enough for most use-cases.\n    channel = channels[Math.floor(Math.random() * numChannels)];\n  }\n\n  channel._emit(wreq, opts, function (err, wres) {\n    var ctx = this; // Call context.\n    var errType = ctx.message.errorType;\n    if (err) {\n      // System error, likely the message wasn't sent (or an error occurred\n      // while decoding the response).\n      if (self._strict$) {\n        err = errType.clone(err.message, {wrapUnions: true});\n      }\n      done(err);\n      return;\n    }\n    if (!wres) {\n      // This is a one way message.\n      done();\n      return;\n    }\n    // Message transmission succeeded, we transmit the message data; massaging\n    // any error strings into actual `Error` objects in non-strict mode.\n    err = wres.error;\n    if (!self._strict$) {\n      // Try to coerce an eventual error into more idiomatic JavaScript types:\n      // `undefined` becomes `null` and a remote string \"system\" error is\n      // wrapped inside an actual `Error` object.\n      if (err === undefined) {\n        err = null;\n      } else {\n        if (Type.isType(errType, 'union:unwrapped')) {\n          if (typeof err == 'string') {\n            err = new Error(err);\n          }\n        } else if (err && err.string && typeof err.string == 'string') {\n          err = new Error(err.string);\n        }\n      }\n    }\n    done(err, wres.response);\n\n    function done(err, res) {\n      if (cb) {\n        cb.call(ctx, err, res);\n      } else if (err) {\n        self.emit('error', err);\n      }\n    }\n  });\n};\n\nClient.prototype._createMessageHandler$ = function (msg) {\n  // jshint -W054\n  var fields = msg.requestType.getFields();\n  var names = fields.map(function (f) { return f.getName(); });\n  var body = 'return function ' + msg.name + '(';\n  if (names.length) {\n    body += names.join(', ') + ', ';\n  }\n  body += 'opts, cb) {\\n';\n  body += '  var req = {';\n  body += names.map(function (n) { return n + ': ' + n; }).join(', ');\n  body += '};\\n';\n  body += '  return this.emitMessage(\\'' + msg.name + '\\', req, opts, cb);\\n';\n  body += '};';\n  return (new Function(body))();\n};\n\n/** Message receiver. */\nfunction Server(svc, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  this.service = svc;\n  this._handlers = {};\n  this._fns = []; // Middleware functions.\n  this._channels = {}; // Active channels.\n  this._nextChannelId = 1;\n\n  this._cache = opts.cache || {}; // Deprecated.\n  this._defaultHandler = opts.defaultHandler;\n  this._sysErrFormatter = opts.systemErrorFormatter;\n  this._silent = !!opts.silent;\n  this._strict = !!opts.strictTypes;\n\n  if (opts.remoteProtocols) {\n    insertRemoteProtocols(this._cache, opts.remoteProtocols, svc, false);\n  }\n\n  svc.messages.forEach(function (msg) {\n    var name = msg.name;\n    if (!opts.noCapitalize) {\n      name = utils.capitalize(name);\n    }\n    this['on' + name] = this._createMessageHandler(msg);\n  }, this);\n}\nutil.inherits(Server, events.EventEmitter);\n\nServer.prototype.activeChannels = function () {\n  return utils.objectValues(this._channels);\n};\n\nServer.prototype.createChannel = function (transport, opts) {\n  var objectMode = opts && opts.objectMode;\n  var channel;\n  if (typeof transport == 'function') {\n    var readableFactory;\n    if (objectMode) {\n      readableFactory = transport;\n    } else {\n      readableFactory = function (cb) {\n        var decoder = new FrameDecoder()\n          .once('error', function (err) { channel.destroy(err); });\n        return transport(function (err, writable) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          var encoder = new FrameEncoder();\n          encoder.pipe(writable);\n          cb(null, encoder);\n        }).pipe(decoder);\n      };\n    }\n    channel = new StatelessServerChannel(this, readableFactory, opts);\n  } else {\n    var readable, writable;\n    if (isStream(transport)) {\n      readable = writable = transport;\n    } else {\n      readable = transport.readable;\n      writable = transport.writable;\n    }\n    if (!objectMode) {\n      var decoder = new NettyDecoder();\n      readable = readable.pipe(decoder);\n      var encoder = new NettyEncoder();\n      encoder.pipe(writable);\n      writable = encoder;\n    }\n    channel = new StatefulServerChannel(this, readable, writable, opts);\n    if (!objectMode) {\n      // Similar to client channels, since we never expose the encoder and\n      // decoder, we must release them ourselves here.\n      channel.once('eot', function () {\n        readable.unpipe(decoder);\n        encoder.unpipe(writable);\n      });\n      decoder.once('error', function (err) { channel.destroy(err); });\n    }\n  }\n\n  if (!this.listeners('error').length) {\n    this.on('error', this._onError);\n  }\n  var channelId = this._nextChannelId++;\n  var channels = this._channels;\n  channels[channelId] = channel\n    .once('eot', function () { delete channels[channelId]; });\n  this.emit('channel', channel);\n  return channel;\n};\n\nServer.prototype.onMessage = function (name, handler) {\n  getExistingMessage(this.service, name); // Check message existence.\n  this._handlers[name] = handler;\n  return this;\n};\n\nServer.prototype.remoteProtocols = function () {\n  return getRemoteProtocols(this._cache, false);\n};\n\nServer.prototype.use = function (/* fn ... */) {\n  var i, l, fn;\n  for (i = 0, l = arguments.length; i < l; i++) {\n    fn = arguments[i];\n    this._fns.push(fn.length < 3 ? fn(this) : fn);\n  }\n  return this;\n};\n\nServer.prototype._createMessageHandler = function (msg) {\n  // jshint -W054\n  var name = msg.name;\n  var fields = msg.requestType.fields;\n  var numArgs = fields.length;\n  var args = fields.length ?\n    ', ' + fields.map(function (f) { return 'req.' + f.name; }).join(', ') :\n    '';\n  // We are careful to not lose the initial handler's number of arguments (or\n  // more specifically whether it would have access to the callback or not).\n  // This is useful to implement \"smart promisification\" logic downstream.\n  var body = 'return function (handler) {\\n';\n  body += '  if (handler.length > ' + numArgs + ') {\\n';\n  body += '    return this.onMessage(\\'' + name + '\\', function (req, cb) {\\n';\n  body += '      return handler.call(this' + args + ', cb);\\n';\n  body += '    });\\n';\n  body += '  } else {\\n';\n  body += '    return this.onMessage(\\'' + name + '\\', function (req) {\\n';\n  body += '      return handler.call(this' + args + ');\\n';\n  body += '    });\\n';\n  body += '  }\\n';\n  body += '};\\n';\n  return (new Function(body))();\n};\n\nServer.prototype._onError = function (err) {\n  /* istanbul ignore if */\n  if (!this._silent && err.rpcCode !== 'UNKNOWN_PROTOCOL') {\n    console.error();\n    if (err.rpcCode) {\n      console.error(err.rpcCode);\n      console.error(err.cause);\n    } else {\n      console.error('INTERNAL_SERVER_ERROR');\n      console.error(err);\n    }\n  }\n};\n\n/** Base message emitter class. See below for the two available variants. */\nfunction ClientChannel(client, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  this.client = client;\n  this.timeout = utils.getOption(opts, 'timeout', client._timeout$);\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\n  this._prefix = normalizedPrefix(opts.scope);\n\n  var cache = client._cache$;\n  var clientSvc = client._svc$;\n  var hash = opts.serverHash;\n  if (!hash) {\n    hash = clientSvc.hash;\n  }\n  var adapter = cache[hash];\n  if (!adapter) {\n    // This might happen even if the server hash option was set if the cache\n    // doesn't contain the corresponding adapter. In this case we fall back to\n    // the client's protocol (as mandated by the spec).\n    hash = clientSvc.hash;\n    adapter = cache[hash] = new Adapter(clientSvc, clientSvc, hash);\n  }\n  this._adapter = adapter;\n\n  this._registry = new Registry(this, PREFIX_LENGTH);\n  this.pending = 0;\n  this.destroyed = false;\n  this.draining = false;\n  this.once('_eot', function (pending, err) {\n    // Since this listener is only run once, we will only forward an error if\n    // it is present during the initial `destroy` call, which is OK.\n    debug('client channel EOT');\n    this.destroyed = true;\n    this.emit('eot', pending, err);\n  });\n}\nutil.inherits(ClientChannel, events.EventEmitter);\n\nClientChannel.prototype.destroy = function (noWait) {\n  debug('destroying client channel');\n  if (!this.draining) {\n    this.draining = true;\n    this.emit('_drain');\n  }\n  var registry = this._registry;\n  var pending = this.pending;\n  if (noWait) {\n    registry.clear();\n  }\n  if (noWait || !pending) {\n    if (isError(noWait)) {\n      debug('fatal client channel error: %s', noWait);\n      this.emit('_eot', pending, noWait);\n    } else {\n      this.emit('_eot', pending);\n    }\n  } else {\n    debug('client channel entering drain mode (%s pending)', pending);\n  }\n};\n\nClientChannel.prototype.ping = function (timeout, cb) {\n  if (!cb && typeof timeout == 'function') {\n    cb = timeout;\n    timeout = undefined;\n  }\n  var self = this;\n  var wreq = new WrappedRequest(PING_MESSAGE);\n  this._emit(wreq, {timeout: timeout}, function (err) {\n    if (cb) {\n      cb.call(self, err);\n    } else if (err) {\n      self.destroy(err);\n    }\n  });\n};\n\nClientChannel.prototype._createHandshakeRequest = function (adapter, noSvc) {\n  var svc = this.client._svc$;\n  return {\n    clientHash: svc.hash,\n    clientProtocol: noSvc ? null : JSON.stringify(svc.protocol),\n    serverHash: adapter._hash\n  };\n};\n\nClientChannel.prototype._emit = function (wreq, opts, cb) {\n  var msg = wreq._msg;\n  var wres = msg.oneWay ? undefined : new WrappedResponse(msg, {});\n  var ctx = new CallContext(msg, this);\n  var self = this;\n  this.pending++;\n  process.nextTick(function () {\n    if (!msg.name) {\n      // Ping request, bypass middleware.\n      onTransition(wreq, wres, onCompletion);\n    } else {\n      self.emit('outgoingCall', ctx, opts);\n      var fns = self.client._fns$;\n      debug('starting client middleware chain (%s middleware)', fns.length);\n      chainMiddleware({\n        fns: fns,\n        ctx: ctx,\n        wreq: wreq,\n        wres: wres,\n        onTransition: onTransition,\n        onCompletion: onCompletion,\n        onError: onError\n      });\n    }\n  });\n\n  function onTransition(wreq, wres, prev) {\n    // Serialize the message.\n    var err, reqBuf;\n    if (self.destroyed) {\n      err = new Error('channel destroyed');\n    } else {\n      try {\n        reqBuf = wreq.toBuffer();\n      } catch (cause) {\n        err = serializationError(\n          f('invalid %j request', msg.name),\n          wreq,\n          [\n            {name: 'headers', type: MAP_BYTES_TYPE},\n            {name: 'request', type: msg.requestType}\n          ]\n        );\n      }\n    }\n    if (err) {\n      prev(err);\n      return;\n    }\n\n    // Generate the response callback.\n    var timeout = (opts && opts.timeout !== undefined) ?\n      opts.timeout :\n      self.timeout;\n    var id = self._registry.add(timeout, function (err, resBuf, adapter) {\n      if (!err && !msg.oneWay) {\n        try {\n          adapter._decodeResponse(resBuf, wres, msg);\n        } catch (cause) {\n          err = cause;\n        }\n      }\n      prev(err);\n    });\n    id |= self._prefix;\n\n    debug('sending message %s', id);\n    self._send(id, reqBuf, !!msg && msg.oneWay);\n  }\n\n  function onCompletion(err) {\n    self.pending--;\n    cb.call(ctx, err, wres);\n    if (self.draining && !self.destroyed && !self.pending) {\n      self.destroy();\n    }\n  }\n\n  function onError(err) {\n    // This will happen if a middleware callback is called multiple times. We\n    // forward the error to the client rather than emit it on the channel since\n    // middleware are a client-level abstraction, so better handled there.\n    self.client.emit('error', err, self);\n  }\n};\n\nClientChannel.prototype._getAdapter = function (hres) {\n  var hash = hres.serverHash;\n  var cache = this.client._cache$;\n  var adapter = cache[hash];\n  if (adapter) {\n    return adapter;\n  }\n  var ptcl = JSON.parse(hres.serverProtocol);\n  var serverSvc = Service.forProtocol(ptcl);\n  adapter = new Adapter(this.client._svc$, serverSvc, hash, true);\n  return cache[hash] = adapter;\n};\n\nClientChannel.prototype._matchesPrefix = function (id) {\n  return matchesPrefix(id, this._prefix);\n};\n\nClientChannel.prototype._send = utils.abstractFunction;\n\n// Deprecated.\n\nutils.addDeprecatedGetters(ClientChannel, ['pending', 'timeout']);\n\nClientChannel.prototype.getCache = util.deprecate(\n  function () { return this.client._cache$; },\n  'use `.remoteProtocols()` instead of `.getCache()`'\n);\n\nClientChannel.prototype.getProtocol = util.deprecate(\n  function () {\n    return this.client._svc$;\n  },\n  'use `.service` instead or `.getProtocol()`'\n);\n\nClientChannel.prototype.isDestroyed = util.deprecate(\n  function () { return this.destroyed; },\n  'use `.destroyed` instead of `.isDestroyed`'\n);\n\n/**\n * Factory-based client channel.\n *\n * This channel doesn't keep a persistent connection to the server and requires\n * prepending a handshake to each message emitted. Usage examples include\n * talking to an HTTP server (where the factory returns an HTTP request).\n *\n * Since each message will use its own writable/readable stream pair, the\n * advantage of this channel is that it is able to keep track of which response\n * corresponds to each request without relying on transport ordering. In\n * particular, this means these channels are compatible with any server\n * implementation.\n */\nfunction StatelessClientChannel(client, writableFactory, opts) {\n  ClientChannel.call(this, client, opts);\n  this._writableFactory = writableFactory;\n\n  if (!opts || !opts.noPing) {\n    // Ping the server to check whether the remote protocol is compatible.\n    // If not, this will throw an error on the channel.\n    debug('emitting ping request');\n    this.ping();\n  }\n}\nutil.inherits(StatelessClientChannel, ClientChannel);\n\nStatelessClientChannel.prototype._send = function (id, reqBuf) {\n  var cb = this._registry.get(id);\n  var adapter = this._adapter;\n  var self = this;\n  process.nextTick(emit);\n  return true;\n\n  function emit(retry) {\n    if (self.destroyed) {\n      // The request's callback will already have been called.\n      return;\n    }\n\n    var hreq = self._createHandshakeRequest(adapter, !retry);\n\n    var writable = self._writableFactory.call(self, function (err, readable) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      readable.on('data', function (obj) {\n        debug('received response %s', obj.id);\n        // We don't check that the prefix matches since the ID likely hasn't\n        // been propagated to the response (see default stateless codec).\n        var buf = Buffer.concat(obj.payload);\n        try {\n          var parts = readHead(HANDSHAKE_RESPONSE_TYPE, buf);\n          var hres = parts.head;\n          if (hres.serverHash) {\n            adapter = self._getAdapter(hres);\n          }\n        } catch (cause) {\n          cb(cause);\n          return;\n        }\n        var match = hres.match;\n        debug('handshake match: %s', match);\n        self.emit('handshake', hreq, hres);\n        if (match === 'NONE') {\n          // Try again, including the full protocol this time.\n          process.nextTick(function() { emit(true); });\n        } else {\n          // Change the default adapter.\n          self._adapter = adapter;\n          cb(null, parts.tail, adapter);\n        }\n      });\n    });\n    if (!writable) {\n      cb(new Error('invalid writable stream'));\n      return;\n    }\n    writable.write({\n      id: id,\n      payload: [HANDSHAKE_REQUEST_TYPE.toBuffer(hreq), reqBuf]\n    });\n    if (self._endWritable) {\n      writable.end();\n    }\n  }\n};\n\n/**\n * Multiplexing client channel.\n *\n * These channels reuse the same streams (both readable and writable) for all\n * messages. This avoids a lot of overhead (e.g. creating new connections,\n * re-issuing handshakes) but requires the underlying transport to support\n * forwarding message IDs.\n */\nfunction StatefulClientChannel(client, readable, writable, opts) {\n  ClientChannel.call(this, client, opts);\n  this._readable = readable;\n  this._writable = writable;\n  this._connected = !!(opts && opts.noPing);\n  this._readable.on('end', onEnd);\n  this._writable.on('finish', onFinish);\n\n  var self = this;\n  var timer = null;\n  this.once('eot', function () {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    if (!self._connected) {\n      // Clear any buffered calls (they are guaranteed to error out when\n      // reaching the transition phase).\n      self.emit('_ready');\n    }\n    // Remove references to this channel to avoid potential memory leaks.\n    this._writable.removeListener('finish', onFinish);\n    if (this._endWritable) {\n      debug('ending transport');\n      this._writable.end();\n    }\n    this._readable\n      .removeListener('data', onPing)\n      .removeListener('data', onMessage)\n      .removeListener('end', onEnd);\n  });\n\n  var hreq; // For handshake events.\n  if (this._connected) {\n    this._readable.on('data', onMessage);\n  } else {\n    this._readable.on('data', onPing);\n    process.nextTick(ping);\n    if (self.timeout) {\n      timer = setTimeout(function () {\n        self.destroy(new Error('timeout'));\n      }, self.timeout);\n    }\n  }\n\n  function ping(retry) {\n    if (self.destroyed) {\n      return;\n    }\n    hreq = self._createHandshakeRequest(self._adapter, !retry);\n    var payload = [\n      HANDSHAKE_REQUEST_TYPE.toBuffer(hreq),\n      utils.bufferFrom([0, 0]) // No header, no data (empty message name).\n    ];\n    // We can use a static ID here since we are guaranteed that this message is\n    // the only one on the channel (for this scope at least).\n    self._writable.write({id: self._prefix, payload: payload});\n  }\n\n  function onPing(obj) {\n    if (!self._matchesPrefix(obj.id)) {\n      debug('discarding unscoped response %s (still connecting)', obj.id);\n      return;\n    }\n    var buf = Buffer.concat(obj.payload);\n    try {\n      var hres = readHead(HANDSHAKE_RESPONSE_TYPE, buf).head;\n      if (hres.serverHash) {\n        self._adapter = self._getAdapter(hres);\n      }\n    } catch (cause) {\n      // This isn't a recoverable error.\n      self.destroy(cause);\n      return;\n    }\n    var match = hres.match;\n    debug('handshake match: %s', match);\n    self.emit('handshake', hreq, hres);\n    if (match === 'NONE') {\n      process.nextTick(function () { ping(true); });\n    } else {\n      debug('successfully connected');\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      self._readable.removeListener('data', onPing).on('data', onMessage);\n      self._connected = true;\n      self.emit('_ready');\n      hreq = null; // Release reference.\n    }\n  }\n\n  // Callback used after a connection has been established.\n  function onMessage(obj) {\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      debug('discarding unscoped message %s', id);\n      return;\n    }\n    var cb = self._registry.get(id);\n    if (cb) {\n      process.nextTick(function () {\n        debug('received message %s', id);\n        // Ensure that the initial callback gets called asynchronously, even\n        // for completely synchronous transports (otherwise the number of\n        // pending requests will sometimes be inconsistent between stateful and\n        // stateless transports).\n        cb(null, Buffer.concat(obj.payload), self._adapter);\n      });\n    }\n  }\n\n  function onEnd() { self.destroy(true); }\n  function onFinish() { self.destroy(); }\n}\nutil.inherits(StatefulClientChannel, ClientChannel);\n\nStatefulClientChannel.prototype._emit = function () {\n  // Override this method to allow calling `_emit` even before the channel is\n  // connected. Note that we don't perform this logic in `_send` since we want\n  // to guarantee that `'handshake'` events are emitted before any\n  // `'outgoingCall'` events.\n  if (this._connected || this.draining) {\n    ClientChannel.prototype._emit.apply(this, arguments);\n  } else {\n    debug('queuing request');\n    var args = [];\n    var i, l;\n    for (i = 0, l = arguments.length; i < l; i++) {\n      args.push(arguments[i]);\n    }\n    this.once('_ready', function () { this._emit.apply(this, args); });\n  }\n};\n\nStatefulClientChannel.prototype._send = function (id, reqBuf, oneWay) {\n  if (oneWay) {\n    var self = this;\n    // Clear the callback, passing in an empty header.\n    process.nextTick(function () {\n      self._registry.get(id)(null, utils.bufferFrom([0, 0, 0]), self._adapter);\n    });\n  }\n  return this._writable.write({id: id, payload: [reqBuf]});\n};\n\n/** The server-side emitter equivalent. */\nfunction ServerChannel(server, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  this.server = server;\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\n  this._prefix = normalizedPrefix(opts.scope);\n\n  var cache = server._cache;\n  var svc = server.service;\n  var hash = svc.hash;\n  if (!cache[hash]) {\n    // Add the channel's protocol to the cache if it isn't already there. This\n    // will save a handshake the first time on channels with the same protocol.\n    cache[hash] = new Adapter(svc, svc, hash);\n  }\n  this._adapter = null;\n\n  this.destroyed = false;\n  this.draining = false;\n  this.pending = 0;\n  this.once('_eot', function (pending, err) {\n    debug('server channel EOT');\n    this.emit('eot', pending, err);\n  });\n}\nutil.inherits(ServerChannel, events.EventEmitter);\n\nServerChannel.prototype.destroy = function (noWait) {\n  if (!this.draining) {\n    this.draining = true;\n    this.emit('_drain');\n  }\n  if (noWait || !this.pending) {\n    this.destroyed = true;\n    if (isError(noWait)) {\n      debug('fatal server channel error: %s', noWait);\n      this.emit('_eot', this.pending, noWait);\n    } else {\n      this.emit('_eot', this.pending);\n    }\n  }\n};\n\nServerChannel.prototype._createHandshakeResponse = function (err, hreq) {\n  var svc = this.server.service;\n  var buf = svc.hash;\n  var serverMatch = hreq && hreq.serverHash.equals(buf);\n  return {\n    match: err ? 'NONE' : (serverMatch ? 'BOTH' : 'CLIENT'),\n    serverProtocol: serverMatch ? null : JSON.stringify(svc.protocol),\n    serverHash: serverMatch ? null : buf\n  };\n};\n\nServerChannel.prototype._getAdapter = function (hreq) {\n  var hash = hreq.clientHash;\n  var adapter = this.server._cache[hash];\n  if (adapter) {\n    return adapter;\n  }\n  if (!hreq.clientProtocol) {\n    throw toRpcError('UNKNOWN_PROTOCOL');\n  }\n  var ptcl = JSON.parse(hreq.clientProtocol);\n  var clientSvc = Service.forProtocol(ptcl);\n  adapter = new Adapter(clientSvc, this.server.service, hash, true);\n  return this.server._cache[hash] = adapter;\n};\n\nServerChannel.prototype._matchesPrefix = function (id) {\n  return matchesPrefix(id, this._prefix);\n};\n\nServerChannel.prototype._receive = function (reqBuf, adapter, cb) {\n  var self = this;\n  var wreq;\n  try {\n    wreq = adapter._decodeRequest(reqBuf);\n  } catch (cause) {\n    cb(self._encodeSystemError(toRpcError('INVALID_REQUEST', cause)));\n    return;\n  }\n\n  var msg = wreq._msg;\n  var wres = new WrappedResponse(msg, {});\n  if (!msg.name) {\n    // Ping message, we don't invoke middleware logic in this case.\n    wres.response = null;\n    cb(wres.toBuffer(), false);\n    return;\n  }\n\n  var ctx = new CallContext(msg, this);\n  self.emit('incomingCall', ctx);\n  var fns = this.server._fns;\n  debug('starting server middleware chain (%s middleware)', fns.length);\n  self.pending++;\n  chainMiddleware({\n    fns: fns,\n    ctx: ctx,\n    wreq: wreq,\n    wres: wres,\n    onTransition: onTransition,\n    onCompletion: onCompletion,\n    onError: onError\n  });\n\n  function onTransition(wreq, wres, prev) {\n    var handler = self.server._handlers[msg.name];\n    if (!handler) {\n      // The underlying service hasn't implemented a handler.\n      var defaultHandler = self.server._defaultHandler;\n      if (defaultHandler) {\n        // We call the default handler with arguments similar (slightly\n        // simpler, there are no phases here) to middleware such that it can\n        // easily access the message name (useful to implement proxies).\n        defaultHandler.call(ctx, wreq, wres, prev);\n      } else {\n        var cause = new Error(f('no handler for %s', msg.name));\n        prev(toRpcError('NOT_IMPLEMENTED', cause));\n      }\n    } else {\n      var pending = !msg.oneWay;\n      try {\n        if (pending) {\n          handler.call(ctx, wreq.request, function (err, res) {\n            pending = false;\n            wres.error = err;\n            wres.response = res;\n            prev();\n          });\n        } else {\n          handler.call(ctx, wreq.request);\n          prev();\n        }\n      } catch (err) {\n        // We catch synchronous failures (same as express) and return the\n        // failure. Note that the server process can still crash if an error\n        // is thrown after the handler returns but before the response is\n        // sent (again, same as express). We are careful to only trigger the\n        // response callback once, emitting the errors afterwards instead.\n        if (pending) {\n          pending = false;\n          prev(err);\n        } else {\n          onError(err);\n        }\n      }\n    }\n  }\n\n  function onCompletion(err) {\n    self.pending--;\n    var server = self.server;\n    var resBuf;\n    if (!err) {\n      var resErr = wres.error;\n      var isStrict = server._strict;\n      if (!isStrict) {\n        if (isError(resErr)) {\n          // If the error type is wrapped, we must wrap the error too.\n          wres.error = msg.errorType.clone(resErr.message, {wrapUnions: true});\n        } else if (resErr === null) {\n          // We also allow `null`'s as error in this mode, converting them to\n          // the Avro-compatible `undefined`.\n          resErr = wres.error = undefined;\n        }\n        if (\n          resErr === undefined &&\n          wres.response === undefined &&\n          msg.responseType.isValid(null)\n        ) {\n          // Finally, for messages with `null` as acceptable response type, we\n          // allow `undefined`; converting them to `null`. This allows users to\n          // write a more natural `cb()` instead of `cb(null, null)`.\n          wres.response = null;\n        }\n      }\n      try {\n        resBuf = wres.toBuffer();\n      } catch (cause) {\n        // Note that we don't add an RPC code here such that the client\n        // receives the default `INTERNAL_SERVER_ERROR` one.\n        if (wres.error !== undefined) {\n          err = serializationError(\n            f('invalid %j error', msg.name), // Sic.\n            wres,\n            [\n              {name: 'headers', type: MAP_BYTES_TYPE},\n              {name: 'error', type: msg.errorType}\n            ]\n          );\n        } else {\n          err = serializationError(\n            f('invalid %j response', msg.name),\n            wres,\n            [\n              {name: 'headers', type: MAP_BYTES_TYPE},\n              {name: 'response', type: msg.responseType}\n            ]\n          );\n        }\n      }\n    }\n    if (!resBuf) {\n      // The headers are only available if the message isn't one-way.\n      resBuf = self._encodeSystemError(err, wres.headers);\n    } else if (resErr !== undefined) {\n      server.emit('error', toRpcError('APPLICATION_ERROR', resErr));\n    }\n    cb(resBuf, msg.oneWay);\n    if (self.draining && !self.pending) {\n      self.destroy();\n    }\n  }\n\n  function onError(err) {\n    // Similar to the client equivalent, we redirect this error to the server\n    // since middleware are defined at server-level.\n    self.server.emit('error', err, self);\n  }\n};\n\n// Deprecated.\n\nutils.addDeprecatedGetters(ServerChannel, ['pending']);\n\nServerChannel.prototype.getCache = util.deprecate(\n  function () { return this.server._cache; },\n  'use `.remoteProtocols()` instead of `.getCache()`'\n);\n\nServerChannel.prototype.getProtocol = util.deprecate(\n  function () {\n    return this.server.service;\n  },\n  'use `.service` instead of `.getProtocol()`'\n);\n\nServerChannel.prototype.isDestroyed = util.deprecate(\n  function () { return this.destroyed; },\n  'use `.destroyed` instead of `.isDestroyed`'\n);\n\n/**\n * Encode an error and optional header into a valid Avro response.\n *\n * @param err {Error} Error to encode.\n * @param header {Object} Optional response header.\n */\nServerChannel.prototype._encodeSystemError = function (err, header) {\n  var server = this.server;\n  server.emit('error', err, this);\n  var errStr;\n  if (server._sysErrFormatter) {\n    // Format the error into a string to send over the wire.\n    errStr = server._sysErrFormatter.call(this, err);\n  } else if (err.rpcCode) {\n    // By default, only forward the error's message when the RPC code is set\n    // (i.e. when this isn't an internal server error).\n    errStr = err.message;\n  }\n  var hdrBuf;\n  if (header) {\n    try {\n      // Propagate the header if possible.\n      hdrBuf = MAP_BYTES_TYPE.toBuffer(header);\n    } catch (cause) {\n      server.emit('error', cause, this);\n    }\n  }\n  return Buffer.concat([\n    hdrBuf || utils.bufferFrom([0]),\n    utils.bufferFrom([1, 0]), // Error flag and first union index.\n    STRING_TYPE.toBuffer(errStr || 'internal server error')\n  ]);\n};\n\n/**\n * Server channel for stateless transport.\n *\n * This channel expect a handshake to precede each message.\n */\nfunction StatelessServerChannel(server, readableFactory, opts) {\n  ServerChannel.call(this, server, opts);\n\n  this._writable = undefined;\n  var self = this;\n  var readable;\n\n  process.nextTick(function () {\n    // Delay listening to allow handlers to be attached even if the factory is\n    // purely synchronous.\n    readable = readableFactory.call(self, function (err, writable) {\n      process.nextTick(function () {\n        // We delay once more here in case this call is synchronous, to allow\n        // the readable to always be populated first.\n        if (err) {\n          onFinish(err);\n          return;\n        }\n        self._writable = writable.on('finish', onFinish);\n        self.emit('_writable');\n      });\n    }).on('data', onRequest).on('end', onEnd);\n  });\n\n\n  function onRequest(obj) {\n    var id = obj.id;\n    var buf = Buffer.concat(obj.payload);\n    var err;\n    try {\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\n      var hreq = parts.head;\n      var adapter = self._getAdapter(hreq);\n    } catch (cause) {\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\n    }\n\n    var hres = self._createHandshakeResponse(err, hreq);\n    self.emit('handshake', hreq, hres);\n    if (err) {\n      done(self._encodeSystemError(err));\n    } else {\n      self._receive(parts.tail, adapter, done);\n    }\n\n    function done(resBuf) {\n      if (!self.destroyed) {\n        if (!self._writable) {\n          self.once('_writable', function () { done(resBuf); });\n          return;\n        }\n        self._writable.write({\n          id: id,\n          payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\n        });\n      }\n      if (self._writable && self._endWritable) {\n        self._writable.end();\n      }\n    }\n  }\n\n  function onEnd() { self.destroy(); }\n\n  function onFinish(err) {\n    readable\n      .removeListener('data', onRequest)\n      .removeListener('end', onEnd);\n    self.destroy(err || true);\n  }\n}\nutil.inherits(StatelessServerChannel, ServerChannel);\n\n/**\n * Stateful transport listener.\n *\n * A handshake is done when the channel first receives a message, then all\n * messages are sent without.\n */\nfunction StatefulServerChannel(server, readable, writable, opts) {\n  ServerChannel.call(this, server, opts);\n  this._adapter = undefined;\n  this._writable = writable.on('finish', onFinish);\n  this._readable = readable.on('data', onHandshake).on('end', onEnd);\n\n  this\n    .once('_drain', function () {\n      // Stop listening to incoming events.\n      this._readable\n        .removeListener('data', onHandshake)\n        .removeListener('data', onRequest)\n        .removeListener('end', onEnd);\n    })\n    .once('eot', function () {\n      // Clean up any references to the channel on the underlying streams.\n      this._writable.removeListener('finish', onFinish);\n      if (this._endWritable) {\n        this._writable.end();\n      }\n    });\n\n  var self = this;\n\n  function onHandshake(obj) {\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      return;\n    }\n    var buf = Buffer.concat(obj.payload);\n    var err;\n    try {\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\n      var hreq = parts.head;\n      self._adapter = self._getAdapter(hreq);\n    } catch (cause) {\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\n    }\n    var hres = self._createHandshakeResponse(err, hreq);\n    self.emit('handshake', hreq, hres);\n    if (err) {\n      // Either the client's protocol was unknown or it isn't compatible.\n      done(self._encodeSystemError(err));\n    } else {\n      self._readable\n        .removeListener('data', onHandshake)\n        .on('data', onRequest);\n      self._receive(parts.tail, self._adapter, done);\n    }\n\n    function done(resBuf) {\n      if (self.destroyed) {\n        return;\n      }\n      self._writable.write({\n        id: id,\n        payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\n      });\n    }\n  }\n\n  function onRequest(obj) {\n    // These requests are not prefixed with handshakes.\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      return;\n    }\n    var reqBuf = Buffer.concat(obj.payload);\n    self._receive(reqBuf, self._adapter, function (resBuf, oneWay) {\n      if (self.destroyed || oneWay) {\n        return;\n      }\n      self._writable.write({id: id, payload: [resBuf]});\n    });\n  }\n\n  function onEnd() { self.destroy(); }\n\n  function onFinish() { self.destroy(true); }\n}\nutil.inherits(StatefulServerChannel, ServerChannel);\n\n// Helpers.\n\n/** Enhanced request, used inside forward middleware functions. */\nfunction WrappedRequest(msg, hdrs, req) {\n  this._msg = msg;\n  this.headers = hdrs || {};\n  this.request = req || {};\n}\n\nWrappedRequest.prototype.toBuffer = function () {\n  var msg = this._msg;\n  return Buffer.concat([\n    MAP_BYTES_TYPE.toBuffer(this.headers),\n    STRING_TYPE.toBuffer(msg.name),\n    msg.requestType.toBuffer(this.request)\n  ]);\n};\n\n/** Enhanced response, used inside forward middleware functions. */\nfunction WrappedResponse(msg, hdr, err, res) {\n  this._msg = msg;\n  this.headers = hdr;\n  this.error = err;\n  this.response = res;\n}\n\nWrappedResponse.prototype.toBuffer = function () {\n  var hdr = MAP_BYTES_TYPE.toBuffer(this.headers);\n  var hasError = this.error !== undefined;\n  return Buffer.concat([\n    hdr,\n    BOOLEAN_TYPE.toBuffer(hasError),\n    hasError ?\n      this._msg.errorType.toBuffer(this.error) :\n      this._msg.responseType.toBuffer(this.response)\n  ]);\n};\n\n/**\n * Context for all middleware and handlers.\n *\n * It exposes a `locals` object which can be used to pass information between\n * each other during a given call.\n */\nfunction CallContext(msg, channel) {\n  this.channel = channel;\n  this.locals = {};\n  this.message = msg;\n  Object.freeze(this);\n}\n\n/**\n * Callback registry.\n *\n * Callbacks added must accept an error as first argument. This is used by\n * client channels to store pending calls. This class isn't exposed by the\n * public API.\n */\nfunction Registry(ctx, prefixLength) {\n  this._ctx = ctx; // Context for all callbacks.\n  this._mask = ~0 >>> (prefixLength | 0); // 16 bits by default.\n  this._id = 0; // Unique integer ID for each call.\n  this._n = 0; // Number of pending calls.\n  this._cbs = {};\n}\n\nRegistry.prototype.get = function (id) { return this._cbs[id & this._mask]; };\n\nRegistry.prototype.add = function (timeout, fn) {\n  this._id = (this._id + 1) & this._mask;\n\n  var self = this;\n  var id = this._id;\n  var timer;\n  if (timeout > 0) {\n    timer = setTimeout(function () { cb(new Error('timeout')); }, timeout);\n  }\n\n  this._cbs[id] = cb;\n  this._n++;\n  return id;\n\n  function cb() {\n    if (!self._cbs[id]) {\n      // The callback has already run.\n      return;\n    }\n    delete self._cbs[id];\n    self._n--;\n    if (timer) {\n      clearTimeout(timer);\n    }\n    fn.apply(self._ctx, arguments);\n  }\n};\n\nRegistry.prototype.clear = function () {\n  Object.keys(this._cbs).forEach(function (id) {\n    this._cbs[id](new Error('interrupted'));\n  }, this);\n};\n\n/**\n * Service resolution helper.\n *\n * It is used both by client and server channels, to respectively decode errors\n * and responses, or requests.\n */\nfunction Adapter(clientSvc, serverSvc, hash, isRemote) {\n  this._clientSvc = clientSvc;\n  this._serverSvc = serverSvc;\n  this._hash = hash; // Convenience to access it when creating handshakes.\n  this._isRemote = !!isRemote;\n  this._readers = createReaders(clientSvc, serverSvc);\n}\n\nAdapter.prototype._decodeRequest = function (buf) {\n  var tap = new Tap(buf);\n  var hdr = MAP_BYTES_TYPE._read(tap);\n  var name = STRING_TYPE._read(tap);\n  var msg, req;\n  if (name) {\n    msg = this._serverSvc.message(name);\n    req = this._readers[name + '?']._read(tap);\n  } else {\n    msg = PING_MESSAGE;\n  }\n  if (!tap.isValid()) {\n    throw new Error(f('truncated %s request', name || 'ping$'));\n  }\n  return new WrappedRequest(msg, hdr, req);\n};\n\nAdapter.prototype._decodeResponse = function (buf, wres, msg) {\n  var tap = new Tap(buf);\n  utils.copyOwnProperties(MAP_BYTES_TYPE._read(tap), wres.headers, true);\n  var isError = BOOLEAN_TYPE._read(tap);\n  var name = msg.name;\n  if (name) {\n    var reader = this._readers[name + (isError ? '*' : '!')];\n    msg = this._clientSvc.message(name);\n    if (isError) {\n      wres.error = reader._read(tap);\n    } else {\n      wres.response = reader._read(tap);\n    }\n    if (!tap.isValid()) {\n      throw new Error(f('truncated %s response', name));\n    }\n  } else {\n    msg = PING_MESSAGE;\n  }\n};\n\n/** Standard \"un-framing\" stream. */\nfunction FrameDecoder() {\n  stream.Transform.call(this, {readableObjectMode: true});\n  this._id = undefined;\n  this._buf = utils.newBuffer(0);\n  this._bufs = [];\n\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(FrameDecoder, stream.Transform);\n\nFrameDecoder.prototype._transform = function (buf, encoding, cb) {\n  buf = Buffer.concat([this._buf, buf]);\n  var frameLength;\n  while (\n    buf.length >= 4 &&\n    buf.length >= (frameLength = buf.readInt32BE(0)) + 4\n  ) {\n    if (frameLength) {\n      this._bufs.push(buf.slice(4, frameLength + 4));\n    } else {\n      var bufs = this._bufs;\n      this._bufs = [];\n      this.push({id: null, payload: bufs});\n    }\n    buf = buf.slice(frameLength + 4);\n  }\n  this._buf = buf;\n  cb();\n};\n\nFrameDecoder.prototype._flush = function (cb) {\n  if (this._buf.length || this._bufs.length) {\n    var bufs = this._bufs.slice();\n    bufs.unshift(this._buf);\n    var err = toRpcError('TRAILING_DATA');\n    // Attach the data to help debugging (e.g. if the encoded bytes contain a\n    // human-readable protocol like HTTP).\n    err.trailingData = Buffer.concat(bufs).toString();\n    this.emit('error', err);\n  }\n  cb();\n};\n\n/** Standard framing stream. */\nfunction FrameEncoder() {\n  stream.Transform.call(this, {writableObjectMode: true});\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(FrameEncoder, stream.Transform);\n\nFrameEncoder.prototype._transform = function (obj, encoding, cb) {\n  var bufs = obj.payload;\n  var i, l, buf;\n  for (i = 0, l = bufs.length; i < l; i++) {\n    buf = bufs[i];\n    this.push(intBuffer(buf.length));\n    this.push(buf);\n  }\n  this.push(intBuffer(0));\n  cb();\n};\n\n/** Netty-compatible decoding stream. */\nfunction NettyDecoder() {\n  stream.Transform.call(this, {readableObjectMode: true});\n  this._id = undefined;\n  this._frameCount = 0;\n  this._buf = utils.newBuffer(0);\n  this._bufs = [];\n\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(NettyDecoder, stream.Transform);\n\nNettyDecoder.prototype._transform = function (buf, encoding, cb) {\n  buf = Buffer.concat([this._buf, buf]);\n\n  while (true) {\n    if (this._id === undefined) {\n      if (buf.length < 8) {\n        this._buf = buf;\n        cb();\n        return;\n      }\n      this._id = buf.readInt32BE(0);\n      this._frameCount = buf.readInt32BE(4);\n      buf = buf.slice(8);\n    }\n\n    var frameLength;\n    while (\n      this._frameCount &&\n      buf.length >= 4 &&\n      buf.length >= (frameLength = buf.readInt32BE(0)) + 4\n    ) {\n      this._frameCount--;\n      this._bufs.push(buf.slice(4, frameLength + 4));\n      buf = buf.slice(frameLength + 4);\n    }\n\n    if (this._frameCount) {\n      this._buf = buf;\n      cb();\n      return;\n    } else {\n      var obj = {id: this._id, payload: this._bufs};\n      this._bufs = [];\n      this._id = undefined;\n      this.push(obj);\n    }\n  }\n};\n\nNettyDecoder.prototype._flush = FrameDecoder.prototype._flush;\n\n/** Netty-compatible encoding stream. */\nfunction NettyEncoder() {\n  stream.Transform.call(this, {writableObjectMode: true});\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(NettyEncoder, stream.Transform);\n\nNettyEncoder.prototype._transform = function (obj, encoding, cb) {\n  var bufs = obj.payload;\n  var l = bufs.length;\n  var buf;\n  // Header: [ ID, number of frames ]\n  buf = utils.newBuffer(8);\n  buf.writeInt32BE(obj.id, 0);\n  buf.writeInt32BE(l, 4);\n  this.push(buf);\n  // Frames, each: [ length, bytes ]\n  var i;\n  for (i = 0; i < l; i++) {\n    buf = bufs[i];\n    this.push(intBuffer(buf.length));\n    this.push(buf);\n  }\n  cb();\n};\n\n/**\n * Returns a buffer containing an integer's big-endian representation.\n *\n * @param n {Number} Integer.\n */\nfunction intBuffer(n) {\n  var buf = utils.newBuffer(4);\n  buf.writeInt32BE(n);\n  return buf;\n}\n\n/**\n * Decode a type used as prefix inside a buffer.\n *\n * @param type {Type} The type of the prefix.\n * @param buf {Buffer} Encoded bytes.\n *\n * This function will return an object `{head, tail}` where head contains the\n * decoded value and tail the rest of the buffer. An error will be thrown if\n * the prefix cannot be decoded.\n */\nfunction readHead(type, buf) {\n  var tap = new Tap(buf);\n  var head = type._read(tap);\n  if (!tap.isValid()) {\n    throw new Error(f('truncated %j', type.schema()));\n  }\n  return {head: head, tail: tap.buf.slice(tap.pos)};\n}\n\n/**\n * Generate a decoder, optimizing the case where reader and writer are equal.\n *\n * @param rtype {Type} Reader's type.\n * @param wtype {Type} Writer's type.\n */\nfunction createReader(rtype, wtype) {\n  return rtype.equals(wtype) ? rtype : rtype.createResolver(wtype);\n}\n\n/**\n * Generate all readers for a given protocol combination.\n *\n * @param clientSvc {Service} Client service.\n * @param serverSvc {Service} Client service.\n */\nfunction createReaders(clientSvc, serverSvc) {\n  var obj = {};\n  clientSvc.messages.forEach(function (c) {\n    var n = c.name;\n    var s = serverSvc.message(n);\n    try {\n      if (!s) {\n        throw new Error(f('missing server message: %s', n));\n      }\n      if (s.oneWay !== c.oneWay) {\n        throw new Error(f('inconsistent one-way message: %s', n));\n      }\n      obj[n + '?'] = createReader(s.requestType, c.requestType);\n      obj[n + '*'] = createReader(c.errorType, s.errorType);\n      obj[n + '!'] = createReader(c.responseType, s.responseType);\n    } catch (cause) {\n      throw toRpcError('INCOMPATIBLE_PROTOCOL', cause);\n    }\n  });\n  return obj;\n}\n\n/**\n * Populate a cache from a list of protocols.\n *\n * @param cache {Object} Cache of adapters.\n * @param svc {Service} The local service (either client or server).\n * @param ptcls {Array} Array of protocols to insert.\n * @param isClient {Boolean} Whether the local service is a client's or\n * server's.\n */\nfunction insertRemoteProtocols(cache, ptcls, svc, isClient) {\n  Object.keys(ptcls).forEach(function (hash) {\n    var ptcl = ptcls[hash];\n    var clientSvc, serverSvc;\n    if (isClient) {\n      clientSvc = svc;\n      serverSvc = Service.forProtocol(ptcl);\n    } else {\n      clientSvc = Service.forProtocol(ptcl);\n      serverSvc = svc;\n    }\n    cache[hash] = new Adapter(clientSvc, serverSvc, hash, true);\n  });\n}\n\n/**\n * Extract remote protocols from a cache\n *\n * @param cache {Object} Cache of adapters.\n * @param isClient {Boolean} Whether the remote protocols extracted should be\n * the servers' or clients'.\n */\nfunction getRemoteProtocols(cache, isClient) {\n  var ptcls = {};\n  Object.keys(cache).forEach(function (hs) {\n    var adapter = cache[hs];\n    if (adapter._isRemote) {\n      var svc = isClient ? adapter._serverSvc : adapter._clientSvc;\n      ptcls[hs] = svc.protocol;\n    }\n  });\n  return ptcls;\n}\n\n/**\n * Check whether something is an `Error`.\n *\n * @param any {Object} Any object.\n */\nfunction isError(any) {\n  // Also not ideal, but avoids brittle `instanceof` checks.\n  return !!any && Object.prototype.toString.call(any) === '[object Error]';\n}\n\n/**\n * Forward any errors emitted on the source to the destination.\n *\n * @param src {EventEmitter} The initial source of error events.\n * @param dst {EventEmitter} The new target of the source's error events. The\n * original source will be provided as second argument (the error being the\n * first).\n *\n * As a convenience, the source will be returned.\n */\nfunction forwardErrors(src, dst) {\n  return src.on('error', function (err) {\n    dst.emit('error', err, src);\n  });\n}\n\n/**\n * Create an error.\n *\n * @param msg {String} Error message.\n * @param cause {Error} The cause of the error. It is available as `cause`\n * field on the outer error.\n */\nfunction toError(msg, cause) {\n  var err = new Error(msg);\n  err.cause = cause;\n  return err;\n}\n\n/**\n * Mark an error.\n *\n * @param rpcCode {String} Code representing the failure.\n * @param cause {Error} The cause of the error. It is available as `cause`\n * field on the outer error.\n *\n * This is used to keep the argument of channels' `'error'` event errors.\n */\nfunction toRpcError(rpcCode, cause) {\n  var err = toError(rpcCode.toLowerCase().replace(/_/g, ' '), cause);\n  err.rpcCode = (cause && cause.rpcCode) ? cause.rpcCode : rpcCode;\n  return err;\n}\n\n/**\n * Provide a helpful error to identify why serialization failed.\n *\n * @param err {Error} The error to decorate.\n * @param obj {...} The object containing fields to validated.\n * @param fields {Array} Information about the fields to validate.\n */\nfunction serializationError(msg, obj, fields) {\n  var details = [];\n  var i, l, field;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    field.type.isValid(obj[field.name], {errorHook: errorHook});\n  }\n  var detailsStr = details\n    .map(function (obj) {\n      return f('%s = %j but expected %s', obj.path, obj.value, obj.type);\n    })\n    .join(', ');\n  var err = new Error(f('%s (%s)', msg, detailsStr));\n  err.details = details;\n  return err;\n\n  function errorHook(parts, any, type) {\n    var strs = [];\n    var i, l, part;\n    for (i = 0, l = parts.length; i < l; i++) {\n      part = parts[i];\n      if (isNaN(part)) {\n        strs.push('.' + part);\n      } else {\n        strs.push('[' + part + ']');\n      }\n    }\n    details.push({\n      path: field.name + strs.join(''),\n      value: any,\n      type: type\n    });\n  }\n}\n\n/**\n * Compute a prefix of fixed length from a string.\n *\n * @param scope {String} Namespace to be hashed.\n */\nfunction normalizedPrefix(scope) {\n  return scope ?\n    utils.getHash(scope).readInt16BE(0) << (32 - PREFIX_LENGTH) :\n    0;\n}\n\n/**\n * Check whether an ID matches the prefix.\n *\n * @param id {Integer} Number to check.\n * @param prefix {Integer} Already shifted prefix.\n */\nfunction matchesPrefix(id, prefix) {\n  return ((id ^ prefix) >> (32 - PREFIX_LENGTH)) === 0;\n}\n\n/**\n * Check whether something is a stream.\n *\n * @param any {Object} Any object.\n */\nfunction isStream(any) {\n  // This is a hacky way of checking that the transport is a stream-like\n  // object. We unfortunately can't use `instanceof Stream` checks since\n  // some libraries (e.g. websocket-stream) return streams which don't\n  // inherit from it.\n  return !!(any && any.pipe);\n}\n\n/**\n * Get a message, asserting that it exists.\n *\n * @param svc {Service} The protocol to look into.\n * @param name {String} The message's name.\n */\nfunction getExistingMessage(svc, name) {\n  var msg = svc.message(name);\n  if (!msg) {\n    throw new Error(f('unknown message: %s', name));\n  }\n  return msg;\n}\n\n/**\n * Middleware logic.\n *\n * This is used both in clients and servers to intercept call handling (e.g. to\n * populate headers, do access control).\n *\n * @param params {Object} The following parameters:\n *  + fns {Array} Array of middleware functions.\n *  + ctx {Object} Context used to call the middleware functions, onTransition,\n *    and onCompletion.\n *  + wreq {WrappedRequest}\n *  + wres {WrappedResponse}\n *  + onTransition {Function} End of forward phase callback. It accepts an\n *    eventual error as single argument. This will be used for the backward\n *    phase. This function is guaranteed to be called at most once.\n *  + onCompletion {Function} Final handler, it takes an error as unique\n *    argument. This function is guaranteed to be only at most once.\n *  + onError {Function} Error handler, called if an intermediate callback is\n *    called multiple times.\n */\nfunction chainMiddleware(params) {\n  var args = [params.wreq, params.wres];\n  var cbs = [];\n  var cause; // Backpropagated error.\n  forward(0);\n\n  function forward(pos) {\n    var isDone = false;\n    if (pos < params.fns.length) {\n      params.fns[pos].apply(params.ctx, args.concat(function (err, cb) {\n        if (isDone) {\n          params.onError(toError('duplicate forward middleware call', err));\n          return;\n        }\n        isDone = true;\n        if (\n          err || (\n            params.wres && ( // Non one-way messages.\n              params.wres.error !== undefined ||\n              params.wres.response !== undefined\n            )\n          )\n        ) {\n          // Stop the forward phase, bypass the handler, and start the backward\n          // phase. Note that we ignore any callback argument in this case.\n          cause = err;\n          backward();\n          return;\n        }\n        if (cb) {\n          cbs.push(cb);\n        }\n        forward(++pos);\n      }));\n    } else {\n      // Done with the middleware forward functions, call the handler.\n      params.onTransition.apply(params.ctx, args.concat(function (err) {\n        if (isDone) {\n          params.onError(toError('duplicate handler call', err));\n          return;\n        }\n        isDone = true;\n        cause = err;\n        process.nextTick(backward);\n      }));\n    }\n  }\n\n  function backward() {\n    var cb = cbs.pop();\n    if (cb) {\n      var isDone = false;\n      cb.call(params.ctx, cause, function (err) {\n        if (isDone) {\n          params.onError(toError('duplicate backward middleware call', err));\n          return;\n        }\n        // Substitute the error.\n        cause = err;\n        isDone = true;\n        backward();\n      });\n    } else {\n      // Done with all middleware calls.\n      params.onCompletion.call(params.ctx, cause);\n    }\n  }\n}\n\n\nmodule.exports = {\n  Adapter: Adapter,\n  HANDSHAKE_REQUEST_TYPE: HANDSHAKE_REQUEST_TYPE,\n  HANDSHAKE_RESPONSE_TYPE: HANDSHAKE_RESPONSE_TYPE,\n  Message: Message,\n  Registry: Registry,\n  Service: Service,\n  discoverProtocol: discoverProtocol,\n  streams: {\n    FrameDecoder: FrameDecoder,\n    FrameEncoder: FrameEncoder,\n    NettyDecoder: NettyDecoder,\n    NettyEncoder: NettyEncoder\n  }\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/services.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/specs.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/specs.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\n\n// TODO: Add minimal templating.\n// TODO: Add option to prefix nested type declarations with the outer types'\n// names.\n\n\n\n/** IDL to protocol (services) and schema (types) parsing logic. */\n\nvar files = __webpack_require__(/*! ./files */ \"./node_modules/avsc/lib/files.js\"),\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\n    path = __webpack_require__(/*! path */ \"path\"),\n    util = __webpack_require__(/*! util */ \"util\");\n\n\nvar f = util.format;\n\n\n// Default type references defined by Avro.\nvar TYPE_REFS = {\n  date: {type: 'int', logicalType: 'date'},\n  decimal: {type: 'bytes', logicalType: 'decimal'},\n  time_ms: {type: 'long', logicalType: 'time-millis'},\n  timestamp_ms: {type: 'long', logicalType: 'timestamp-millis'}\n};\n\n\n/** Assemble an IDL file into a decoded protocol. */\nfunction assembleProtocol(fpath, opts, cb) {\n  if (!cb && typeof opts == 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  opts = opts || {};\n  if (!opts.importHook) {\n    opts.importHook = files.createImportHook();\n  }\n\n  importFile(fpath, function (err, protocol) {\n    if (err) {\n      cb(err);\n      return;\n    }\n    if (!protocol) {\n      cb(new Error('empty root import'));\n      return;\n    }\n    var schemas = protocol.types;\n    if (schemas) {\n      // Strip redundant namespaces from types before returning the protocol.\n      // Note that we keep empty (`''`) nested namespaces when the outer one is\n      // non-empty. This allows figuring out whether unqualified imported names\n      // should be qualified by the protocol's namespace: they should if their\n      // namespace is `undefined` and should not if it is empty.\n      var namespace = protocolNamespace(protocol) || '';\n      schemas.forEach(function (schema) {\n        if (schema.namespace === namespace) {\n          delete schema.namespace;\n        }\n      });\n    }\n    cb(null, protocol);\n  });\n\n  function importFile(fpath, cb) {\n    opts.importHook(fpath, 'idl', function (err, str) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      if (str === undefined) {\n        // This signals an already imported file by the default import hooks.\n        // Implementors who wish to disallow duplicate imports should provide a\n        // custom hook which throws an error when a duplicate is detected.\n        cb();\n        return;\n      }\n      try {\n        var reader = new Reader(str, opts);\n        var obj = reader._readProtocol(str, opts);\n      } catch (err) {\n        err.path = fpath; // To help debug which file caused the error.\n        cb(err);\n        return;\n      }\n      fetchImports(obj.protocol, obj.imports, path.dirname(fpath), cb);\n    });\n  }\n\n  function fetchImports(protocol, imports, dpath, cb) {\n    var importedProtocols = [];\n    next();\n\n    function next() {\n      var info = imports.shift();\n      if (!info) {\n        // We are done with this file. We prepend all imported types to this\n        // file's and we can return the final result.\n        importedProtocols.reverse();\n        try {\n          importedProtocols.forEach(function (imported) {\n            mergeImport(protocol, imported);\n          });\n        } catch (err) {\n          cb(err);\n          return;\n        }\n        cb(null, protocol);\n        return;\n      }\n      var importPath = path.join(dpath, info.name);\n      if (info.kind === 'idl') {\n        importFile(importPath, function (err, imported) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          if (imported) {\n            importedProtocols.push(imported);\n          }\n          next();\n        });\n      } else {\n        // We are importing a protocol or schema file.\n        opts.importHook(importPath, info.kind, function (err, str) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          switch (info.kind) {\n            case 'protocol':\n            case 'schema':\n              if (str === undefined) {\n                // Skip duplicate import (see related comment above).\n                next();\n                return;\n              }\n              try {\n                var obj = JSON.parse(str);\n              } catch (err) {\n                err.path = importPath;\n                cb(err);\n                return;\n              }\n              var imported = info.kind === 'schema' ? {types: [obj]} : obj;\n              importedProtocols.push(imported);\n              next();\n              return;\n            default:\n              cb(new Error(f('invalid import kind: %s', info.kind)));\n          }\n        });\n      }\n    }\n  }\n\n  function mergeImport(protocol, imported) {\n    // Merge first the types (where we don't need to check for duplicates\n    // since instantiating the service will take care of it), then the messages\n    // (where we need to, as duplicates will overwrite each other).\n    var schemas = imported.types || [];\n    schemas.reverse();\n    schemas.forEach(function (schema) {\n      if (!protocol.types) {\n        protocol.types = [];\n      }\n      // Ensure the imported protocol's namespace is inherited correctly (it\n      // might be different from the current one).\n      if (schema.namespace === undefined) {\n        schema.namespace = protocolNamespace(imported) || '';\n      }\n      protocol.types.unshift(schema);\n    });\n    Object.keys(imported.messages || {}).forEach(function (name) {\n      if (!protocol.messages) {\n        protocol.messages = {};\n      }\n      if (protocol.messages[name]) {\n        throw new Error(f('duplicate message: %s', name));\n      }\n      protocol.messages[name] = imported.messages[name];\n    });\n  }\n}\n\n// Parsing functions.\n\n/**\n * Convenience function to parse multiple inputs into protocols and schemas.\n *\n * It should cover most basic use-cases but has a few limitations:\n *\n * + It doesn't allow passing options to the parsing step.\n * + The protocol/type inference logic can be deceived.\n *\n * The parsing logic is as follows:\n *\n * + If `str` contains `path.sep` (on windows `\\`, otherwise `/`) and is a path\n *   to an existing file, it will first be read as JSON, then as an IDL\n *   specification if JSON parsing failed. If either succeeds, the result is\n *   returned, otherwise the next steps are run using the file's content\n *   instead of the input path.\n * + If `str` is a valid JSON string, it is parsed then returned.\n * + If `str` is a valid IDL protocol specification, it is parsed and returned\n *   if no imports are present (and an error is thrown if there are any\n *   imports).\n * + If `str` is a valid IDL type specification, it is parsed and returned.\n * + If neither of the above cases apply, `str` is returned.\n */\nfunction read(str) {\n  var schema;\n  if (typeof str == 'string' && ~str.indexOf(path.sep) && files.existsSync(str)) {\n    // Try interpreting `str` as path to a file contain a JSON schema or an IDL\n    // protocol. Note that we add the second check to skip primitive references\n    // (e.g. `\"int\"`, the most common use-case for `avro.parse`).\n    var contents = files.readFileSync(str, {encoding: 'utf8'});\n    try {\n      return JSON.parse(contents);\n    } catch (err) {\n      var opts = {importHook: files.createSyncImportHook()};\n      assembleProtocol(str, opts, function (err, protocolSchema) {\n        schema = err ? contents : protocolSchema;\n      });\n    }\n  } else {\n    schema = str;\n  }\n  if (typeof schema != 'string' || schema === 'null') {\n    // This last predicate is to allow `read('null')` to work similarly to\n    // `read('int')` and other primitives (null needs to be handled separately\n    // since it is also a valid JSON identifier).\n    return schema;\n  }\n  try {\n    return JSON.parse(schema);\n  } catch (err) {\n    try {\n      return Reader.readProtocol(schema);\n    } catch (err) {\n      try {\n        return Reader.readSchema(schema);\n      } catch (err) {\n        return schema;\n      }\n    }\n  }\n}\n\nfunction Reader(str, opts) {\n  opts = opts || {};\n\n  this._tk = new Tokenizer(str);\n  this._ackVoidMessages = !!opts.ackVoidMessages;\n  this._implicitTags = !opts.delimitedCollections;\n  this._typeRefs = opts.typeRefs || TYPE_REFS;\n}\n\nReader.readProtocol = function (str, opts) {\n  var reader = new Reader(str, opts);\n  var protocol = reader._readProtocol();\n  if (protocol.imports.length) {\n    // Imports can only be resolved when the IDL file is provided via its\n    // path, we fail rather than silently ignore imports.\n    throw new Error('unresolvable import');\n  }\n  return protocol.protocol;\n};\n\nReader.readSchema = function (str, opts) {\n  var reader = new Reader(str, opts);\n  var doc = reader._readJavadoc();\n  var schema = reader._readType(doc === undefined ? {} : {doc: doc}, true);\n  reader._tk.next({id: '(eof)'}); // Check that we have read everything.\n  return schema;\n};\n\nReader.prototype._readProtocol = function () {\n  var tk = this._tk;\n  var imports = [];\n  var types = [];\n  var messages = {};\n  var pos;\n\n  // Outer declarations (outside of the protocol block).\n  this._readImports(imports);\n  var protocolSchema = {};\n  var protocolJavadoc = this._readJavadoc();\n  if (protocolJavadoc !== undefined) {\n    protocolSchema.doc = protocolJavadoc;\n  }\n  this._readAnnotations(protocolSchema);\n  tk.next({val: 'protocol'});\n  if (!tk.next({val: '{', silent: true})) {\n    // Named protocol.\n    protocolSchema.protocol = tk.next({id: 'name'}).val;\n    tk.next({val: '{'});\n  }\n\n  // Inner declarations.\n  while (!tk.next({val: '}', silent: true})) {\n    if (!this._readImports(imports)) {\n      var javadoc = this._readJavadoc();\n      var typeSchema = this._readType({}, true);\n      var numImports = this._readImports(imports, true);\n      var message = undefined;\n      // We mark our position and try to parse a message from here.\n      pos = tk.pos;\n      if (!numImports && (message = this._readMessage(typeSchema))) {\n        // Note that if any imports were found, we cannot be parsing a message.\n        if (javadoc !== undefined && message.schema.doc === undefined) {\n          message.schema.doc = javadoc;\n        }\n        var oneWay = false;\n        if (\n          message.schema.response === 'void' ||\n          message.schema.response.type === 'void'\n        ) {\n          oneWay = !this._ackVoidMessages && !message.schema.errors;\n          if (message.schema.response === 'void') {\n            message.schema.response = 'null';\n          } else {\n            message.schema.response.type = 'null';\n          }\n        }\n        if (oneWay) {\n          message.schema['one-way'] = true;\n        }\n        if (messages[message.name]) {\n          // We have to do this check here otherwise the duplicate will be\n          // overwritten (and service instantiation won't be able to catch it).\n          throw new Error(f('duplicate message: %s', message.name));\n        }\n        messages[message.name] = message.schema;\n      } else {\n        // This was a standalone type definition.\n        if (javadoc) {\n          if (typeof typeSchema == 'string') {\n            typeSchema = {doc: javadoc, type: typeSchema};\n          } else if (typeSchema.doc === undefined) {\n            typeSchema.doc = javadoc;\n          }\n        }\n        types.push(typeSchema);\n        // We backtrack until just before the type's type name and swallow an\n        // eventual semi-colon (to make type declarations more consistent).\n        tk.pos = pos;\n        tk.next({val: ';', silent: true});\n      }\n      javadoc = undefined;\n    }\n  }\n  tk.next({id: '(eof)'});\n  if (types.length) {\n    protocolSchema.types = types;\n  }\n  if (Object.keys(messages).length) {\n    protocolSchema.messages = messages;\n  }\n  return {protocol: protocolSchema, imports: imports};\n};\n\nReader.prototype._readAnnotations = function (schema) {\n  var tk = this._tk;\n  while (tk.next({val: '@', silent: true})) {\n    // Annotations are allowed to have names which aren't valid Avro names,\n    // we must advance until we hit the first left parenthesis.\n    var parts = [];\n    while (!tk.next({val: '(', silent: true})) {\n      parts.push(tk.next().val);\n    }\n    schema[parts.join('')] = tk.next({id: 'json'}).val;\n    tk.next({val: ')'});\n  }\n};\n\nReader.prototype._readMessage = function (responseSchema) {\n  var tk = this._tk;\n  var schema = {request: [], response: responseSchema};\n  this._readAnnotations(schema);\n  var name = tk.next().val;\n  if (tk.next().val !== '(') {\n    // This isn't a message.\n    return;\n  }\n  if (!tk.next({val: ')', silent: true})) {\n    do {\n      schema.request.push(this._readField());\n    } while (!tk.next({val: ')', silent: true}) && tk.next({val: ','}));\n  }\n  var token = tk.next();\n  switch (token.val) {\n    case 'throws':\n      // It doesn't seem like the IDL is explicit about which syntax to used\n      // for multiple errors. We will assume a comma-separated list.\n      schema.errors = [];\n      do {\n        schema.errors.push(this._readType());\n      } while (!tk.next({val: ';', silent: true}) && tk.next({val: ','}));\n      break;\n    case 'oneway':\n      schema['one-way'] = true;\n      tk.next({val: ';'});\n      break;\n    case ';':\n      break;\n    default:\n      throw tk.error('invalid message suffix', token);\n  }\n  return {name: name, schema: schema};\n};\n\nReader.prototype._readJavadoc = function () {\n  var token = this._tk.next({id: 'javadoc', emitJavadoc: true, silent: true});\n  if (token) {\n    return token.val;\n  }\n};\n\nReader.prototype._readField = function () {\n  var tk = this._tk;\n  var javadoc = this._readJavadoc();\n  var schema = {type: this._readType()};\n  if (javadoc !== undefined && schema.doc === undefined) {\n    schema.doc = javadoc;\n  }\n  this._readAnnotations(schema);\n  schema.name = tk.next({id: 'name'}).val;\n  if (tk.next({val: '=', silent: true})) {\n    schema['default'] = tk.next({id: 'json'}).val;\n  }\n  return schema;\n};\n\nReader.prototype._readType = function (schema, top) {\n  schema = schema || {};\n  this._readAnnotations(schema);\n  schema.type = this._tk.next({id: 'name'}).val;\n  switch (schema.type) {\n    case 'record':\n    case 'error':\n      return this._readRecord(schema);\n    case 'fixed':\n      return this._readFixed(schema);\n    case 'enum':\n      return this._readEnum(schema, top);\n    case 'map':\n      return this._readMap(schema);\n    case 'array':\n      return this._readArray(schema);\n    case 'union':\n      if (Object.keys(schema).length > 1) {\n        throw new Error('union annotations are not supported');\n      }\n      return this._readUnion();\n    default:\n      // Reference.\n      var ref = this._typeRefs[schema.type];\n      if (ref) {\n        delete schema.type; // Always overwrite the type.\n        utils.copyOwnProperties(ref, schema);\n      }\n      return Object.keys(schema).length > 1 ? schema : schema.type;\n  }\n};\n\nReader.prototype._readFixed = function (schema) {\n  var tk = this._tk;\n  if (!tk.next({val: '(', silent: true})) {\n    schema.name = tk.next({id: 'name'}).val;\n    tk.next({val: '('});\n  }\n  schema.size = parseInt(tk.next({id: 'number'}).val);\n  tk.next({val: ')'});\n  return schema;\n};\n\nReader.prototype._readMap = function (schema) {\n  var tk = this._tk;\n  // Brackets are unwieldy when declaring inline types. We allow for them to be\n  // omitted (but we keep the consistency that if the entry bracket is present,\n  // the exit one must be as well). Note that this is non-standard.\n  var silent = this._implicitTags;\n  var implicitTags = tk.next({val: '<', silent: silent}) === undefined;\n  schema.values = this._readType();\n  tk.next({val: '>', silent: implicitTags});\n  return schema;\n};\n\nReader.prototype._readArray = function (schema) {\n  var tk = this._tk;\n  var silent = this._implicitTags;\n  var implicitTags = tk.next({val: '<', silent: silent}) === undefined;\n  schema.items = this._readType();\n  tk.next({val: '>', silent: implicitTags});\n  return schema;\n};\n\nReader.prototype._readEnum = function (schema, top) {\n  var tk = this._tk;\n  if (!tk.next({val: '{', silent: true})) {\n    schema.name = tk.next({id: 'name'}).val;\n    tk.next({val: '{'});\n  }\n  schema.symbols = [];\n  do {\n    schema.symbols.push(tk.next().val);\n  } while (!tk.next({val: '}', silent: true}) && tk.next({val: ','}));\n  // To avoid confusing syntax, reader enums (i.e. enums with a default value)\n  // can only be defined top-level.\n  if (top && tk.next({val: '=', silent: true})) {\n    schema.default = tk.next().val;\n    tk.next({val: ';'});\n  }\n  return schema;\n};\n\nReader.prototype._readUnion = function () {\n  var tk = this._tk;\n  var arr = [];\n  tk.next({val: '{'});\n  do {\n    arr.push(this._readType());\n  } while (!tk.next({val: '}', silent: true}) && tk.next({val: ','}));\n  return arr;\n};\n\nReader.prototype._readRecord = function (schema) {\n  var tk = this._tk;\n  if (!tk.next({val: '{', silent: true})) {\n    schema.name = tk.next({id: 'name'}).val;\n    tk.next({val: '{'});\n  }\n  schema.fields = [];\n  while (!tk.next({val: '}', silent: true})) {\n    schema.fields.push(this._readField());\n    tk.next({val: ';'});\n  }\n  return schema;\n};\n\nReader.prototype._readImports = function (imports, maybeMessage) {\n  var tk = this._tk;\n  var numImports = 0;\n  var pos = tk.pos;\n  while (tk.next({val: 'import', silent: true})) {\n    if (!numImports && maybeMessage && tk.next({val: '(', silent: true})) {\n      // This will happen if a message is named import.\n      tk.pos = pos;\n      return;\n    }\n    var kind = tk.next({id: 'name'}).val;\n    var fname = JSON.parse(tk.next({id: 'string'}).val);\n    tk.next({val: ';'});\n    imports.push({kind: kind, name: fname});\n    numImports++;\n  }\n  return numImports;\n};\n\n// Helpers.\n\n/**\n * Simple class to split an input string into tokens.\n *\n * There are different types of tokens, characterized by their `id`:\n *\n * + `number` numbers.\n * + `name` references.\n * + `string` double-quoted.\n * + `operator`, anything else, always single character.\n * + `javadoc`, only emitted when `next` is called with `emitJavadoc` set.\n * + `json`, only emitted when `next` is called with `'json'` as `id` (the\n *   tokenizer doesn't have enough context to predict these).\n */\nfunction Tokenizer(str) {\n  this._str = str;\n  this.pos = 0;\n}\n\nTokenizer.prototype.next = function (opts) {\n  var token = {pos: this.pos, id: undefined, val: undefined};\n  var javadoc = this._skip(opts && opts.emitJavadoc);\n  if (javadoc) {\n    token.id = 'javadoc';\n    token.val = javadoc;\n  } else {\n    var pos = this.pos;\n    var str = this._str;\n    var c = str.charAt(pos);\n    if (!c) {\n      token.id = '(eof)';\n    } else {\n      if (opts && opts.id === 'json') {\n        token.id = 'json';\n        this.pos = this._endOfJson();\n      } else if (c === '\"') {\n        token.id = 'string';\n        this.pos = this._endOfString();\n      } else if (/[0-9]/.test(c)) {\n        token.id = 'number';\n        this.pos = this._endOf(/[0-9]/);\n      } else if (/[`A-Za-z_.]/.test(c)) {\n        token.id = 'name';\n        this.pos = this._endOf(/[`A-Za-z0-9_.]/);\n      } else {\n        token.id = 'operator';\n        this.pos = pos + 1;\n      }\n      token.val = str.slice(pos, this.pos);\n      if (token.id === 'json') {\n        // Let's be nice and give a more helpful error message when this occurs\n        // (JSON parsing errors wouldn't let us find the location otherwise).\n        try {\n          token.val = JSON.parse(token.val);\n        } catch (err) {\n          throw this.error('invalid JSON', token);\n        }\n      } else if (token.id === 'name') {\n        // Unescape names (our parser doesn't need them).\n        token.val = token.val.replace(/`/g, '');\n      }\n    }\n  }\n\n  var err;\n  if (opts && opts.id && opts.id !== token.id) {\n    err = this.error(f('expected ID %s', opts.id), token);\n  } else if (opts && opts.val && opts.val !== token.val) {\n    err = this.error(f('expected value %s', opts.val), token);\n  }\n  if (!err) {\n    return token;\n  } else if (opts && opts.silent) {\n    this.pos = token.pos; // Backtrack to start of token.\n    return undefined;\n  } else {\n    throw err;\n  }\n};\n\nTokenizer.prototype.error = function (reason, context) {\n  // Context must be either a token or a position.\n  var isToken = typeof context != 'number';\n  var pos = isToken ? context.pos : context;\n  var str = this._str;\n  var lineNum = 1;\n  var lineStart = 0;\n  var i;\n  for (i = 0; i < pos; i++) {\n    if (str.charAt(i) === '\\n') {\n      lineNum++;\n      lineStart = i;\n    }\n  }\n  var msg = isToken ? f('invalid token %j: %s', context, reason) : reason;\n  var err = new Error(msg);\n  err.token = isToken ? context : undefined;\n  err.lineNum = lineNum;\n  err.colNum = pos - lineStart;\n  return err;\n};\n\n/** Skip whitespace and comments. */\nTokenizer.prototype._skip = function (emitJavadoc) {\n  var str = this._str;\n  var isJavadoc = false;\n  var pos, c;\n\n  while ((c = str.charAt(this.pos)) && /\\s/.test(c)) {\n    this.pos++;\n  }\n  pos = this.pos;\n  if (c === '/') {\n    switch (str.charAt(this.pos + 1)) {\n    case '/':\n      this.pos += 2;\n      while ((c = str.charAt(this.pos)) && c !== '\\n') {\n        this.pos++;\n      }\n      return this._skip(emitJavadoc);\n    case '*':\n      this.pos += 2;\n      if (str.charAt(this.pos) === '*') {\n        isJavadoc = true;\n      }\n      while ((c = str.charAt(this.pos++))) {\n        if (c === '*' && str.charAt(this.pos) === '/') {\n          this.pos++;\n          if (isJavadoc && emitJavadoc) {\n            return extractJavadoc(str.slice(pos + 3, this.pos - 2));\n          }\n          return this._skip(emitJavadoc);\n        }\n      }\n      throw this.error('unterminated comment', pos);\n    }\n  }\n};\n\n/** Generic end of method. */\nTokenizer.prototype._endOf = function (pat) {\n  var pos = this.pos;\n  var str = this._str;\n  while (pat.test(str.charAt(pos))) {\n    pos++;\n  }\n  return pos;\n};\n\n/** Find end of a string. */\nTokenizer.prototype._endOfString = function () {\n  var pos = this.pos + 1; // Skip first double quote.\n  var str = this._str;\n  var c;\n  while ((c = str.charAt(pos))) {\n    if (c === '\"') {\n      // The spec doesn't explicitly say so, but IDLs likely only\n      // allow double quotes for strings (C- and Java-style).\n      return pos + 1;\n    }\n    if (c === '\\\\') {\n      pos += 2;\n    } else {\n      pos++;\n    }\n  }\n  throw this.error('unterminated string', pos - 1);\n};\n\n/** Find end of JSON object, throwing an error if the end is reached first. */\nTokenizer.prototype._endOfJson = function () {\n  var pos = utils.jsonEnd(this._str, this.pos);\n  if (pos < 0) {\n    throw this.error('invalid JSON', pos);\n  }\n  return pos;\n};\n\n/**\n * Extract Javadoc contents from the comment.\n *\n * The parsing done is very simple and simply removes the line prefixes and\n * leading / trailing empty lines. It's better to be conservative with\n * formatting rather than risk losing information.\n */\nfunction extractJavadoc(str) {\n  var lines = str\n    .replace(/^[ \\t]+|[ \\t]+$/g, '') // Trim whitespace.\n    .split('\\n').map(function (line, i) {\n      return i ? line.replace(/^\\s*\\*\\s?/, '') : line;\n    });\n  while (!lines[0]) {\n    lines.shift();\n  }\n  while (!lines[lines.length - 1]) {\n    lines.pop();\n  }\n  return lines.join('\\n');\n}\n\n/** Returns the namespace generated by a protocol. */\nfunction protocolNamespace(protocol) {\n  if (protocol.namespace) {\n    return protocol.namespace;\n  }\n  var match = /^(.*)\\.[^.]+$/.exec(protocol.protocol);\n  return match ? match[1] : undefined;\n}\n\n\nmodule.exports = {\n  Tokenizer: Tokenizer,\n  assembleProtocol: assembleProtocol,\n  read: read,\n  readProtocol: Reader.readProtocol,\n  readSchema: Reader.readSchema\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/specs.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/types.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/types.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\n\n// TODO: Make it easier to implement custom types. This will likely require\n// exposing the `Tap` object, perhaps under another name. Probably worth a\n// major release.\n// TODO: Allow configuring when to write the size when writing arrays and maps,\n// and customizing their block size.\n// TODO: Code-generate `compare` and `clone` record and union methods.\n\n\n\n/**\n * This module defines all Avro data types and their serialization logic.\n *\n */\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\n    buffer = __webpack_require__(/*! buffer */ \"buffer\"), // For `SlowBuffer`.\n    util = __webpack_require__(/*! util */ \"util\");\n\n\n// Convenience imports.\nvar Tap = utils.Tap;\nvar debug = util.debuglog('avsc:types');\nvar f = util.format;\n\n// All non-union concrete (i.e. non-logical) Avro types.\nvar TYPES = {\n  'array': ArrayType,\n  'boolean': BooleanType,\n  'bytes': BytesType,\n  'double': DoubleType,\n  'enum': EnumType,\n  'error': RecordType,\n  'fixed': FixedType,\n  'float': FloatType,\n  'int': IntType,\n  'long': LongType,\n  'map': MapType,\n  'null': NullType,\n  'record': RecordType,\n  'string': StringType\n};\n\n// Random generator.\nvar RANDOM = new utils.Lcg();\n\n// Encoding tap (shared for performance).\nvar TAP = new Tap(new buffer.SlowBuffer(1024));\n\n// Currently active logical type, used for name redirection.\nvar LOGICAL_TYPE = null;\n\n// Underlying types of logical types currently being instantiated. This is used\n// to be able to reference names (i.e. for branches) during instantiation.\nvar UNDERLYING_TYPES = [];\n\n/**\n * \"Abstract\" base Avro type.\n *\n * This class' constructor will register any named types to support recursive\n * schemas. All type values are represented in memory similarly to their JSON\n * representation, except for:\n *\n * + `bytes` and `fixed` which are represented as `Buffer`s.\n * + `union`s which will be \"unwrapped\" unless the `wrapUnions` option is set.\n *\n *  See individual subclasses for details.\n */\nfunction Type(schema, opts) {\n  var type;\n  if (LOGICAL_TYPE) {\n    type = LOGICAL_TYPE;\n    UNDERLYING_TYPES.push([LOGICAL_TYPE, this]);\n    LOGICAL_TYPE = null;\n  } else {\n    type = this;\n  }\n\n  // Lazily instantiated hash string. It will be generated the first time the\n  // type's default fingerprint is computed (for example when using `equals`).\n  // We use a mutable object since types are frozen after instantiation.\n  this._hash = new Hash();\n  this.name = undefined;\n  this.aliases = undefined;\n  this.doc = (schema && schema.doc) ? '' + schema.doc : undefined;\n\n  if (schema) {\n    // This is a complex (i.e. non-primitive) type.\n    var name = schema.name;\n    var namespace = schema.namespace === undefined ?\n      opts && opts.namespace :\n      schema.namespace;\n    if (name !== undefined) {\n      // This isn't an anonymous type.\n      name = maybeQualify(name, namespace);\n      if (isPrimitive(name)) {\n        // Avro doesn't allow redefining primitive names.\n        throw new Error(f('cannot rename primitive type: %j', name));\n      }\n      var registry = opts && opts.registry;\n      if (registry) {\n        if (registry[name] !== undefined) {\n          throw new Error(f('duplicate type name: %s', name));\n        }\n        registry[name] = type;\n      }\n    } else if (opts && opts.noAnonymousTypes) {\n      throw new Error(f('missing name property in schema: %j', schema));\n    }\n    this.name = name;\n    this.aliases = schema.aliases ?\n      schema.aliases.map(function (s) { return maybeQualify(s, namespace); }) :\n      [];\n  }\n}\n\nType.forSchema = function (schema, opts) {\n  opts = opts || {};\n  opts.registry = opts.registry || {};\n\n  var UnionType = (function (wrapUnions) {\n    if (wrapUnions === true) {\n      wrapUnions = 'always';\n    } else if (wrapUnions === false) {\n      wrapUnions = 'never';\n    } else if (wrapUnions === undefined) {\n      wrapUnions = 'auto';\n    } else if (typeof wrapUnions == 'string') {\n      wrapUnions = wrapUnions.toLowerCase();\n    }\n    switch (wrapUnions) {\n      case 'always':\n        return WrappedUnionType;\n      case 'never':\n        return UnwrappedUnionType;\n      case 'auto':\n        return undefined; // Determined dynamically later on.\n      default:\n        throw new Error(f('invalid wrap unions option: %j', wrapUnions));\n    }\n  })(opts.wrapUnions);\n\n  if (schema === null) {\n    // Let's be helpful for this common error.\n    throw new Error('invalid type: null (did you mean \"null\"?)');\n  }\n\n  if (Type.isType(schema)) {\n    return schema;\n  }\n\n  var type;\n  if (opts.typeHook && (type = opts.typeHook(schema, opts))) {\n    if (!Type.isType(type)) {\n      throw new Error(f('invalid typehook return value: %j', type));\n    }\n    return type;\n  }\n\n  if (typeof schema == 'string') { // Type reference.\n    schema = maybeQualify(schema, opts.namespace);\n    type = opts.registry[schema];\n    if (type) {\n      // Type was already defined, return it.\n      return type;\n    }\n    if (isPrimitive(schema)) {\n      // Reference to a primitive type. These are also defined names by default\n      // so we create the appropriate type and it to the registry for future\n      // reference.\n      return opts.registry[schema] = Type.forSchema({type: schema}, opts);\n    }\n    throw new Error(f('undefined type name: %s', schema));\n  }\n\n  if (schema.logicalType && opts.logicalTypes && !LOGICAL_TYPE) {\n    var DerivedType = opts.logicalTypes[schema.logicalType];\n    if (DerivedType) {\n      var namespace = opts.namespace;\n      var registry = {};\n      Object.keys(opts.registry).forEach(function (key) {\n        registry[key] = opts.registry[key];\n      });\n      try {\n        debug('instantiating logical type for %s', schema.logicalType);\n        return new DerivedType(schema, opts);\n      } catch (err) {\n        debug('failed to instantiate logical type for %s', schema.logicalType);\n        if (opts.assertLogicalTypes) {\n          // The spec mandates that we fall through to the underlying type if\n          // the logical type is invalid. We provide this option to ease\n          // debugging.\n          throw err;\n        }\n        LOGICAL_TYPE = null;\n        opts.namespace = namespace;\n        opts.registry = registry;\n      }\n    }\n  }\n\n  if (Array.isArray(schema)) { // Union.\n    // We temporarily clear the logical type since we instantiate the branch's\n    // types before the underlying union's type (necessary to decide whether the\n    // union is ambiguous or not).\n    var logicalType = LOGICAL_TYPE;\n    LOGICAL_TYPE = null;\n    var types = schema.map(function (obj) {\n      return Type.forSchema(obj, opts);\n    });\n    if (!UnionType) {\n      UnionType = isAmbiguous(types) ? WrappedUnionType : UnwrappedUnionType;\n    }\n    LOGICAL_TYPE = logicalType;\n    type = new UnionType(types, opts);\n  } else { // New type definition.\n    type = (function (typeName) {\n      var Type = TYPES[typeName];\n      if (Type === undefined) {\n        throw new Error(f('unknown type: %j', typeName));\n      }\n      return new Type(schema, opts);\n    })(schema.type);\n  }\n  return type;\n};\n\nType.forValue = function (val, opts) {\n  opts = opts || {};\n\n  // Sentinel used when inferring the types of empty arrays.\n  opts.emptyArrayType = opts.emptyArrayType || Type.forSchema({\n    type: 'array', items: 'null'\n  });\n\n  // Optional custom inference hook.\n  if (opts.valueHook) {\n    var type = opts.valueHook(val, opts);\n    if (type !== undefined) {\n      if (!Type.isType(type)) {\n        throw new Error(f('invalid value hook return value: %j', type));\n      }\n      return type;\n    }\n  }\n\n  // Default inference logic.\n  switch (typeof val) {\n    case 'string':\n      return Type.forSchema('string', opts);\n    case 'boolean':\n      return Type.forSchema('boolean', opts);\n    case 'number':\n      if ((val | 0) === val) {\n        return Type.forSchema('int', opts);\n      } else if (Math.abs(val) < 9007199254740991) {\n        return Type.forSchema('float', opts);\n      }\n      return Type.forSchema('double', opts);\n    case 'object':\n      if (val === null) {\n        return Type.forSchema('null', opts);\n      } else if (Array.isArray(val)) {\n        if (!val.length) {\n          return opts.emptyArrayType;\n        }\n        return Type.forSchema({\n          type: 'array',\n          items: Type.forTypes(\n            val.map(function (v) { return Type.forValue(v, opts); }),\n            opts\n          )\n        }, opts);\n      } else if (Buffer.isBuffer(val)) {\n        return Type.forSchema('bytes', opts);\n      }\n      var fieldNames = Object.keys(val);\n      if (fieldNames.some(function (s) { return !utils.isValidName(s); })) {\n        // We have to fall back to a map.\n        return Type.forSchema({\n          type: 'map',\n          values: Type.forTypes(fieldNames.map(function (s) {\n            return Type.forValue(val[s], opts);\n          }), opts)\n        }, opts);\n      }\n      return Type.forSchema({\n        type: 'record',\n        fields: fieldNames.map(function (s) {\n          return {name: s, type: Type.forValue(val[s], opts)};\n        })\n      }, opts);\n    default:\n      throw new Error(f('cannot infer type from: %j', val));\n  }\n};\n\nType.forTypes = function (types, opts) {\n  if (!types.length) {\n    throw new Error('no types to combine');\n  }\n  if (types.length === 1) {\n    return types[0]; // Nothing to do.\n  }\n  opts = opts || {};\n\n  // Extract any union types, with special care for wrapped unions (see below).\n  var expanded = [];\n  var numWrappedUnions = 0;\n  var isValidWrappedUnion = true;\n  types.forEach(function (type) {\n    switch (type.typeName) {\n      case 'union:unwrapped':\n        isValidWrappedUnion = false;\n        expanded = expanded.concat(type.types);\n        break;\n      case 'union:wrapped':\n        numWrappedUnions++;\n        expanded = expanded.concat(type.types);\n        break;\n      case 'null':\n        expanded.push(type);\n        break;\n      default:\n        isValidWrappedUnion = false;\n        expanded.push(type);\n    }\n  });\n  if (numWrappedUnions) {\n    if (!isValidWrappedUnion) {\n      // It is only valid to combine wrapped unions when no other type is\n      // present other than wrapped unions and nulls (otherwise the values of\n      // others wouldn't be valid in the resulting union).\n      throw new Error('cannot combine wrapped union');\n    }\n    var branchTypes = {};\n    expanded.forEach(function (type) {\n      var name = type.branchName;\n      var branchType = branchTypes[name];\n      if (!branchType) {\n        branchTypes[name] = type;\n      } else if (!type.equals(branchType)) {\n        throw new Error('inconsistent branch type');\n      }\n    });\n    var wrapUnions = opts.wrapUnions;\n    var unionType;\n    opts.wrapUnions = true;\n    try {\n      unionType = Type.forSchema(Object.keys(branchTypes).map(function (name) {\n        return branchTypes[name];\n      }), opts);\n    } catch (err) {\n      opts.wrapUnions = wrapUnions;\n      throw err;\n    }\n    opts.wrapUnions = wrapUnions;\n    return unionType;\n  }\n\n  // Group types by category, similar to the logic for unwrapped unions.\n  var bucketized = {};\n  expanded.forEach(function (type) {\n    var bucket = getTypeBucket(type);\n    var bucketTypes = bucketized[bucket];\n    if (!bucketTypes) {\n      bucketized[bucket] = bucketTypes = [];\n    }\n    bucketTypes.push(type);\n  });\n\n  // Generate the \"augmented\" type for each group.\n  var buckets = Object.keys(bucketized);\n  var augmented = buckets.map(function (bucket) {\n    var bucketTypes = bucketized[bucket];\n    if (bucketTypes.length === 1) {\n      return bucketTypes[0];\n    } else {\n      switch (bucket) {\n        case 'null':\n        case 'boolean':\n          return bucketTypes[0];\n        case 'number':\n          return combineNumbers(bucketTypes);\n        case 'string':\n          return combineStrings(bucketTypes, opts);\n        case 'buffer':\n          return combineBuffers(bucketTypes, opts);\n        case 'array':\n          // Remove any sentinel arrays (used when inferring from empty arrays)\n          // to avoid making things nullable when they shouldn't be.\n          bucketTypes = bucketTypes.filter(function (t) {\n            return t !== opts.emptyArrayType;\n          });\n          if (!bucketTypes.length) {\n            // We still don't have a real type, just return the sentinel.\n            return opts.emptyArrayType;\n          }\n          return Type.forSchema({\n            type: 'array',\n            items: Type.forTypes(bucketTypes.map(function (t) {\n              return t.itemsType;\n            }), opts)\n          }, opts);\n        default:\n          return combineObjects(bucketTypes, opts);\n      }\n    }\n  });\n\n  if (augmented.length === 1) {\n    return augmented[0];\n  } else {\n    // We return an (unwrapped) union of all augmented types.\n    return Type.forSchema(augmented, opts);\n  }\n};\n\nType.isType = function (/* any, [prefix] ... */) {\n  var l = arguments.length;\n  if (!l) {\n    return false;\n  }\n\n  var any = arguments[0];\n  if (\n    !any ||\n    typeof any._update != 'function' ||\n    typeof any.fingerprint != 'function'\n  ) {\n    // Not fool-proof, but most likely good enough.\n    return false;\n  }\n\n  if (l === 1) {\n    // No type names specified, we are done.\n    return true;\n  }\n\n  // We check if at least one of the prefixes matches.\n  var typeName = any.typeName;\n  var i;\n  for (i = 1; i < l; i++) {\n    if (typeName.indexOf(arguments[i]) === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\nType.__reset = function (size) {\n  debug('resetting type buffer to %d', size);\n  TAP.buf = new buffer.SlowBuffer(size);\n};\n\nObject.defineProperty(Type.prototype, 'branchName', {\n  enumerable: true,\n  get: function () {\n    var type = Type.isType(this, 'logical') ? this.underlyingType : this;\n    if (type.name) {\n      return type.name;\n    }\n    if (Type.isType(type, 'abstract')) {\n      return type._concreteTypeName;\n    }\n    return Type.isType(type, 'union') ? undefined : type.typeName;\n  }\n});\n\nType.prototype.clone = function (val, opts) {\n  if (opts) {\n    opts = {\n      coerce: !!opts.coerceBuffers | 0, // Coerce JSON to Buffer.\n      fieldHook: opts.fieldHook,\n      qualifyNames: !!opts.qualifyNames,\n      skip: !!opts.skipMissingFields,\n      wrap: !!opts.wrapUnions | 0 // Wrap first match into union.\n    };\n    return this._copy(val, opts);\n  } else {\n    // If no modifications are required, we can get by with a serialization\n    // roundtrip (generally much faster than a standard deep copy).\n    return this.fromBuffer(this.toBuffer(val));\n  }\n};\n\nType.prototype.compare = utils.abstractFunction;\n\nType.prototype.compareBuffers = function (buf1, buf2) {\n  return this._match(new Tap(buf1), new Tap(buf2));\n};\n\nType.prototype.createResolver = function (type, opts) {\n  if (!Type.isType(type)) {\n    // More explicit error message than the \"incompatible type\" thrown\n    // otherwise (especially because of the overridden `toJSON` method).\n    throw new Error(f('not a type: %j', type));\n  }\n\n  if (!Type.isType(this, 'union', 'logical') && Type.isType(type, 'logical')) {\n    // Trying to read a logical type as a built-in: unwrap the logical type.\n    // Note that we exclude unions to support resolving into unions containing\n    // logical types.\n    return this.createResolver(type.underlyingType, opts);\n  }\n\n  opts = opts || {};\n  opts.registry = opts.registry || {};\n\n  var resolver, key;\n  if (\n    Type.isType(this, 'record', 'error') &&\n    Type.isType(type, 'record', 'error')\n  ) {\n    // We allow conversions between records and errors.\n    key = this.name + ':' + type.name; // ':' is illegal in Avro type names.\n    resolver = opts.registry[key];\n    if (resolver) {\n      return resolver;\n    }\n  }\n\n  resolver = new Resolver(this);\n  if (key) { // Register resolver early for recursive schemas.\n    opts.registry[key] = resolver;\n  }\n\n  if (Type.isType(type, 'union')) {\n    var resolvers = type.types.map(function (t) {\n      return this.createResolver(t, opts);\n    }, this);\n    resolver._read = function (tap) {\n      var index = tap.readLong();\n      var resolver = resolvers[index];\n      if (resolver === undefined) {\n        throw new Error(f('invalid union index: %s', index));\n      }\n      return resolvers[index]._read(tap);\n    };\n  } else {\n    this._update(resolver, type, opts);\n  }\n\n  if (!resolver._read) {\n    throw new Error(f('cannot read %s as %s', type, this));\n  }\n  return Object.freeze(resolver);\n};\n\nType.prototype.decode = function (buf, pos, resolver) {\n  var tap = new Tap(buf, pos);\n  var val = readValue(this, tap, resolver);\n  if (!tap.isValid()) {\n    return {value: undefined, offset: -1};\n  }\n  return {value: val, offset: tap.pos};\n};\n\nType.prototype.encode = function (val, buf, pos) {\n  var tap = new Tap(buf, pos);\n  this._write(tap, val);\n  if (!tap.isValid()) {\n    // Don't throw as there is no way to predict this. We also return the\n    // number of missing bytes to ease resizing.\n    return buf.length - tap.pos;\n  }\n  return tap.pos;\n};\n\nType.prototype.equals = function (type, opts) {\n  var canon = ( // Canonical equality.\n    Type.isType(type) &&\n    this.fingerprint().equals(type.fingerprint())\n  );\n  if (!canon || !(opts && opts.strict)) {\n    return canon;\n  }\n  return (\n    JSON.stringify(this.schema({exportAttrs: true})) ===\n    JSON.stringify(type.schema({exportAttrs: true}))\n  );\n};\n\nType.prototype.fingerprint = function (algorithm) {\n  if (!algorithm) {\n    if (!this._hash.str) {\n      var schemaStr = JSON.stringify(this.schema());\n      this._hash.str = utils.getHash(schemaStr).toString('binary');\n    }\n    return utils.bufferFrom(this._hash.str, 'binary');\n  } else {\n    return utils.getHash(JSON.stringify(this.schema()), algorithm);\n  }\n};\n\nType.prototype.fromBuffer = function (buf, resolver, noCheck) {\n  var tap = new Tap(buf);\n  var val = readValue(this, tap, resolver, noCheck);\n  if (!tap.isValid()) {\n    throw new Error('truncated buffer');\n  }\n  if (!noCheck && tap.pos < buf.length) {\n    throw new Error('trailing data');\n  }\n  return val;\n};\n\nType.prototype.fromString = function (str) {\n  return this._copy(JSON.parse(str), {coerce: 2});\n};\n\nType.prototype.inspect = function () {\n  var typeName = this.typeName;\n  var className = getClassName(typeName);\n  if (isPrimitive(typeName)) {\n    // The class name is sufficient to identify the type.\n    return f('<%s>', className);\n  } else {\n    // We add a little metadata for convenience.\n    var obj = this.schema({exportAttrs: true, noDeref: true});\n    if (typeof obj == 'object' && !Type.isType(this, 'logical')) {\n      obj.type = undefined; // Would be redundant with constructor name.\n    }\n    return f('<%s %j>', className, obj);\n  }\n};\n\nType.prototype.isValid = function (val, opts) {\n  // We only have a single flag for now, so no need to complicate things.\n  var flags = (opts && opts.noUndeclaredFields) | 0;\n  var errorHook = opts && opts.errorHook;\n  var hook, path;\n  if (errorHook) {\n    path = [];\n    hook = function (any, type) {\n      errorHook.call(this, path.slice(), any, type, val);\n    };\n  }\n  return this._check(val, flags, hook, path);\n};\n\nType.prototype.random = utils.abstractFunction;\n\nType.prototype.schema = function (opts) {\n  // Copy the options to avoid mutating the original options object when we add\n  // the registry of dereferenced types.\n  return this._attrs({\n    exportAttrs: !!(opts && opts.exportAttrs),\n    noDeref: !!(opts && opts.noDeref)\n  });\n};\n\nType.prototype.toBuffer = function (val) {\n  TAP.pos = 0;\n  this._write(TAP, val);\n  var buf = utils.newBuffer(TAP.pos);\n  if (TAP.isValid()) {\n    TAP.buf.copy(buf, 0, 0, TAP.pos);\n  } else {\n    this._write(new Tap(buf), val);\n  }\n  return buf;\n};\n\nType.prototype.toJSON = function () {\n  // Convenience to allow using `JSON.stringify(type)` to get a type's schema.\n  return this.schema({exportAttrs: true});\n};\n\nType.prototype.toString = function (val) {\n  if (val === undefined) {\n    // Consistent behavior with standard `toString` expectations.\n    return JSON.stringify(this.schema({noDeref: true}));\n  }\n  return JSON.stringify(this._copy(val, {coerce: 3}));\n};\n\nType.prototype.wrap = function (val) {\n  var Branch = this._branchConstructor;\n  return Branch === null ? null : new Branch(val);\n};\n\nType.prototype._attrs = function (opts) {\n  // This function handles a lot of the common logic to schema generation\n  // across types, for example keeping track of which types have already been\n  // de-referenced (i.e. derefed).\n  opts.derefed = opts.derefed || {};\n  var name = this.name;\n  if (name !== undefined) {\n    if (opts.noDeref || opts.derefed[name]) {\n      return name;\n    }\n    opts.derefed[name] = true;\n  }\n  var schema = {};\n  // The order in which we add fields to the `schema` object matters here.\n  // Since JS objects are unordered, this implementation (unfortunately) relies\n  // on engines returning properties in the same order that they are inserted\n  // in. This is not in the JS spec, but can be \"somewhat\" safely assumed (see\n  // http://stackoverflow.com/q/5525795/1062617).\n  if (this.name !== undefined) {\n    schema.name = name;\n  }\n  schema.type = this.typeName;\n  var derefedSchema = this._deref(schema, opts);\n  if (derefedSchema !== undefined) {\n    // We allow the original schema to be overridden (this will happen for\n    // primitive types and logical types).\n    schema = derefedSchema;\n  }\n  if (opts.exportAttrs) {\n    if (this.aliases && this.aliases.length) {\n      schema.aliases = this.aliases;\n    }\n    if (this.doc !== undefined) {\n      schema.doc = this.doc;\n    }\n  }\n  return schema;\n};\n\nType.prototype._createBranchConstructor = function () {\n  // jshint -W054\n  var name = this.branchName;\n  if (name === 'null') {\n    return null;\n  }\n  var attr = ~name.indexOf('.') ? 'this[\\'' + name + '\\']' : 'this.' + name;\n  var body = 'return function Branch$(val) { ' + attr + ' = val; };';\n  var Branch = (new Function(body))();\n  Branch.type = this;\n  Branch.prototype.unwrap = new Function('return ' + attr + ';');\n  Branch.prototype.unwrapped = Branch.prototype.unwrap; // Deprecated.\n  return Branch;\n};\n\nType.prototype._peek = function (tap) {\n  var pos = tap.pos;\n  var val = this._read(tap);\n  tap.pos = pos;\n  return val;\n};\n\nType.prototype._check = utils.abstractFunction;\nType.prototype._copy = utils.abstractFunction;\nType.prototype._deref = utils.abstractFunction;\nType.prototype._match = utils.abstractFunction;\nType.prototype._read = utils.abstractFunction;\nType.prototype._skip = utils.abstractFunction;\nType.prototype._update = utils.abstractFunction;\nType.prototype._write = utils.abstractFunction;\n\n// \"Deprecated\" getters (will be explicitly deprecated in 5.1).\n\nType.prototype.getAliases = function () { return this.aliases; };\n\nType.prototype.getFingerprint = Type.prototype.fingerprint;\n\nType.prototype.getName = function (asBranch) {\n  return (this.name || !asBranch) ? this.name : this.branchName;\n};\n\nType.prototype.getSchema = Type.prototype.schema;\n\nType.prototype.getTypeName = function () { return this.typeName; };\n\n// Implementations.\n\n/**\n * Base primitive Avro type.\n *\n * Most of the primitive types share the same cloning and resolution\n * mechanisms, provided by this class. This class also lets us conveniently\n * check whether a type is a primitive using `instanceof`.\n */\nfunction PrimitiveType(noFreeze) {\n  Type.call(this);\n  this._branchConstructor = this._createBranchConstructor();\n  if (!noFreeze) {\n    // Abstract long types can't be frozen at this stage.\n    Object.freeze(this);\n  }\n}\nutil.inherits(PrimitiveType, Type);\n\nPrimitiveType.prototype._update = function (resolver, type) {\n  if (type.typeName === this.typeName) {\n    resolver._read = this._read;\n  }\n};\n\nPrimitiveType.prototype._copy = function (val) {\n  this._check(val, undefined, throwInvalidError);\n  return val;\n};\n\nPrimitiveType.prototype._deref = function () { return this.typeName; };\n\nPrimitiveType.prototype.compare = utils.compare;\n\n/** Nulls. */\nfunction NullType() { PrimitiveType.call(this); }\nutil.inherits(NullType, PrimitiveType);\n\nNullType.prototype._check = function (val, flags, hook) {\n  var b = val === null;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nNullType.prototype._read = function () { return null; };\n\nNullType.prototype._skip = function () {};\n\nNullType.prototype._write = function (tap, val) {\n  if (val !== null) {\n    throwInvalidError(val, this);\n  }\n};\n\nNullType.prototype._match = function () { return 0; };\n\nNullType.prototype.compare = NullType.prototype._match;\n\nNullType.prototype.typeName = 'null';\n\nNullType.prototype.random = NullType.prototype._read;\n\n/** Booleans. */\nfunction BooleanType() { PrimitiveType.call(this); }\nutil.inherits(BooleanType, PrimitiveType);\n\nBooleanType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'boolean';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nBooleanType.prototype._read = function (tap) { return tap.readBoolean(); };\n\nBooleanType.prototype._skip = function (tap) { tap.skipBoolean(); };\n\nBooleanType.prototype._write = function (tap, val) {\n  if (typeof val != 'boolean') {\n    throwInvalidError(val, this);\n  }\n  tap.writeBoolean(val);\n};\n\nBooleanType.prototype._match = function (tap1, tap2) {\n  return tap1.matchBoolean(tap2);\n};\n\nBooleanType.prototype.typeName = 'boolean';\n\nBooleanType.prototype.random = function () { return RANDOM.nextBoolean(); };\n\n/** Integers. */\nfunction IntType() { PrimitiveType.call(this); }\nutil.inherits(IntType, PrimitiveType);\n\nIntType.prototype._check = function (val, flags, hook) {\n  var b = val === (val | 0);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nIntType.prototype._read = function (tap) { return tap.readInt(); };\n\nIntType.prototype._skip = function (tap) { tap.skipInt(); };\n\nIntType.prototype._write = function (tap, val) {\n  if (val !== (val | 0)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeInt(val);\n};\n\nIntType.prototype._match = function (tap1, tap2) {\n  return tap1.matchInt(tap2);\n};\n\nIntType.prototype.typeName = 'int';\n\nIntType.prototype.random = function () { return RANDOM.nextInt(1000) | 0; };\n\n/**\n * Longs.\n *\n * We can't capture all the range unfortunately since JavaScript represents all\n * numbers internally as `double`s, so the default implementation plays safe\n * and throws rather than potentially silently change the data. See `__with` or\n * `AbstractLongType` below for a way to implement a custom long type.\n */\nfunction LongType() { PrimitiveType.call(this); }\nutil.inherits(LongType, PrimitiveType);\n\nLongType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number' && val % 1 === 0 && isSafeLong(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nLongType.prototype._read = function (tap) {\n  var n = tap.readLong();\n  if (!isSafeLong(n)) {\n    throw new Error('potential precision loss');\n  }\n  return n;\n};\n\nLongType.prototype._skip = function (tap) { tap.skipLong(); };\n\nLongType.prototype._write = function (tap, val) {\n  if (typeof val != 'number' || val % 1 || !isSafeLong(val)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(val);\n};\n\nLongType.prototype._match = function (tap1, tap2) {\n  return tap1.matchLong(tap2);\n};\n\nLongType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      resolver._read = this._read; // In case `type` is an `AbstractLongType`.\n  }\n};\n\nLongType.prototype.typeName = 'long';\n\nLongType.prototype.random = function () { return RANDOM.nextInt(); };\n\nLongType.__with = function (methods, noUnpack) {\n  methods = methods || {}; // Will give a more helpful error message.\n  // We map some of the methods to a different name to be able to intercept\n  // their input and output (otherwise we wouldn't be able to perform any\n  // unpacking logic, and the type wouldn't work when nested).\n  var mapping = {\n    toBuffer: '_toBuffer',\n    fromBuffer: '_fromBuffer',\n    fromJSON: '_fromJSON',\n    toJSON: '_toJSON',\n    isValid: '_isValid',\n    compare: 'compare'\n  };\n  var type = new AbstractLongType(noUnpack);\n  Object.keys(mapping).forEach(function (name) {\n    if (methods[name] === undefined) {\n      throw new Error(f('missing method implementation: %s', name));\n    }\n    type[mapping[name]] = methods[name];\n  });\n  return Object.freeze(type);\n};\n\n/** Floats. */\nfunction FloatType() { PrimitiveType.call(this); }\nutil.inherits(FloatType, PrimitiveType);\n\nFloatType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nFloatType.prototype._read = function (tap) { return tap.readFloat(); };\n\nFloatType.prototype._skip = function (tap) { tap.skipFloat(); };\n\nFloatType.prototype._write = function (tap, val) {\n  if (typeof val != 'number') {\n    throwInvalidError(val, this);\n  }\n  tap.writeFloat(val);\n};\n\nFloatType.prototype._match = function (tap1, tap2) {\n  return tap1.matchFloat(tap2);\n};\n\nFloatType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'float':\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      // No need to worry about precision loss here since we're always rounding\n      // to float anyway.\n      resolver._read = function (tap) { return tap.readLong(); };\n  }\n};\n\nFloatType.prototype.typeName = 'float';\n\nFloatType.prototype.random = function () { return RANDOM.nextFloat(1e3); };\n\n/** Doubles. */\nfunction DoubleType() { PrimitiveType.call(this); }\nutil.inherits(DoubleType, PrimitiveType);\n\nDoubleType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nDoubleType.prototype._read = function (tap) { return tap.readDouble(); };\n\nDoubleType.prototype._skip = function (tap) { tap.skipDouble(); };\n\nDoubleType.prototype._write = function (tap, val) {\n  if (typeof val != 'number') {\n    throwInvalidError(val, this);\n  }\n  tap.writeDouble(val);\n};\n\nDoubleType.prototype._match = function (tap1, tap2) {\n  return tap1.matchDouble(tap2);\n};\n\nDoubleType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'double':\n    case 'float':\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      // Similar to inside `FloatType`, no need to worry about precision loss\n      // here since we're always rounding to double anyway.\n      resolver._read = function (tap) { return tap.readLong(); };\n  }\n};\n\nDoubleType.prototype.typeName = 'double';\n\nDoubleType.prototype.random = function () { return RANDOM.nextFloat(); };\n\n/** Strings. */\nfunction StringType() { PrimitiveType.call(this); }\nutil.inherits(StringType, PrimitiveType);\n\nStringType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'string';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nStringType.prototype._read = function (tap) { return tap.readString(); };\n\nStringType.prototype._skip = function (tap) { tap.skipString(); };\n\nStringType.prototype._write = function (tap, val) {\n  if (typeof val != 'string') {\n    throwInvalidError(val, this);\n  }\n  tap.writeString(val);\n};\n\nStringType.prototype._match = function (tap1, tap2) {\n  return tap1.matchString(tap2);\n};\n\nStringType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'bytes':\n    case 'string':\n      resolver._read = this._read;\n  }\n};\n\nStringType.prototype.typeName = 'string';\n\nStringType.prototype.random = function () {\n  return RANDOM.nextString(RANDOM.nextInt(32));\n};\n\n/**\n * Bytes.\n *\n * These are represented in memory as `Buffer`s rather than binary-encoded\n * strings. This is more efficient (when decoding/encoding from bytes, the\n * common use-case), idiomatic, and convenient.\n *\n * Note the coercion in `_copy`.\n */\nfunction BytesType() { PrimitiveType.call(this); }\nutil.inherits(BytesType, PrimitiveType);\n\nBytesType.prototype._check = function (val, flags, hook) {\n  var b = Buffer.isBuffer(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nBytesType.prototype._read = function (tap) { return tap.readBytes(); };\n\nBytesType.prototype._skip = function (tap) { tap.skipBytes(); };\n\nBytesType.prototype._write = function (tap, val) {\n  if (!Buffer.isBuffer(val)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeBytes(val);\n};\n\nBytesType.prototype._match = function (tap1, tap2) {\n  return tap1.matchBytes(tap2);\n};\n\nBytesType.prototype._update = StringType.prototype._update;\n\nBytesType.prototype._copy = function (obj, opts) {\n  var buf;\n  switch ((opts && opts.coerce) | 0) {\n    case 3: // Coerce buffers to strings.\n      this._check(obj, undefined, throwInvalidError);\n      return obj.toString('binary');\n    case 2: // Coerce strings to buffers.\n      if (typeof obj != 'string') {\n        throw new Error(f('cannot coerce to buffer: %j', obj));\n      }\n      buf = utils.bufferFrom(obj, 'binary');\n      this._check(buf, undefined, throwInvalidError);\n      return buf;\n    case 1: // Coerce buffer JSON representation to buffers.\n      if (!isJsonBuffer(obj)) {\n        throw new Error(f('cannot coerce to buffer: %j', obj));\n      }\n      buf = utils.bufferFrom(obj.data);\n      this._check(buf, undefined, throwInvalidError);\n      return buf;\n    default: // Copy buffer.\n      this._check(obj, undefined, throwInvalidError);\n      return utils.bufferFrom(obj);\n  }\n};\n\nBytesType.prototype.compare = Buffer.compare;\n\nBytesType.prototype.typeName = 'bytes';\n\nBytesType.prototype.random = function () {\n  return RANDOM.nextBuffer(RANDOM.nextInt(32));\n};\n\n/** Base \"abstract\" Avro union type. */\nfunction UnionType(schema, opts) {\n  Type.call(this);\n\n  if (!Array.isArray(schema)) {\n    throw new Error(f('non-array union schema: %j', schema));\n  }\n  if (!schema.length) {\n    throw new Error('empty union');\n  }\n  this.types = Object.freeze(schema.map(function (obj) {\n    return Type.forSchema(obj, opts);\n  }));\n\n  this._branchIndices = {};\n  this.types.forEach(function (type, i) {\n    if (Type.isType(type, 'union')) {\n      throw new Error('unions cannot be directly nested');\n    }\n    var branch = type.branchName;\n    if (this._branchIndices[branch] !== undefined) {\n      throw new Error(f('duplicate union branch name: %j', branch));\n    }\n    this._branchIndices[branch] = i;\n  }, this);\n}\nutil.inherits(UnionType, Type);\n\nUnionType.prototype._branchConstructor = function () {\n  throw new Error('unions cannot be directly wrapped');\n};\n\nUnionType.prototype._skip = function (tap) {\n  this.types[tap.readLong()]._skip(tap);\n};\n\nUnionType.prototype._match = function (tap1, tap2) {\n  var n1 = tap1.readLong();\n  var n2 = tap2.readLong();\n  if (n1 === n2) {\n    return this.types[n1]._match(tap1, tap2);\n  } else {\n    return n1 < n2 ? -1 : 1;\n  }\n};\n\nUnionType.prototype._deref = function (schema, opts) {\n  return this.types.map(function (t) { return t._attrs(opts); });\n};\n\nUnionType.prototype.getTypes = function () { return this.types; };\n\n/**\n * \"Natural\" union type.\n *\n * This representation doesn't require a wrapping object and is therefore\n * simpler and generally closer to what users expect. However it cannot be used\n * to represent all Avro unions since some lead to ambiguities (e.g. if two\n * number types are in the union).\n *\n * Currently, this union supports at most one type in each of the categories\n * below:\n *\n * + `null`\n * + `boolean`\n * + `int`, `long`, `float`, `double`\n * + `string`, `enum`\n * + `bytes`, `fixed`\n * + `array`\n * + `map`, `record`\n */\nfunction UnwrappedUnionType(schema, opts) {\n  UnionType.call(this, schema, opts);\n\n  this._dynamicBranches = null;\n  this._bucketIndices = {};\n  this.types.forEach(function (type, index) {\n    if (Type.isType(type, 'abstract', 'logical')) {\n      if (!this._dynamicBranches) {\n        this._dynamicBranches = [];\n      }\n      this._dynamicBranches.push({index: index, type: type});\n    } else {\n      var bucket = getTypeBucket(type);\n      if (this._bucketIndices[bucket] !== undefined) {\n        throw new Error(f('ambiguous unwrapped union: %j', this));\n      }\n      this._bucketIndices[bucket] = index;\n    }\n  }, this);\n\n  Object.freeze(this);\n}\nutil.inherits(UnwrappedUnionType, UnionType);\n\nUnwrappedUnionType.prototype._getIndex = function (val) {\n  var index = this._bucketIndices[getValueBucket(val)];\n  if (this._dynamicBranches) {\n    // Slower path, we must run the value through all branches.\n    index = this._getBranchIndex(val, index);\n  }\n  return index;\n};\n\nUnwrappedUnionType.prototype._getBranchIndex = function (any, index) {\n  var logicalBranches = this._dynamicBranches;\n  var i, l, branch;\n  for (i = 0, l = logicalBranches.length; i < l; i++) {\n    branch = logicalBranches[i];\n    if (branch.type._check(any)) {\n      if (index === undefined) {\n        index = branch.index;\n      } else {\n        // More than one branch matches the value so we aren't guaranteed to\n        // infer the correct type. We throw rather than corrupt data. This can\n        // be fixed by \"tightening\" the logical types.\n        throw new Error('ambiguous conversion');\n      }\n    }\n  }\n  return index;\n};\n\nUnwrappedUnionType.prototype._check = function (val, flags, hook, path) {\n  var index = this._getIndex(val);\n  var b = index !== undefined;\n  if (b) {\n    return this.types[index]._check(val, flags, hook, path);\n  }\n  if (hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nUnwrappedUnionType.prototype._read = function (tap) {\n  var index = tap.readLong();\n  var branchType = this.types[index];\n  if (branchType) {\n    return branchType._read(tap);\n  } else {\n    throw new Error(f('invalid union index: %s', index));\n  }\n};\n\nUnwrappedUnionType.prototype._write = function (tap, val) {\n  var index = this._getIndex(val);\n  if (index === undefined) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(index);\n  if (val !== null) {\n    this.types[index]._write(tap, val);\n  }\n};\n\nUnwrappedUnionType.prototype._update = function (resolver, type, opts) {\n  // jshint -W083\n  // (The loop exits after the first function is created.)\n  var i, l, typeResolver;\n  for (i = 0, l = this.types.length; i < l; i++) {\n    try {\n      typeResolver = this.types[i].createResolver(type, opts);\n    } catch (err) {\n      continue;\n    }\n    resolver._read = function (tap) { return typeResolver._read(tap); };\n    return;\n  }\n};\n\nUnwrappedUnionType.prototype._copy = function (val, opts) {\n  var coerce = opts && opts.coerce | 0;\n  var wrap = opts && opts.wrap | 0;\n  var index;\n  if (wrap === 2) {\n    // We are parsing a default, so always use the first branch's type.\n    index = 0;\n  } else {\n    switch (coerce) {\n      case 1:\n        // Using the `coerceBuffers` option can cause corruption and erroneous\n        // failures with unwrapped unions (in rare cases when the union also\n        // contains a record which matches a buffer's JSON representation).\n        if (isJsonBuffer(val) && this._bucketIndices.buffer !== undefined) {\n          index = this._bucketIndices.buffer;\n        } else {\n          index = this._getIndex(val);\n        }\n        break;\n      case 2:\n        // Decoding from JSON, we must unwrap the value.\n        if (val === null) {\n          index = this._bucketIndices['null'];\n        } else if (typeof val === 'object') {\n          var keys = Object.keys(val);\n          if (keys.length === 1) {\n            index = this._branchIndices[keys[0]];\n            val = val[keys[0]];\n          }\n        }\n        break;\n      default:\n        index = this._getIndex(val);\n    }\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n  }\n  var type = this.types[index];\n  if (val === null || wrap === 3) {\n    return type._copy(val, opts);\n  } else {\n    switch (coerce) {\n      case 3:\n        // Encoding to JSON, we wrap the value.\n        var obj = {};\n        obj[type.branchName] = type._copy(val, opts);\n        return obj;\n      default:\n        return type._copy(val, opts);\n    }\n  }\n};\n\nUnwrappedUnionType.prototype.compare = function (val1, val2) {\n  var index1 = this._getIndex(val1);\n  var index2 = this._getIndex(val2);\n  if (index1 === undefined) {\n    throwInvalidError(val1, this);\n  } else if (index2 === undefined) {\n    throwInvalidError(val2, this);\n  } else if (index1 === index2) {\n    return this.types[index1].compare(val1, val2);\n  } else {\n    return utils.compare(index1, index2);\n  }\n};\n\nUnwrappedUnionType.prototype.typeName = 'union:unwrapped';\n\nUnwrappedUnionType.prototype.random = function () {\n  var index = RANDOM.nextInt(this.types.length);\n  return this.types[index].random();\n};\n\n/**\n * Compatible union type.\n *\n * Values of this type are represented in memory similarly to their JSON\n * representation (i.e. inside an object with single key the name of the\n * contained type).\n *\n * This is not ideal, but is the most efficient way to unambiguously support\n * all unions. Here are a few reasons why the wrapping object is necessary:\n *\n * + Unions with multiple number types would have undefined behavior, unless\n *   numbers are wrapped (either everywhere, leading to large performance and\n *   convenience costs; or only when necessary inside unions, making it hard to\n *   understand when numbers are wrapped or not).\n * + Fixed types would have to be wrapped to be distinguished from bytes.\n * + Using record's constructor names would work (after a slight change to use\n *   the fully qualified name), but would mean that generic objects could no\n *   longer be valid records (making it inconvenient to do simple things like\n *   creating new records).\n */\nfunction WrappedUnionType(schema, opts) {\n  UnionType.call(this, schema, opts);\n  Object.freeze(this);\n}\nutil.inherits(WrappedUnionType, UnionType);\n\nWrappedUnionType.prototype._check = function (val, flags, hook, path) {\n  var b = false;\n  if (val === null) {\n    // Shortcut type lookup in this case.\n    b = this._branchIndices['null'] !== undefined;\n  } else if (typeof val == 'object') {\n    var keys = Object.keys(val);\n    if (keys.length === 1) {\n      // We require a single key here to ensure that writes are correct and\n      // efficient as soon as a record passes this check.\n      var name = keys[0];\n      var index = this._branchIndices[name];\n      if (index !== undefined) {\n        if (hook) {\n          // Slow path.\n          path.push(name);\n          b = this.types[index]._check(val[name], flags, hook, path);\n          path.pop();\n          return b;\n        } else {\n          return this.types[index]._check(val[name], flags);\n        }\n      }\n    }\n  }\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nWrappedUnionType.prototype._read = function (tap) {\n  var type = this.types[tap.readLong()];\n  if (!type) {\n    throw new Error(f('invalid union index'));\n  }\n  var Branch = type._branchConstructor;\n  if (Branch === null) {\n    return null;\n  } else {\n    return new Branch(type._read(tap));\n  }\n};\n\nWrappedUnionType.prototype._write = function (tap, val) {\n  var index, keys, name;\n  if (val === null) {\n    index = this._branchIndices['null'];\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n    tap.writeLong(index);\n  } else {\n    keys = Object.keys(val);\n    if (keys.length === 1) {\n      name = keys[0];\n      index = this._branchIndices[name];\n    }\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n    tap.writeLong(index);\n    this.types[index]._write(tap, val[name]);\n  }\n};\n\nWrappedUnionType.prototype._update = function (resolver, type, opts) {\n  // jshint -W083\n  // (The loop exits after the first function is created.)\n  var i, l, typeResolver, Branch;\n  for (i = 0, l = this.types.length; i < l; i++) {\n    try {\n      typeResolver = this.types[i].createResolver(type, opts);\n    } catch (err) {\n      continue;\n    }\n    Branch = this.types[i]._branchConstructor;\n    if (Branch) {\n      resolver._read = function (tap) {\n        return new Branch(typeResolver._read(tap));\n      };\n    } else {\n      resolver._read = function () { return null; };\n    }\n    return;\n  }\n};\n\nWrappedUnionType.prototype._copy = function (val, opts) {\n  var wrap = opts && opts.wrap | 0;\n  if (wrap === 2) {\n    var firstType = this.types[0];\n    // Promote into first type (used for schema defaults).\n    if (val === null && firstType.typeName === 'null') {\n      return null;\n    }\n    return new firstType._branchConstructor(firstType._copy(val, opts));\n  }\n  if (val === null && this._branchIndices['null'] !== undefined) {\n    return null;\n  }\n\n  var i, l, obj;\n  if (typeof val == 'object') {\n    var keys = Object.keys(val);\n    if (keys.length === 1) {\n      var name = keys[0];\n      i = this._branchIndices[name];\n      if (i === undefined && opts.qualifyNames) {\n        // We are a bit more flexible than in `_check` here since we have\n        // to deal with other serializers being less strict, so we fall\n        // back to looking up unqualified names.\n        var j, type;\n        for (j = 0, l = this.types.length; j < l; j++) {\n          type = this.types[j];\n          if (type.name && name === utils.unqualify(type.name)) {\n            i = j;\n            break;\n          }\n        }\n      }\n      if (i !== undefined) {\n        obj = this.types[i]._copy(val[name], opts);\n      }\n    }\n  }\n  if (wrap === 1 && obj === undefined) {\n    // Try promoting into first match (convenience, slow).\n    i = 0;\n    l = this.types.length;\n    while (i < l && obj === undefined) {\n      try {\n        obj = this.types[i]._copy(val, opts);\n      } catch (err) {\n        i++;\n      }\n    }\n  }\n  if (obj !== undefined) {\n    return wrap === 3 ? obj : new this.types[i]._branchConstructor(obj);\n  }\n  throwInvalidError(val, this);\n};\n\nWrappedUnionType.prototype.compare = function (val1, val2) {\n  var name1 = val1 === null ? 'null' : Object.keys(val1)[0];\n  var name2 = val2 === null ? 'null' : Object.keys(val2)[0];\n  var index = this._branchIndices[name1];\n  if (name1 === name2) {\n    return name1 === 'null' ?\n      0 :\n      this.types[index].compare(val1[name1], val2[name1]);\n  } else {\n    return utils.compare(index, this._branchIndices[name2]);\n  }\n};\n\nWrappedUnionType.prototype.typeName = 'union:wrapped';\n\nWrappedUnionType.prototype.random = function () {\n  var index = RANDOM.nextInt(this.types.length);\n  var type = this.types[index];\n  var Branch = type._branchConstructor;\n  if (!Branch) {\n    return null;\n  }\n  return new Branch(type.random());\n};\n\n/**\n * Avro enum type.\n *\n * Represented as strings (with allowed values from the set of symbols). Using\n * integers would be a reasonable option, but the performance boost is arguably\n * offset by the legibility cost and the extra deviation from the JSON encoding\n * convention.\n *\n * An integer representation can still be used (e.g. for compatibility with\n * TypeScript `enum`s) by overriding the `EnumType` with a `LongType` (e.g. via\n * `parse`'s registry).\n */\nfunction EnumType(schema, opts) {\n  Type.call(this, schema, opts);\n  if (!Array.isArray(schema.symbols) || !schema.symbols.length) {\n    throw new Error(f('invalid enum symbols: %j', schema.symbols));\n  }\n  this.symbols = Object.freeze(schema.symbols.slice());\n  this._indices = {};\n  this.symbols.forEach(function (symbol, i) {\n    if (!utils.isValidName(symbol)) {\n      throw new Error(f('invalid %s symbol: %j', this, symbol));\n    }\n    if (this._indices[symbol] !== undefined) {\n      throw new Error(f('duplicate %s symbol: %j', this, symbol));\n    }\n    this._indices[symbol] = i;\n  }, this);\n  this.default = schema.default;\n  if (this.default !== undefined && this._indices[this.default] === undefined) {\n    throw new Error(f('invalid %s default: %j', this, this.default));\n  }\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(EnumType, Type);\n\nEnumType.prototype._check = function (val, flags, hook) {\n  var b = this._indices[val] !== undefined;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nEnumType.prototype._read = function (tap) {\n  var index = tap.readLong();\n  var symbol = this.symbols[index];\n  if (symbol === undefined) {\n    throw new Error(f('invalid %s enum index: %s', this.name, index));\n  }\n  return symbol;\n};\n\nEnumType.prototype._skip = function (tap) { tap.skipLong(); };\n\nEnumType.prototype._write = function (tap, val) {\n  var index = this._indices[val];\n  if (index === undefined) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(index);\n};\n\nEnumType.prototype._match = function (tap1, tap2) {\n  return tap1.matchLong(tap2);\n};\n\nEnumType.prototype.compare = function (val1, val2) {\n  return utils.compare(this._indices[val1], this._indices[val2]);\n};\n\nEnumType.prototype._update = function (resolver, type, opts) {\n  var symbols = this.symbols;\n  if (\n    type.typeName === 'enum' &&\n    hasCompatibleName(this, type, !opts.ignoreNamespaces) &&\n    (\n      type.symbols.every(function (s) { return ~symbols.indexOf(s); }) ||\n      this.default !== undefined\n    )\n  ) {\n    resolver.symbols = type.symbols.map(function (s) {\n      return this._indices[s] === undefined ? this.default : s;\n    }, this);\n    resolver._read = type._read;\n  }\n};\n\nEnumType.prototype._copy = function (val) {\n  this._check(val, undefined, throwInvalidError);\n  return val;\n};\n\nEnumType.prototype._deref = function (schema) {\n  schema.symbols = this.symbols;\n};\n\nEnumType.prototype.getSymbols = function () { return this.symbols; };\n\nEnumType.prototype.typeName = 'enum';\n\nEnumType.prototype.random = function () {\n  return RANDOM.choice(this.symbols);\n};\n\n/** Avro fixed type. Represented simply as a `Buffer`. */\nfunction FixedType(schema, opts) {\n  Type.call(this, schema, opts);\n  if (schema.size !== (schema.size | 0) || schema.size < 0) {\n    throw new Error(f('invalid %s size', this.branchName));\n  }\n  this.size = schema.size | 0;\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(FixedType, Type);\n\nFixedType.prototype._check = function (val, flags, hook) {\n  var b = Buffer.isBuffer(val) && val.length === this.size;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nFixedType.prototype._read = function (tap) {\n  return tap.readFixed(this.size);\n};\n\nFixedType.prototype._skip = function (tap) {\n  tap.skipFixed(this.size);\n};\n\nFixedType.prototype._write = function (tap, val) {\n  if (!Buffer.isBuffer(val) || val.length !== this.size) {\n    throwInvalidError(val, this);\n  }\n  tap.writeFixed(val, this.size);\n};\n\nFixedType.prototype._match = function (tap1, tap2) {\n  return tap1.matchFixed(tap2, this.size);\n};\n\nFixedType.prototype.compare = Buffer.compare;\n\nFixedType.prototype._update = function (resolver, type, opts) {\n  if (\n    type.typeName === 'fixed' &&\n    this.size === type.size &&\n    hasCompatibleName(this, type, !opts.ignoreNamespaces)\n  ) {\n    resolver.size = this.size;\n    resolver._read = this._read;\n  }\n};\n\nFixedType.prototype._copy = BytesType.prototype._copy;\n\nFixedType.prototype._deref = function (schema) { schema.size = this.size; };\n\nFixedType.prototype.getSize = function () { return this.size; };\n\nFixedType.prototype.typeName = 'fixed';\n\nFixedType.prototype.random = function () {\n  return RANDOM.nextBuffer(this.size);\n};\n\n/** Avro map. Represented as vanilla objects. */\nfunction MapType(schema, opts) {\n  Type.call(this);\n  if (!schema.values) {\n    throw new Error(f('missing map values: %j', schema));\n  }\n  this.valuesType = Type.forSchema(schema.values, opts);\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(MapType, Type);\n\nMapType.prototype._check = function (val, flags, hook, path) {\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\n    if (hook) {\n      hook(val, this);\n    }\n    return false;\n  }\n\n  var keys = Object.keys(val);\n  var b = true;\n  var i, l, j, key;\n  if (hook) {\n    // Slow path.\n    j = path.length;\n    path.push('');\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = path[j] = keys[i];\n      if (!this.valuesType._check(val[key], flags, hook, path)) {\n        b = false;\n      }\n    }\n    path.pop();\n  } else {\n    for (i = 0, l = keys.length; i < l; i++) {\n      if (!this.valuesType._check(val[keys[i]], flags)) {\n        return false;\n      }\n    }\n  }\n  return b;\n};\n\nMapType.prototype._read = function (tap) {\n  var values = this.valuesType;\n  var val = {};\n  var n;\n  while ((n = readArraySize(tap))) {\n    while (n--) {\n      var key = tap.readString();\n      val[key] = values._read(tap);\n    }\n  }\n  return val;\n};\n\nMapType.prototype._skip = function (tap) {\n  var values = this.valuesType;\n  var len, n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      len = tap.readLong();\n      tap.pos += len;\n    } else {\n      while (n--) {\n        tap.skipString();\n        values._skip(tap);\n      }\n    }\n  }\n};\n\nMapType.prototype._write = function (tap, val) {\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n\n  var values = this.valuesType;\n  var keys = Object.keys(val);\n  var n = keys.length;\n  var i, key;\n  if (n) {\n    tap.writeLong(n);\n    for (i = 0; i < n; i++) {\n      key = keys[i];\n      tap.writeString(key);\n      values._write(tap, val[key]);\n    }\n  }\n  tap.writeLong(0);\n};\n\nMapType.prototype._match = function () {\n  throw new Error('maps cannot be compared');\n};\n\nMapType.prototype._update = function (rsv, type, opts) {\n  if (type.typeName === 'map') {\n    rsv.valuesType = this.valuesType.createResolver(type.valuesType, opts);\n    rsv._read = this._read;\n  }\n};\n\nMapType.prototype._copy = function (val, opts) {\n  if (val && typeof val == 'object' && !Array.isArray(val)) {\n    var values = this.valuesType;\n    var keys = Object.keys(val);\n    var i, l, key;\n    var copy = {};\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      copy[key] = values._copy(val[key], opts);\n    }\n    return copy;\n  }\n  throwInvalidError(val, this);\n};\n\nMapType.prototype.compare = MapType.prototype._match;\n\nMapType.prototype.typeName = 'map';\n\nMapType.prototype.getValuesType = function () { return this.valuesType; };\n\nMapType.prototype.random = function () {\n  var val = {};\n  var i, l;\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\n    val[RANDOM.nextString(RANDOM.nextInt(20))] = this.valuesType.random();\n  }\n  return val;\n};\n\nMapType.prototype._deref = function (schema, opts) {\n  schema.values = this.valuesType._attrs(opts);\n};\n\n/** Avro array. Represented as vanilla arrays. */\nfunction ArrayType(schema, opts) {\n  Type.call(this);\n  if (!schema.items) {\n    throw new Error(f('missing array items: %j', schema));\n  }\n  this.itemsType = Type.forSchema(schema.items, opts);\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(ArrayType, Type);\n\nArrayType.prototype._check = function (val, flags, hook, path) {\n  if (!Array.isArray(val)) {\n    if (hook) {\n      hook(val, this);\n    }\n    return false;\n  }\n  var items = this.itemsType;\n  var b = true;\n  var i, l, j;\n  if (hook) {\n    // Slow path.\n    j = path.length;\n    path.push('');\n    for (i = 0, l = val.length; i < l; i++) {\n      path[j] = '' + i;\n      if (!items._check(val[i], flags, hook, path)) {\n        b = false;\n      }\n    }\n    path.pop();\n  } else {\n    for (i = 0, l = val.length; i < l; i++) {\n      if (!items._check(val[i], flags)) {\n        return false;\n      }\n    }\n  }\n  return b;\n};\n\nArrayType.prototype._read = function (tap) {\n  var items = this.itemsType;\n  var i = 0;\n  var val, n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      n = -n;\n      tap.skipLong(); // Skip size.\n    }\n    // Initializing the array on the first batch gives a ~10% speedup. See\n    // https://github.com/mtth/avsc/pull/338 for more context.\n    val = val || new Array(n)\n    while (n--) {\n      val[i++] = items._read(tap);\n    }\n  }\n  return val || [];\n};\n\nArrayType.prototype._skip = function (tap) {\n  var items = this.itemsType;\n  var len, n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      len = tap.readLong();\n      tap.pos += len;\n    } else {\n      while (n--) {\n        items._skip(tap);\n      }\n    }\n  }\n};\n\nArrayType.prototype._write = function (tap, val) {\n  if (!Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n  var items = this.itemsType;\n  var n = val.length;\n  var i;\n  if (n) {\n    tap.writeLong(n);\n    for (i = 0; i < n; i++) {\n      items._write(tap, val[i]);\n    }\n  }\n  tap.writeLong(0);\n};\n\nArrayType.prototype._match = function (tap1, tap2) {\n  var n1 = tap1.readLong();\n  var n2 = tap2.readLong();\n  var f;\n  while (n1 && n2) {\n    f = this.itemsType._match(tap1, tap2);\n    if (f) {\n      return f;\n    }\n    if (!--n1) {\n      n1 = readArraySize(tap1);\n    }\n    if (!--n2) {\n      n2 = readArraySize(tap2);\n    }\n  }\n  return utils.compare(n1, n2);\n};\n\nArrayType.prototype._update = function (resolver, type, opts) {\n  if (type.typeName === 'array') {\n    resolver.itemsType = this.itemsType.createResolver(type.itemsType, opts);\n    resolver._read = this._read;\n  }\n};\n\nArrayType.prototype._copy = function (val, opts) {\n  if (!Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n  var items = new Array(val.length);\n  var i, l;\n  for (i = 0, l = val.length; i < l; i++) {\n    items[i] = this.itemsType._copy(val[i], opts);\n  }\n  return items;\n};\n\nArrayType.prototype._deref = function (schema, opts) {\n  schema.items = this.itemsType._attrs(opts);\n};\n\nArrayType.prototype.compare = function (val1, val2) {\n  var n1 = val1.length;\n  var n2 = val2.length;\n  var i, l, f;\n  for (i = 0, l = Math.min(n1, n2); i < l; i++) {\n    if ((f = this.itemsType.compare(val1[i], val2[i]))) {\n      return f;\n    }\n  }\n  return utils.compare(n1, n2);\n};\n\nArrayType.prototype.getItemsType = function () { return this.itemsType; };\n\nArrayType.prototype.typeName = 'array';\n\nArrayType.prototype.random = function () {\n  var arr = [];\n  var i, l;\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\n    arr.push(this.itemsType.random());\n  }\n  return arr;\n};\n\n/**\n * Avro record.\n *\n * Values are represented as instances of a programmatically generated\n * constructor (similar to a \"specific record\"), available via the\n * `getRecordConstructor` method. This \"specific record class\" gives\n * significant speedups over using generics objects.\n *\n * Note that vanilla objects are still accepted as valid as long as their\n * fields match (this makes it much more convenient to do simple things like\n * update nested records).\n *\n * This type is also used for errors (similar, except for the extra `Error`\n * constructor call) and for messages (see comment below).\n */\nfunction RecordType(schema, opts) {\n  // Force creation of the options object in case we need to register this\n  // record's name.\n  opts = opts || {};\n\n  // Save the namespace to restore it as we leave this record's scope.\n  var namespace = opts.namespace;\n  if (schema.namespace !== undefined) {\n    opts.namespace = schema.namespace;\n  } else if (schema.name) {\n    // Fully qualified names' namespaces are used when no explicit namespace\n    // attribute was specified.\n    var ns = utils.impliedNamespace(schema.name);\n    if (ns !== undefined) {\n      opts.namespace = ns;\n    }\n  }\n  Type.call(this, schema, opts);\n\n  if (!Array.isArray(schema.fields)) {\n    throw new Error(f('non-array record fields: %j', schema.fields));\n  }\n  if (utils.hasDuplicates(schema.fields, function (f) { return f.name; })) {\n    throw new Error(f('duplicate field name: %j', schema.fields));\n  }\n  this._fieldsByName = {};\n  this.fields = Object.freeze(schema.fields.map(function (f) {\n    var field = new Field(f, opts);\n    this._fieldsByName[field.name] = field;\n    return field;\n  }, this));\n  this._branchConstructor = this._createBranchConstructor();\n  this._isError = schema.type === 'error';\n  this.recordConstructor = this._createConstructor(\n    opts.errorStackTraces,\n    opts.omitRecordMethods\n  );\n  this._read = this._createReader();\n  this._skip = this._createSkipper();\n  this._write = this._createWriter();\n  this._check = this._createChecker();\n\n  opts.namespace = namespace;\n  Object.freeze(this);\n}\nutil.inherits(RecordType, Type);\n\nRecordType.prototype._getConstructorName = function () {\n  return this.name ?\n    utils.capitalize(utils.unqualify(this.name)) :\n    this._isError ? 'Error$' : 'Record$';\n};\n\nRecordType.prototype._createConstructor = function (errorStack, plainRecords) {\n  // jshint -W054\n  var outerArgs = [];\n  var innerArgs = [];\n  var ds = []; // Defaults.\n  var innerBody = '';\n  var i, l, field, name, defaultValue, hasDefault, stackField;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    field = this.fields[i];\n    defaultValue = field.defaultValue;\n    hasDefault = defaultValue() !== undefined;\n    name = field.name;\n    if (\n      errorStack && this._isError && name === 'stack' &&\n      Type.isType(field.type, 'string') && !hasDefault\n    ) {\n      // We keep track of whether we've encountered a valid stack field (in\n      // particular, without a default) to populate a stack trace below.\n      stackField = field;\n    }\n    innerArgs.push('v' + i);\n    innerBody += '  ';\n    if (!hasDefault) {\n      innerBody += 'this.' + name + ' = v' + i + ';\\n';\n    } else {\n      innerBody += 'if (v' + i + ' === undefined) { ';\n      innerBody += 'this.' + name + ' = d' + ds.length + '(); ';\n      innerBody += '} else { this.' + name + ' = v' + i + '; }\\n';\n      outerArgs.push('d' + ds.length);\n      ds.push(defaultValue);\n    }\n  }\n  if (stackField) {\n    // We should populate a stack trace.\n    innerBody += '  if (this.stack === undefined) { ';\n    /* istanbul ignore else */\n    if (typeof Error.captureStackTrace == 'function') {\n      // v8 runtimes, the easy case.\n      innerBody += 'Error.captureStackTrace(this, this.constructor);';\n    } else {\n      // A few other runtimes (e.g. SpiderMonkey), might not work everywhere.\n      innerBody += 'this.stack = Error().stack;';\n    }\n    innerBody += ' }\\n';\n  }\n  var outerBody = 'return function ' + this._getConstructorName() + '(';\n  outerBody += innerArgs.join() + ') {\\n' + innerBody + '};';\n  var Record = new Function(outerArgs.join(), outerBody).apply(undefined, ds);\n  if (plainRecords) {\n    return Record;\n  }\n\n  var self = this;\n  Record.getType = function () { return self; };\n  Record.type = self;\n  if (this._isError) {\n    util.inherits(Record, Error);\n    Record.prototype.name = this._getConstructorName();\n  }\n  Record.prototype.clone = function (o) { return self.clone(this, o); };\n  Record.prototype.compare = function (v) { return self.compare(this, v); };\n  Record.prototype.isValid = function (o) { return self.isValid(this, o); };\n  Record.prototype.toBuffer = function () { return self.toBuffer(this); };\n  Record.prototype.toString = function () { return self.toString(this); };\n  Record.prototype.wrap = function () { return self.wrap(this); };\n  Record.prototype.wrapped = Record.prototype.wrap; // Deprecated.\n  return Record;\n};\n\nRecordType.prototype._createChecker = function () {\n  // jshint -W054\n  var names = [];\n  var values = [];\n  var name = this._getConstructorName();\n  var body = 'return function check' + name + '(v, f, h, p) {\\n';\n  body += '  if (\\n';\n  body += '    v === null ||\\n';\n  body += '    typeof v != \\'object\\' ||\\n';\n  body += '    (f && !this._checkFields(v))\\n';\n  body += '  ) {\\n';\n  body += '    if (h) { h(v, this); }\\n';\n  body += '    return false;\\n';\n  body += '  }\\n';\n  if (!this.fields.length) {\n    // Special case, empty record. We handle this directly.\n    body += '  return true;\\n';\n  } else {\n    for (i = 0, l = this.fields.length; i < l; i++) {\n      field = this.fields[i];\n      names.push('t' + i);\n      values.push(field.type);\n      if (field.defaultValue() !== undefined) {\n        body += '  var v' + i + ' = v.' + field.name + ';\\n';\n      }\n    }\n    body += '  if (h) {\\n';\n    body += '    var b = 1;\\n';\n    body += '    var j = p.length;\\n';\n    body += '    p.push(\\'\\');\\n';\n    var i, l, field;\n    for (i = 0, l = this.fields.length; i < l; i++) {\n      field = this.fields[i];\n      body += '    p[j] = \\'' + field.name + '\\';\\n';\n      body += '    b &= ';\n      if (field.defaultValue() === undefined) {\n        body += 't' + i + '._check(v.' + field.name + ', f, h, p);\\n';\n      } else {\n        body += 'v' + i + ' === undefined || ';\n        body += 't' + i + '._check(v' + i + ', f, h, p);\\n';\n      }\n    }\n    body += '    p.pop();\\n';\n    body += '    return !!b;\\n';\n    body += '  } else {\\n    return (\\n      ';\n    body += this.fields.map(function (field, i) {\n      return field.defaultValue() === undefined ?\n        't' + i + '._check(v.' + field.name + ', f)' :\n        '(v' + i + ' === undefined || t' + i + '._check(v' + i + ', f))';\n    }).join(' &&\\n      ');\n    body += '\\n    );\\n  }\\n';\n  }\n  body += '};';\n  return new Function(names.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._createReader = function () {\n  // jshint -W054\n  var names = [];\n  var values = [this.recordConstructor];\n  var i, l;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    names.push('t' + i);\n    values.push(this.fields[i].type);\n  }\n  var name = this._getConstructorName();\n  var body = 'return function read' + name + '(t) {\\n';\n  body += '  return new ' + name + '(\\n    ';\n  body += names.map(function (s) { return s + '._read(t)'; }).join(',\\n    ');\n  body += '\\n  );\\n};';\n  names.unshift(name);\n  // We can do this since the JS spec guarantees that function arguments are\n  // evaluated from left to right.\n  return new Function(names.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._createSkipper = function () {\n  // jshint -W054\n  var args = [];\n  var body = 'return function skip' + this._getConstructorName() + '(t) {\\n';\n  var values = [];\n  var i, l;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    args.push('t' + i);\n    values.push(this.fields[i].type);\n    body += '  t' + i + '._skip(t);\\n';\n  }\n  body += '}';\n  return new Function(args.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._createWriter = function () {\n  // jshint -W054\n  // We still do default handling here, in case a normal JS object is passed.\n  var args = [];\n  var name = this._getConstructorName();\n  var body = 'return function write' + name + '(t, v) {\\n';\n  var values = [];\n  var i, l, field, value;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    field = this.fields[i];\n    args.push('t' + i);\n    values.push(field.type);\n    body += '  ';\n    if (field.defaultValue() === undefined) {\n      body += 't' + i + '._write(t, v.' + field.name + ');\\n';\n    } else {\n      value = field.type.toBuffer(field.defaultValue()).toString('binary');\n      // Convert the default value to a binary string ahead of time. We aren't\n      // converting it to a buffer to avoid retaining too much memory. If we\n      // had our own buffer pool, this could be an idea in the future.\n      args.push('d' + i);\n      values.push(value);\n      body += 'var v' + i + ' = v.' + field.name + ';\\n';\n      body += 'if (v' + i + ' === undefined) {\\n';\n      body += '    t.writeBinary(d' + i + ', ' + value.length + ');\\n';\n      body += '  } else {\\n    t' + i + '._write(t, v' + i + ');\\n  }\\n';\n    }\n  }\n  body += '}';\n  return new Function(args.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._update = function (resolver, type, opts) {\n  // jshint -W054\n  if (!hasCompatibleName(this, type, !opts.ignoreNamespaces)) {\n    throw new Error(f('no alias found for %s', type.name));\n  }\n\n  var rFields = this.fields;\n  var wFields = type.fields;\n  var wFieldsMap = utils.toMap(wFields, function (f) { return f.name; });\n\n  var innerArgs = []; // Arguments for reader constructor.\n  var resolvers = {}; // Resolvers keyed by writer field name.\n  var i, j, field, name, names, matches, fieldResolver;\n  for (i = 0; i < rFields.length; i++) {\n    field = rFields[i];\n    names = getAliases(field);\n    matches = [];\n    for (j = 0; j < names.length; j++) {\n      name = names[j];\n      if (wFieldsMap[name]) {\n        matches.push(name);\n      }\n    }\n    if (matches.length > 1) {\n      throw new Error(\n        f('ambiguous aliasing for %s.%s (%s)', type.name, field.name, matches)\n      );\n    }\n    if (!matches.length) {\n      if (field.defaultValue() === undefined) {\n        throw new Error(\n          f('no matching field for default-less %s.%s', type.name, field.name)\n        );\n      }\n      innerArgs.push('undefined');\n    } else {\n      name = matches[0];\n      fieldResolver = {\n        resolver: field.type.createResolver(wFieldsMap[name].type, opts),\n        name: '_' + field.name, // Reader field name.\n      };\n      if (!resolvers[name]) {\n        resolvers[name] = [fieldResolver];\n      } else {\n        resolvers[name].push(fieldResolver);\n      }\n      innerArgs.push(fieldResolver.name);\n    }\n  }\n\n  // See if we can add a bypass for unused fields at the end of the record.\n  var lazyIndex = -1;\n  i = wFields.length;\n  while (i && resolvers[wFields[--i].name] === undefined) {\n    lazyIndex = i;\n  }\n\n  var uname = this._getConstructorName();\n  var args = [uname];\n  var values = [this.recordConstructor];\n  var body = '  return function read' + uname + '(t, b) {\\n';\n  for (i = 0; i < wFields.length; i++) {\n    if (i === lazyIndex) {\n      body += '  if (!b) {\\n';\n    }\n    field = type.fields[i];\n    name = field.name;\n    if (resolvers[name] === undefined) {\n      body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';\n      args.push('r' + i);\n      values.push(field.type);\n      body += 'r' + i + '._skip(t);\\n';\n    } else {\n      j = resolvers[name].length;\n      while (j--) {\n        body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';\n        args.push('r' + i + 'f' + j);\n        fieldResolver = resolvers[name][j];\n        values.push(fieldResolver.resolver);\n        body += 'var ' + fieldResolver.name + ' = ';\n        body += 'r' + i + 'f' + j + '._' + (j ? 'peek' : 'read') + '(t);\\n';\n      }\n    }\n  }\n  if (~lazyIndex) {\n    body += '  }\\n';\n  }\n  body += '  return new ' + uname + '(' + innerArgs.join() + ');\\n};';\n\n  resolver._read = new Function(args.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._match = function (tap1, tap2) {\n  var fields = this.fields;\n  var i, l, field, order, type;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    order = field._order;\n    type = field.type;\n    if (order) {\n      order *= type._match(tap1, tap2);\n      if (order) {\n        return order;\n      }\n    } else {\n      type._skip(tap1);\n      type._skip(tap2);\n    }\n  }\n  return 0;\n};\n\nRecordType.prototype._checkFields = function (obj) {\n  var keys = Object.keys(obj);\n  var i, l;\n  for (i = 0, l = keys.length; i < l; i++) {\n    if (!this._fieldsByName[keys[i]]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nRecordType.prototype._copy = function (val, opts) {\n  // jshint -W058\n  var hook = opts && opts.fieldHook;\n  var values = [undefined];\n  var i, l, field, value;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    field = this.fields[i];\n    value = val[field.name];\n    if (value === undefined && field.hasOwnProperty('defaultValue')) {\n      value = field.defaultValue();\n    }\n    if ((opts && !opts.skip) || value !== undefined) {\n      value = field.type._copy(value, opts);\n    }\n    if (hook) {\n      value = hook(field, value, this);\n    }\n    values.push(value);\n  }\n  var Record = this.recordConstructor;\n  return new (Record.bind.apply(Record, values))();\n};\n\nRecordType.prototype._deref = function (schema, opts) {\n  schema.fields = this.fields.map(function (field) {\n    var fieldType = field.type;\n    var fieldSchema = {\n      name: field.name,\n      type: fieldType._attrs(opts)\n    };\n    if (opts.exportAttrs) {\n      var val = field.defaultValue();\n      if (val !== undefined) {\n        // We must both unwrap all unions and coerce buffers to strings.\n        fieldSchema['default'] = fieldType._copy(val, {coerce: 3, wrap: 3});\n      }\n      var fieldOrder = field.order;\n      if (fieldOrder !== 'ascending') {\n        fieldSchema.order = fieldOrder;\n      }\n      var fieldAliases = field.aliases;\n      if (fieldAliases.length) {\n        fieldSchema.aliases = fieldAliases;\n      }\n      var fieldDoc = field.doc;\n      if (fieldDoc !== undefined) {\n        fieldSchema.doc = fieldDoc;\n      }\n    }\n    return fieldSchema;\n  });\n};\n\nRecordType.prototype.compare = function (val1, val2) {\n  var fields = this.fields;\n  var i, l, field, name, order, type;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    name = field.name;\n    order = field._order;\n    type = field.type;\n    if (order) {\n      order *= type.compare(val1[name], val2[name]);\n      if (order) {\n        return order;\n      }\n    }\n  }\n  return 0;\n};\n\nRecordType.prototype.random = function () {\n  // jshint -W058\n  var fields = this.fields.map(function (f) { return f.type.random(); });\n  fields.unshift(undefined);\n  var Record = this.recordConstructor;\n  return new (Record.bind.apply(Record, fields))();\n};\n\nRecordType.prototype.field = function (name) {\n  return this._fieldsByName[name];\n};\n\nRecordType.prototype.getField = RecordType.prototype.field;\n\nRecordType.prototype.getFields = function () { return this.fields; };\n\nRecordType.prototype.getRecordConstructor = function () {\n  return this.recordConstructor;\n};\n\nObject.defineProperty(RecordType.prototype, 'typeName', {\n  enumerable: true,\n  get: function () { return this._isError ? 'error' : 'record'; }\n});\n\n/** Derived type abstract class. */\nfunction LogicalType(schema, opts) {\n  this._logicalTypeName = schema.logicalType;\n  Type.call(this);\n  LOGICAL_TYPE = this;\n  try {\n    this._underlyingType = Type.forSchema(schema, opts);\n  } finally {\n    LOGICAL_TYPE = null;\n    // Remove the underlying type now that we're done instantiating. Note that\n    // in some (rare) cases, it might not have been inserted; for example, if\n    // this constructor was manually called with an already instantiated type.\n    var l = UNDERLYING_TYPES.length;\n    if (l && UNDERLYING_TYPES[l - 1][0] === this) {\n      UNDERLYING_TYPES.pop();\n    }\n  }\n  // We create a separate branch constructor for logical types to keep them\n  // monomorphic.\n  if (Type.isType(this.underlyingType, 'union')) {\n    this._branchConstructor = this.underlyingType._branchConstructor;\n  } else {\n    this._branchConstructor = this.underlyingType._createBranchConstructor();\n  }\n  // We don't freeze derived types to allow arbitrary properties. Implementors\n  // can still do so in the subclass' constructor at their convenience.\n}\nutil.inherits(LogicalType, Type);\n\nObject.defineProperty(LogicalType.prototype, 'typeName', {\n  enumerable: true,\n  get: function () { return 'logical:' + this._logicalTypeName; }\n});\n\nObject.defineProperty(LogicalType.prototype, 'underlyingType', {\n  enumerable: true,\n  get: function () {\n    if (this._underlyingType) {\n      return this._underlyingType;\n    }\n    // If the field wasn't present, it means the logical type isn't complete\n    // yet: we're waiting on its underlying type to be fully instantiated. In\n    // this case, it will be present in the `UNDERLYING_TYPES` array.\n    var i, l, arr;\n    for (i = 0, l = UNDERLYING_TYPES.length; i < l; i++) {\n      arr = UNDERLYING_TYPES[i];\n      if (arr[0] === this) {\n        return arr[1];\n      }\n    }\n  }\n});\n\nLogicalType.prototype.getUnderlyingType = function () {\n  return this.underlyingType;\n};\n\nLogicalType.prototype._read = function (tap) {\n  return this._fromValue(this.underlyingType._read(tap));\n};\n\nLogicalType.prototype._write = function (tap, any) {\n  this.underlyingType._write(tap, this._toValue(any));\n};\n\nLogicalType.prototype._check = function (any, flags, hook, path) {\n  try {\n    var val = this._toValue(any);\n  } catch (err) {\n    // Handled below.\n  }\n  if (val === undefined) {\n    if (hook) {\n      hook(any, this);\n    }\n    return false;\n  }\n  return this.underlyingType._check(val, flags, hook, path);\n};\n\nLogicalType.prototype._copy = function (any, opts) {\n  var type = this.underlyingType;\n  switch (opts && opts.coerce) {\n    case 3: // To string.\n      return type._copy(this._toValue(any), opts);\n    case 2: // From string.\n      return this._fromValue(type._copy(any, opts));\n    default: // Normal copy.\n      return this._fromValue(type._copy(this._toValue(any), opts));\n  }\n};\n\nLogicalType.prototype._update = function (resolver, type, opts) {\n  var _fromValue = this._resolve(type, opts);\n  if (_fromValue) {\n    resolver._read = function (tap) { return _fromValue(type._read(tap)); };\n  }\n};\n\nLogicalType.prototype.compare = function (obj1, obj2) {\n  var val1 = this._toValue(obj1);\n  var val2 = this._toValue(obj2);\n  return this.underlyingType.compare(val1, val2);\n};\n\nLogicalType.prototype.random = function () {\n  return this._fromValue(this.underlyingType.random());\n};\n\nLogicalType.prototype._deref = function (schema, opts) {\n  var type = this.underlyingType;\n  var isVisited = type.name !== undefined && opts.derefed[type.name];\n  schema = type._attrs(opts);\n  if (!isVisited && opts.exportAttrs) {\n    if (typeof schema == 'string') {\n      schema = {type: schema};\n    }\n    schema.logicalType = this._logicalTypeName;\n    this._export(schema);\n  }\n  return schema;\n};\n\nLogicalType.prototype._skip = function (tap) {\n  this.underlyingType._skip(tap);\n};\n\n// Unlike the other methods below, `_export` has a reasonable default which we\n// can provide (not exporting anything).\nLogicalType.prototype._export = function (/* schema */) {};\n\n// Methods to be implemented.\nLogicalType.prototype._fromValue = utils.abstractFunction;\nLogicalType.prototype._toValue = utils.abstractFunction;\nLogicalType.prototype._resolve = utils.abstractFunction;\n\n\n// General helpers.\n\n/**\n * Customizable long.\n *\n * This allows support of arbitrarily large long (e.g. larger than\n * `Number.MAX_SAFE_INTEGER`). See `LongType.__with` method above. Note that we\n * can't use a logical type because we need a \"lower-level\" hook here: passing\n * through through the standard long would cause a loss of precision.\n */\nfunction AbstractLongType(noUnpack) {\n  this._concreteTypeName = 'long';\n  PrimitiveType.call(this, true);\n  // Note that this type \"inherits\" `LongType` (i.e. gain its prototype\n  // methods) but only \"subclasses\" `PrimitiveType` to avoid being prematurely\n  // frozen.\n  this._noUnpack = !!noUnpack;\n}\nutil.inherits(AbstractLongType, LongType);\n\nAbstractLongType.prototype.typeName = 'abstract:long';\n\nAbstractLongType.prototype._check = function (val, flags, hook) {\n  var b = this._isValid(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nAbstractLongType.prototype._read = function (tap) {\n  var buf, pos;\n  if (this._noUnpack) {\n    pos = tap.pos;\n    tap.skipLong();\n    buf = tap.buf.slice(pos, tap.pos);\n  } else {\n    buf = tap.unpackLongBytes(tap);\n  }\n  if (tap.isValid()) {\n    return this._fromBuffer(buf);\n  }\n};\n\nAbstractLongType.prototype._write = function (tap, val) {\n  if (!this._isValid(val)) {\n    throwInvalidError(val, this);\n  }\n  var buf = this._toBuffer(val);\n  if (this._noUnpack) {\n    tap.writeFixed(buf);\n  } else {\n    tap.packLongBytes(buf);\n  }\n};\n\nAbstractLongType.prototype._copy = function (val, opts) {\n  switch (opts && opts.coerce) {\n    case 3: // To string.\n      return this._toJSON(val);\n    case 2: // From string.\n      return this._fromJSON(val);\n    default: // Normal copy.\n      // Slow but guarantees most consistent results. Faster alternatives would\n      // require assumptions on the long class used (e.g. immutability).\n      return this._fromJSON(this._toJSON(val));\n  }\n};\n\nAbstractLongType.prototype._deref = function () { return 'long'; };\n\nAbstractLongType.prototype._update = function (resolver, type) {\n  var self = this;\n  switch (type.typeName) {\n    case 'int':\n      resolver._read = function (tap) {\n        return self._fromJSON(type._read(tap));\n      };\n      break;\n    case 'abstract:long':\n    case 'long':\n      resolver._read = function (tap) { return self._read(tap); };\n  }\n};\n\nAbstractLongType.prototype.random = function () {\n  return this._fromJSON(LongType.prototype.random());\n};\n\n// Methods to be implemented by the user.\nAbstractLongType.prototype._fromBuffer = utils.abstractFunction;\nAbstractLongType.prototype._toBuffer = utils.abstractFunction;\nAbstractLongType.prototype._fromJSON = utils.abstractFunction;\nAbstractLongType.prototype._toJSON = utils.abstractFunction;\nAbstractLongType.prototype._isValid = utils.abstractFunction;\nAbstractLongType.prototype.compare = utils.abstractFunction;\n\n/** A record field. */\nfunction Field(schema, opts) {\n  var name = schema.name;\n  if (typeof name != 'string' || !utils.isValidName(name)) {\n    throw new Error(f('invalid field name: %s', name));\n  }\n\n  this.name = name;\n  this.type = Type.forSchema(schema.type, opts);\n  this.aliases = schema.aliases || [];\n  this.doc = schema.doc !== undefined ? '' + schema.doc : undefined;\n\n  this._order = (function (order) {\n    switch (order) {\n      case 'ascending':\n        return 1;\n      case 'descending':\n        return -1;\n      case 'ignore':\n        return 0;\n      default:\n        throw new Error(f('invalid order: %j', order));\n    }\n  })(schema.order === undefined ? 'ascending' : schema.order);\n\n  var value = schema['default'];\n  if (value !== undefined) {\n    // We need to convert defaults back to a valid format (unions are\n    // disallowed in default definitions, only the first type of each union is\n    // allowed instead).\n    // http://apache-avro.679487.n3.nabble.com/field-union-default-in-Java-td1175327.html\n    var type = this.type;\n    var val = type._copy(value, {coerce: 2, wrap: 2});\n    // The clone call above will throw an error if the default is invalid.\n    if (isPrimitive(type.typeName) && type.typeName !== 'bytes') {\n      // These are immutable.\n      this.defaultValue = function () { return val; };\n    } else {\n      this.defaultValue = function () { return type._copy(val); };\n    }\n  }\n\n  Object.freeze(this);\n}\n\nField.prototype.defaultValue = function () {}; // Undefined default.\n\nObject.defineProperty(Field.prototype, 'order', {\n  enumerable: true,\n  get: function () {\n    return ['descending', 'ignore', 'ascending'][this._order + 1];\n  }\n});\n\nField.prototype.getAliases = function () { return this.aliases; };\n\nField.prototype.getDefault = Field.prototype.defaultValue;\n\nField.prototype.getName = function () { return this.name; };\n\nField.prototype.getOrder = function () { return this.order; };\n\nField.prototype.getType = function () { return this.type; };\n\n/**\n * Resolver to read a writer's schema as a new schema.\n *\n * @param readerType {Type} The type to convert to.\n */\nfunction Resolver(readerType) {\n  // Add all fields here so that all resolvers share the same hidden class.\n  this._readerType = readerType;\n  this._read = null;\n  this.itemsType = null;\n  this.size = 0;\n  this.symbols = null;\n  this.valuesType = null;\n}\n\nResolver.prototype._peek = Type.prototype._peek;\n\nResolver.prototype.inspect = function () { return '<Resolver>'; };\n\n/** Mutable hash container. */\nfunction Hash() {\n  this.str = undefined;\n}\n\n/**\n * Read a value from a tap.\n *\n * @param type {Type} The type to decode.\n * @param tap {Tap} The tap to read from. No checks are performed here.\n * @param resolver {Resolver} Optional resolver. It must match the input type.\n * @param lazy {Boolean} Skip trailing fields when using a resolver.\n */\nfunction readValue(type, tap, resolver, lazy) {\n  if (resolver) {\n    if (resolver._readerType !== type) {\n      throw new Error('invalid resolver');\n    }\n    return resolver._read(tap, lazy);\n  } else {\n    return type._read(tap);\n  }\n}\n\n/**\n * Get all aliases for a type (including its name).\n *\n * @param obj {Type|Object} Typically a type or a field. Its aliases property\n * must exist and be an array.\n */\nfunction getAliases(obj) {\n  var names = {};\n  if (obj.name) {\n    names[obj.name] = true;\n  }\n  var aliases = obj.aliases;\n  var i, l;\n  for (i = 0, l = aliases.length; i < l; i++) {\n    names[aliases[i]] = true;\n  }\n  return Object.keys(names);\n}\n\n/** Checks if a type can be read as another based on name resolution rules. */\nfunction hasCompatibleName(reader, writer, strict) {\n  if (!writer.name) {\n    return true;\n  }\n  var name = strict ? writer.name : utils.unqualify(writer.name);\n  var aliases = getAliases(reader);\n  var i, l, alias;\n  for (i = 0, l = aliases.length; i < l; i++) {\n    alias = aliases[i];\n    if (!strict) {\n      alias = utils.unqualify(alias);\n    }\n    if (alias === name) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Check whether a type's name is a primitive.\n *\n * @param name {String} Type name (e.g. `'string'`, `'array'`).\n */\nfunction isPrimitive(typeName) {\n  // Since we use this module's own `TYPES` object, we can use `instanceof`.\n  var type = TYPES[typeName];\n  return type && type.prototype instanceof PrimitiveType;\n}\n\n/**\n * Return a type's class name from its Avro type name.\n *\n * We can't simply use `constructor.name` since it isn't supported in all\n * browsers.\n *\n * @param typeName {String} Type name.\n */\nfunction getClassName(typeName) {\n  if (typeName === 'error') {\n    typeName = 'record';\n  } else {\n    var match = /^([^:]+):(.*)$/.exec(typeName);\n    if (match) {\n      if (match[1] === 'union') {\n        typeName = match[2] + 'Union';\n      } else {\n        // Logical type.\n        typeName = match[1];\n      }\n    }\n  }\n  return utils.capitalize(typeName) + 'Type';\n}\n\n/**\n * Get the number of elements in an array block.\n *\n * @param tap {Tap} A tap positioned at the beginning of an array block.\n */\nfunction readArraySize(tap) {\n  var n = tap.readLong();\n  if (n < 0) {\n    n = -n;\n    tap.skipLong(); // Skip size.\n  }\n  return n;\n}\n\n/**\n * Check whether a long can be represented without precision loss.\n *\n * @param n {Number} The number.\n *\n * Two things to note:\n *\n * + We are not using the `Number` constants for compatibility with older\n *   browsers.\n * + We must remove one from each bound because of rounding errors.\n */\nfunction isSafeLong(n) {\n  return n >= -9007199254740990 && n <= 9007199254740990;\n}\n\n/**\n * Check whether an object is the JSON representation of a buffer.\n */\nfunction isJsonBuffer(obj) {\n  return obj && obj.type === 'Buffer' && Array.isArray(obj.data);\n}\n\n/**\n * Throw a somewhat helpful error on invalid object.\n *\n * @param path {Array} Passed from hook, but unused (because empty where this\n * function is used, since we aren't keeping track of it for effiency).\n * @param val {...} The object to reject.\n * @param type {Type} The type to check against.\n *\n * This method is mostly used from `_write` to signal an invalid object for a\n * given type. Note that this provides less information than calling `isValid`\n * with a hook since the path is not propagated (for efficiency reasons).\n */\nfunction throwInvalidError(val, type) {\n  throw new Error(f('invalid %j: %j', type.schema(), val));\n}\n\nfunction maybeQualify(name, ns) {\n  var unqualified = utils.unqualify(name);\n  // Primitives are always in the global namespace.\n  return isPrimitive(unqualified) ? unqualified : utils.qualify(name, ns);\n}\n\n/**\n * Get a type's bucket when included inside an unwrapped union.\n *\n * @param type {Type} Any type.\n */\nfunction getTypeBucket(type) {\n  var typeName = type.typeName;\n  switch (typeName) {\n    case 'double':\n    case 'float':\n    case 'int':\n    case 'long':\n      return 'number';\n    case 'bytes':\n    case 'fixed':\n      return 'buffer';\n    case 'enum':\n      return 'string';\n    case 'map':\n    case 'error':\n    case 'record':\n      return 'object';\n    default:\n      return typeName;\n  }\n}\n\n/**\n * Infer a value's bucket (see unwrapped unions for more details).\n *\n * @param val {...} Any value.\n */\nfunction getValueBucket(val) {\n  if (val === null) {\n    return 'null';\n  }\n  var bucket = typeof val;\n  if (bucket === 'object') {\n    // Could be bytes, fixed, array, map, or record.\n    if (Array.isArray(val)) {\n      return 'array';\n    } else if (Buffer.isBuffer(val)) {\n      return 'buffer';\n    }\n  }\n  return bucket;\n}\n\n/**\n * Check whether a collection of types leads to an ambiguous union.\n *\n * @param types {Array} Array of types.\n */\nfunction isAmbiguous(types) {\n  var buckets = {};\n  var i, l, bucket, type;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (!Type.isType(type, 'logical')) {\n      bucket = getTypeBucket(type);\n      if (buckets[bucket]) {\n        return true;\n      }\n      buckets[bucket] = true;\n    }\n  }\n  return false;\n}\n\n/**\n * Combine number types.\n *\n * Note that never have to create a new type here, we are guaranteed to be able\n * to reuse one of the input types as super-type.\n */\nfunction combineNumbers(types) {\n  var typeNames = ['int', 'long', 'float', 'double'];\n  var superIndex = -1;\n  var superType = null;\n  var i, l, type, index;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    index = typeNames.indexOf(type.typeName);\n    if (index > superIndex) {\n      superIndex = index;\n      superType = type;\n    }\n  }\n  return superType;\n}\n\n/**\n * Combine enums and strings.\n *\n * The order of the returned symbols is undefined and the returned enum is\n *\n */\nfunction combineStrings(types, opts) {\n  var symbols = {};\n  var i, l, type, typeSymbols;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'string') {\n      // If at least one of the types is a string, it will be the supertype.\n      return type;\n    }\n    typeSymbols = type.symbols;\n    var j, m;\n    for (j = 0, m = typeSymbols.length; j < m; j++) {\n      symbols[typeSymbols[j]] = true;\n    }\n  }\n  return Type.forSchema({type: 'enum', symbols: Object.keys(symbols)}, opts);\n}\n\n/**\n * Combine bytes and fixed.\n *\n * This function is optimized to avoid creating new types when possible: in\n * case of a size mismatch between fixed types, it will continue looking\n * through the array to find an existing bytes type (rather than exit early by\n * creating one eagerly).\n */\nfunction combineBuffers(types, opts) {\n  var size = -1;\n  var i, l, type;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'bytes') {\n      return type;\n    }\n    if (size === -1) {\n      size = type.size;\n    } else if (type.size !== size) {\n      // Don't create a bytes type right away, we might be able to reuse one\n      // later on in the types array. Just mark this for now.\n      size = -2;\n    }\n  }\n  return size < 0 ? Type.forSchema('bytes', opts) : types[0];\n}\n\n/**\n * Combine maps and records.\n *\n * Field defaults are kept when possible (i.e. when no coercion to a map\n * happens), with later definitions overriding previous ones.\n */\nfunction combineObjects(types, opts) {\n  var allTypes = []; // Field and value types.\n  var fieldTypes = {}; // Record field types grouped by field name.\n  var fieldDefaults = {};\n  var isValidRecord = true;\n\n  // Check whether the final type will be a map or a record.\n  var i, l, type, fields;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'map') {\n      isValidRecord = false;\n      allTypes.push(type.valuesType);\n    } else {\n      fields = type.fields;\n      var j, m, field, fieldDefault, fieldName, fieldType;\n      for (j = 0, m = fields.length; j < m; j++) {\n        field = fields[j];\n        fieldName = field.name;\n        fieldType = field.type;\n        allTypes.push(fieldType);\n        if (isValidRecord) {\n          if (!fieldTypes[fieldName]) {\n            fieldTypes[fieldName] = [];\n          }\n          fieldTypes[fieldName].push(fieldType);\n          fieldDefault = field.defaultValue();\n          if (fieldDefault !== undefined) {\n            // Later defaults will override any previous ones.\n            fieldDefaults[fieldName] = fieldDefault;\n          }\n        }\n      }\n    }\n  }\n\n  if (isValidRecord) {\n    // Check that no fields are missing and that we have the approriate\n    // defaults for those which are.\n    var fieldNames = Object.keys(fieldTypes);\n    for (i = 0, l = fieldNames.length; i < l; i++) {\n      fieldName = fieldNames[i];\n      if (\n        fieldTypes[fieldName].length < types.length &&\n        fieldDefaults[fieldName] === undefined\n      ) {\n        // At least one of the records is missing a field with no default.\n        if (opts && opts.strictDefaults) {\n          isValidRecord = false;\n        } else {\n          fieldTypes[fieldName].unshift(Type.forSchema('null', opts));\n          fieldDefaults[fieldName] = null;\n        }\n      }\n    }\n  }\n\n  var schema;\n  if (isValidRecord) {\n    schema = {\n      type: 'record',\n      fields: fieldNames.map(function (s) {\n        var fieldType = Type.forTypes(fieldTypes[s], opts);\n        var fieldDefault = fieldDefaults[s];\n        if (\n          fieldDefault !== undefined &&\n          ~fieldType.typeName.indexOf('union')\n        ) {\n          // Ensure that the default's corresponding type is first.\n          var unionTypes = fieldType.types.slice();\n          var i, l;\n          for (i = 0, l = unionTypes.length; i < l; i++) {\n            if (unionTypes[i].isValid(fieldDefault)) {\n              break;\n            }\n          }\n          if (i > 0) {\n            var unionType = unionTypes[0];\n            unionTypes[0] = unionTypes[i];\n            unionTypes[i] = unionType;\n            fieldType = Type.forSchema(unionTypes, opts);\n          }\n        }\n        return {\n          name: s,\n          type: fieldType,\n          'default': fieldDefaults[s]\n        };\n      })\n    };\n  } else {\n    schema = {\n      type: 'map',\n      values: Type.forTypes(allTypes, opts)\n    };\n  }\n  return Type.forSchema(schema, opts);\n}\n\n\nmodule.exports = {\n  Type: Type,\n  getTypeBucket: getTypeBucket,\n  getValueBucket: getValueBucket,\n  isPrimitive: isPrimitive,\n  builtins: (function () {\n    var types = {\n      LogicalType: LogicalType,\n      UnwrappedUnionType: UnwrappedUnionType,\n      WrappedUnionType: WrappedUnionType\n    };\n    var typeNames = Object.keys(TYPES);\n    var i, l, typeName;\n    for (i = 0, l = typeNames.length; i < l; i++) {\n      typeName = typeNames[i];\n      types[getClassName(typeName)] = TYPES[typeName];\n    }\n    return types;\n  })()\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/types.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/utils.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/utils.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\n\n// TODO: Make long comparison impervious to precision loss.\n// TODO: Optimize binary comparison methods.\n\n\n\n/** Various utilities used across this library. */\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n// Shared buffer pool for all taps.\nvar POOL = new BufferPool(4096);\n\n// Valid (field, type, and symbol) name regex.\nvar NAME_PATTERN = /^[A-Za-z_][A-Za-z0-9_]*$/;\n\n// Convenience imports.\nvar f = util.format;\n\n/**\n * Create a new empty buffer.\n *\n * @param size {Number} The buffer's size.\n */\nfunction newBuffer(size) {\n  if (typeof Buffer.alloc == 'function') {\n    return Buffer.alloc(size);\n  } else {\n    return new Buffer(size);\n  }\n}\n\n/**\n * Create a new buffer with the input contents.\n *\n * @param data {Array|String} The buffer's data.\n * @param enc {String} Encoding, used if data is a string.\n */\nfunction bufferFrom(data, enc) {\n  if (typeof Buffer.from == 'function') {\n    return Buffer.from(data, enc);\n  } else {\n    return new Buffer(data, enc);\n  }\n}\n\n/**\n * Uppercase the first letter of a string.\n *\n * @param s {String} The string.\n */\nfunction capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }\n\n/**\n * Compare two numbers.\n *\n * @param n1 {Number} The first one.\n * @param n2 {Number} The second one.\n */\nfunction compare(n1, n2) { return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1); }\n\n/**\n * Get option or default if undefined.\n *\n * @param opts {Object} Options.\n * @param key {String} Name of the option.\n * @param def {...} Default value.\n *\n * This is useful mostly for true-ish defaults and false-ish values (where the\n * usual `||` idiom breaks down).\n */\nfunction getOption(opts, key, def) {\n  var value = opts[key];\n  return value === undefined ? def : value;\n}\n\n/**\n * Compute a string's hash.\n *\n * @param str {String} The string to hash.\n * @param algorithm {String} The algorithm used. Defaults to MD5.\n */\nfunction getHash(str, algorithm) {\n  algorithm = algorithm || 'md5';\n  var hash = crypto.createHash(algorithm);\n  hash.end(str);\n  return hash.read();\n}\n\n/**\n * Find index of value in array.\n *\n * @param arr {Array} Can also be a false-ish value.\n * @param v {Object} Value to find.\n *\n * Returns -1 if not found, -2 if found multiple times.\n */\nfunction singleIndexOf(arr, v) {\n  var pos = -1;\n  var i, l;\n  if (!arr) {\n    return -1;\n  }\n  for (i = 0, l = arr.length; i < l; i++) {\n    if (arr[i] === v) {\n      if (pos >= 0) {\n        return -2;\n      }\n      pos = i;\n    }\n  }\n  return pos;\n}\n\n/**\n * Convert array to map.\n *\n * @param arr {Array} Elements.\n * @param fn {Function} Function returning an element's key.\n */\nfunction toMap(arr, fn) {\n  var obj = {};\n  var i, elem;\n  for (i = 0; i < arr.length; i++) {\n    elem = arr[i];\n    obj[fn(elem)] = elem;\n  }\n  return obj;\n}\n\n/**\n * Convert map to array of values (polyfill for `Object.values`).\n *\n * @param obj {Object} Map.\n */\nfunction objectValues(obj) {\n  return Object.keys(obj).map(function (key) { return obj[key]; });\n}\n\n/**\n * Check whether an array has duplicates.\n *\n * @param arr {Array} The array.\n * @param fn {Function} Optional function to apply to each element.\n */\nfunction hasDuplicates(arr, fn) {\n  var obj = Object.create(null);\n  var i, l, elem;\n  for (i = 0, l = arr.length; i < l; i++) {\n    elem = arr[i];\n    if (fn) {\n      elem = fn(elem);\n    }\n    if (obj[elem]) {\n      return true;\n    }\n    obj[elem] = true;\n  }\n  return false;\n}\n\n/**\n * Copy properties from one object to another.\n *\n * @param src {Object} The source object.\n * @param dst {Object} The destination object.\n * @param overwrite {Boolean} Whether to overwrite existing destination\n * properties. Defaults to false.\n */\nfunction copyOwnProperties(src, dst, overwrite) {\n  var names = Object.getOwnPropertyNames(src);\n  var i, l, name;\n  for (i = 0, l = names.length; i < l; i++) {\n    name = names[i];\n    if (!dst.hasOwnProperty(name) || overwrite) {\n      var descriptor = Object.getOwnPropertyDescriptor(src, name);\n      Object.defineProperty(dst, name, descriptor);\n    }\n  }\n  return dst;\n}\n\n/**\n * Check whether a string is a valid Avro identifier.\n */\nfunction isValidName(str) { return NAME_PATTERN.test(str); }\n\n/**\n * Verify and return fully qualified name.\n *\n * @param name {String} Full or short name. It can be prefixed with a dot to\n * force global namespace.\n * @param namespace {String} Optional namespace.\n */\nfunction qualify(name, namespace) {\n  if (~name.indexOf('.')) {\n    name = name.replace(/^\\./, ''); // Allow absolute referencing.\n  } else if (namespace) {\n    name = namespace + '.' + name;\n  }\n  name.split('.').forEach(function (part) {\n    if (!isValidName(part)) {\n      throw new Error(f('invalid name: %j', name));\n    }\n  });\n  return name;\n}\n\n/**\n * Remove namespace from a name.\n *\n * @param name {String} Full or short name.\n */\nfunction unqualify(name) {\n  var parts = name.split('.');\n  return parts[parts.length - 1];\n}\n\n/**\n * Return the namespace implied by a name.\n *\n * @param name {String} Full or short name. If short, the returned namespace\n *  will be empty.\n */\nfunction impliedNamespace(name) {\n  var match = /^(.*)\\.[^.]+$/.exec(name);\n  return match ? match[1] : undefined;\n}\n\n/**\n * Returns offset in the string of the end of JSON object (-1 if past the end).\n *\n * To keep the implementation simple, this function isn't a JSON validator. It\n * will gladly return a result for invalid JSON (which is OK since that will be\n * promptly rejected by the JSON parser). What matters is that it is guaranteed\n * to return the correct end when presented with valid JSON.\n *\n * @param str {String} Input string containing serialized JSON..\n * @param pos {Number} Starting position.\n */\nfunction jsonEnd(str, pos) {\n  pos = pos | 0;\n\n  // Handle the case of a simple literal separately.\n  var c = str.charAt(pos++);\n  if (/[\\d-]/.test(c)) {\n    while (/[eE\\d.+-]/.test(str.charAt(pos))) {\n      pos++;\n    }\n    return pos;\n  } else if (/true|null/.test(str.slice(pos - 1, pos + 3))) {\n    return pos + 3;\n  } else if (/false/.test(str.slice(pos - 1, pos + 4))) {\n    return pos + 4;\n  }\n\n  // String, object, or array.\n  var depth = 0;\n  var literal = false;\n  do {\n    switch (c) {\n    case '{':\n    case '[':\n      if (!literal) { depth++; }\n      break;\n    case '}':\n    case ']':\n      if (!literal && !--depth) {\n        return pos;\n      }\n      break;\n    case '\"':\n      literal = !literal;\n      if (!depth && !literal) {\n        return pos;\n      }\n      break;\n    case '\\\\':\n      pos++; // Skip the next character.\n    }\n  } while ((c = str.charAt(pos++)));\n\n  return -1;\n}\n\n/** \"Abstract\" function to help with \"subclassing\". */\nfunction abstractFunction() { throw new Error('abstract'); }\n\n/** Batch-deprecate \"getters\" from an object's prototype. */\nfunction addDeprecatedGetters(obj, props) {\n  var proto = obj.prototype;\n  var i, l, prop, getter;\n  for (i = 0, l = props.length; i < l; i++) {\n    prop = props[i];\n    getter = 'get' + capitalize(prop);\n    proto[getter] = util.deprecate(\n      createGetter(prop),\n      'use `.' + prop + '` instead of `.' + getter + '()`'\n    );\n  }\n\n  function createGetter(prop) {\n    return function () {\n      var delegate = this[prop];\n      return typeof delegate == 'function' ?\n        delegate.apply(this, arguments) :\n        delegate;\n    };\n  }\n}\n\n/**\n * Simple buffer pool to avoid allocating many small buffers.\n *\n * This provides significant speedups in recent versions of node (6+).\n */\nfunction BufferPool(len) {\n  this._len = len | 0;\n  this._pos = 0;\n  this._slab = newBuffer(this._len);\n}\n\nBufferPool.prototype.alloc = function (len) {\n  if (len < 0) {\n    throw new Error('negative length');\n  }\n  var maxLen = this._len;\n  if (len > maxLen) {\n    return newBuffer(len);\n  }\n  if (this._pos + len > maxLen) {\n    this._slab = newBuffer(maxLen);\n    this._pos = 0;\n  }\n  return this._slab.slice(this._pos, this._pos += len);\n};\n\n/**\n * Generator of random things.\n *\n * Inspired by: http://stackoverflow.com/a/424445/1062617\n */\nfunction Lcg(seed) {\n  var a = 1103515245;\n  var c = 12345;\n  var m = Math.pow(2, 31);\n  var state = Math.floor(seed || Math.random() * (m - 1));\n\n  this._max = m;\n  this._nextInt = function () { return state = (a * state + c) % m; };\n}\n\nLcg.prototype.nextBoolean = function () {\n  // jshint -W018\n  return !!(this._nextInt() % 2);\n};\n\nLcg.prototype.nextInt = function (start, end) {\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  end = end === undefined ? this._max : end;\n  return start + Math.floor(this.nextFloat() * (end - start));\n};\n\nLcg.prototype.nextFloat = function (start, end) {\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  end = end === undefined ? 1 : end;\n  return start + (end - start) * this._nextInt() / this._max;\n};\n\nLcg.prototype.nextString = function(len, flags) {\n  len |= 0;\n  flags = flags || 'aA';\n  var mask = '';\n  if (flags.indexOf('a') > -1) {\n    mask += 'abcdefghijklmnopqrstuvwxyz';\n  }\n  if (flags.indexOf('A') > -1) {\n    mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  }\n  if (flags.indexOf('#') > -1) {\n    mask += '0123456789';\n  }\n  if (flags.indexOf('!') > -1) {\n    mask += '~`!@#$%^&*()_+-={}[]:\";\\'<>?,./|\\\\';\n  }\n  var result = [];\n  for (var i = 0; i < len; i++) {\n    result.push(this.choice(mask));\n  }\n  return result.join('');\n};\n\nLcg.prototype.nextBuffer = function (len) {\n  var arr = [];\n  var i;\n  for (i = 0; i < len; i++) {\n    arr.push(this.nextInt(256));\n  }\n  return bufferFrom(arr);\n};\n\nLcg.prototype.choice = function (arr) {\n  var len = arr.length;\n  if (!len) {\n    throw new Error('choosing from empty array');\n  }\n  return arr[this.nextInt(len)];\n};\n\n/**\n * Ordered queue which returns items consecutively.\n *\n * This is actually a heap by index, with the added requirements that elements\n * can only be retrieved consecutively.\n */\nfunction OrderedQueue() {\n  this._index = 0;\n  this._items = [];\n}\n\nOrderedQueue.prototype.push = function (item) {\n  var items = this._items;\n  var i = items.length | 0;\n  var j;\n  items.push(item);\n  while (i > 0 && items[i].index < items[j = ((i - 1) >> 1)].index) {\n    item = items[i];\n    items[i] = items[j];\n    items[j] = item;\n    i = j;\n  }\n};\n\nOrderedQueue.prototype.pop = function () {\n  var items = this._items;\n  var len = (items.length - 1) | 0;\n  var first = items[0];\n  if (!first || first.index > this._index) {\n    return null;\n  }\n  this._index++;\n  if (!len) {\n    items.pop();\n    return first;\n  }\n  items[0] = items.pop();\n  var mid = len >> 1;\n  var i = 0;\n  var i1, i2, j, item, c, c1, c2;\n  while (i < mid) {\n    item = items[i];\n    i1 = (i << 1) + 1;\n    i2 = (i + 1) << 1;\n    c1 = items[i1];\n    c2 = items[i2];\n    if (!c2 || c1.index <= c2.index) {\n      c = c1;\n      j = i1;\n    } else {\n      c = c2;\n      j = i2;\n    }\n    if (c.index >= item.index) {\n      break;\n    }\n    items[j] = item;\n    items[i] = c;\n    i = j;\n  }\n  return first;\n};\n\n/**\n * A tap is a buffer which remembers what has been already read.\n *\n * It is optimized for performance, at the cost of failing silently when\n * overflowing the buffer. This is a purposeful trade-off given the expected\n * rarity of this case and the large performance hit necessary to enforce\n * validity. See `isValid` below for more information.\n */\nfunction Tap(buf, pos) {\n  this.buf = buf;\n  this.pos = pos | 0;\n  if (this.pos < 0) {\n    throw new Error('negative offset');\n  }\n}\n\n/**\n * Check that the tap is in a valid state.\n *\n * For efficiency reasons, none of the methods below will fail if an overflow\n * occurs (either read, skip, or write). For this reason, it is up to the\n * caller to always check that the read, skip, or write was valid by calling\n * this method.\n */\nTap.prototype.isValid = function () { return this.pos <= this.buf.length; };\n\nTap.prototype._invalidate = function () { this.pos = this.buf.length + 1; };\n\n// Read, skip, write methods.\n//\n// These should fail silently when the buffer overflows. Note this is only\n// required to be true when the functions are decoding valid objects. For\n// example errors will still be thrown if a bad count is read, leading to a\n// negative position offset (which will typically cause a failure in\n// `readFixed`).\n\nTap.prototype.readBoolean = function () { return !!this.buf[this.pos++]; };\n\nTap.prototype.skipBoolean = function () { this.pos++; };\n\nTap.prototype.writeBoolean = function (b) { this.buf[this.pos++] = !!b; };\n\nTap.prototype.readInt = Tap.prototype.readLong = function () {\n  var n = 0;\n  var k = 0;\n  var buf = this.buf;\n  var b, h, f, fk;\n\n  do {\n    b = buf[this.pos++];\n    h = b & 0x80;\n    n |= (b & 0x7f) << k;\n    k += 7;\n  } while (h && k < 28);\n\n  if (h) {\n    // Switch to float arithmetic, otherwise we might overflow.\n    f = n;\n    fk = 268435456; // 2 ** 28.\n    do {\n      b = buf[this.pos++];\n      f += (b & 0x7f) * fk;\n      fk *= 128;\n    } while (b & 0x80);\n    return (f % 2 ? -(f + 1) : f) / 2;\n  }\n\n  return (n >> 1) ^ -(n & 1);\n};\n\nTap.prototype.skipInt = Tap.prototype.skipLong = function () {\n  var buf = this.buf;\n  while (buf[this.pos++] & 0x80) {}\n};\n\nTap.prototype.writeInt = Tap.prototype.writeLong = function (n) {\n  var buf = this.buf;\n  var f, m;\n\n  if (n >= -1073741824 && n < 1073741824) {\n    // Won't overflow, we can use integer arithmetic.\n    m = n >= 0 ? n << 1 : (~n << 1) | 1;\n    do {\n      buf[this.pos] = m & 0x7f;\n      m >>= 7;\n    } while (m && (buf[this.pos++] |= 0x80));\n  } else {\n    // We have to use slower floating arithmetic.\n    f = n >= 0 ? n * 2 : (-n * 2) - 1;\n    do {\n      buf[this.pos] = f & 0x7f;\n      f /= 128;\n    } while (f >= 1 && (buf[this.pos++] |= 0x80));\n  }\n  this.pos++;\n};\n\nTap.prototype.readFloat = function () {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 4;\n  if (this.pos > buf.length) {\n    return 0;\n  }\n  return this.buf.readFloatLE(pos);\n};\n\nTap.prototype.skipFloat = function () { this.pos += 4; };\n\nTap.prototype.writeFloat = function (f) {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 4;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.writeFloatLE(f, pos);\n};\n\nTap.prototype.readDouble = function () {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 8;\n  if (this.pos > buf.length) {\n    return 0;\n  }\n  return this.buf.readDoubleLE(pos);\n};\n\nTap.prototype.skipDouble = function () { this.pos += 8; };\n\nTap.prototype.writeDouble = function (d) {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 8;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.writeDoubleLE(d, pos);\n};\n\nTap.prototype.readFixed = function (len) {\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  var fixed = POOL.alloc(len);\n  this.buf.copy(fixed, 0, pos, pos + len);\n  return fixed;\n};\n\nTap.prototype.skipFixed = function (len) { this.pos += len; };\n\nTap.prototype.writeFixed = function (buf, len) {\n  len = len || buf.length;\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  buf.copy(this.buf, pos, 0, len);\n};\n\nTap.prototype.readBytes = function () {\n  var len = this.readLong();\n  if (len < 0) {\n    this._invalidate();\n    return;\n  }\n  return this.readFixed(len);\n};\n\nTap.prototype.skipBytes = function () {\n  var len = this.readLong();\n  if (len < 0) {\n    this._invalidate();\n    return;\n  }\n  this.pos += len;\n};\n\nTap.prototype.writeBytes = function (buf) {\n  var len = buf.length;\n  this.writeLong(len);\n  this.writeFixed(buf, len);\n};\n\n/* istanbul ignore else */\nif (typeof Buffer.prototype.utf8Slice == 'function') {\n  // Use this optimized function when available.\n  Tap.prototype.readString = function () {\n    var len = this.readLong();\n    if (len < 0) {\n      this._invalidate();\n      return '';\n    }\n    var pos = this.pos;\n    var buf = this.buf;\n    this.pos += len;\n    if (this.pos > buf.length) {\n      return;\n    }\n    return this.buf.utf8Slice(pos, pos + len);\n  };\n} else {\n  Tap.prototype.readString = function () {\n    var len = this.readLong();\n    if (len < 0) {\n      this._invalidate();\n      return '';\n    }\n    var pos = this.pos;\n    var buf = this.buf;\n    this.pos += len;\n    if (this.pos > buf.length) {\n      return;\n    }\n    return this.buf.slice(pos, pos + len).toString();\n  };\n}\n\nTap.prototype.skipString = function () {\n  var len = this.readLong();\n  if (len < 0) {\n    this._invalidate();\n    return;\n  }\n  this.pos += len;\n};\n\nTap.prototype.writeString = function (s) {\n  var len = Buffer.byteLength(s);\n  var buf = this.buf;\n  this.writeLong(len);\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > buf.length) {\n    return;\n  }\n  if (len > 64 && typeof Buffer.prototype.utf8Write == 'function') {\n    // This method is roughly 50% faster than the manual implementation below\n    // for long strings (which is itself faster than the generic `Buffer#write`\n    // at least in most browsers, where `utf8Write` is not available).\n    buf.utf8Write(s, pos, len);\n  } else {\n    var i, l, c1, c2;\n    for (i = 0, l = len; i < l; i++) {\n      c1 = s.charCodeAt(i);\n      if (c1 < 0x80) {\n        buf[pos++] = c1;\n      } else if (c1 < 0x800) {\n        buf[pos++] = c1 >> 6 | 0xc0;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      } else if (\n        (c1 & 0xfc00) === 0xd800 &&\n        ((c2 = s.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n      ) {\n        c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n        i++;\n        buf[pos++] = c1 >> 18 | 0xf0;\n        buf[pos++] = c1 >> 12 & 0x3f | 0x80;\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      } else {\n        buf[pos++] = c1 >> 12 | 0xe0;\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      }\n    }\n  }\n};\n\n/* istanbul ignore else */\nif (typeof Buffer.prototype.latin1Write == 'function') {\n  // `binaryWrite` has been renamed to `latin1Write` in Node v6.4.0, see\n  // https://github.com/nodejs/node/pull/7111. Note that the `'binary'`\n  // encoding argument still works however.\n  Tap.prototype.writeBinary = function (str, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.latin1Write(str, pos, len);\n  };\n} else if (typeof Buffer.prototype.binaryWrite == 'function') {\n  Tap.prototype.writeBinary = function (str, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.binaryWrite(str, pos, len);\n  };\n} else {\n  // Slowest implementation.\n  Tap.prototype.writeBinary = function (s, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.write(s, pos, len, 'binary');\n  };\n}\n\n// Binary comparison methods.\n//\n// These are not guaranteed to consume the objects they are comparing when\n// returning a non-zero result (allowing for performance benefits), so no other\n// operations should be done on either tap after a compare returns a non-zero\n// value. Also, these methods do not have the same silent failure requirement\n// as read, skip, and write since they are assumed to be called on valid\n// buffers.\n\nTap.prototype.matchBoolean = function (tap) {\n  return this.buf[this.pos++] - tap.buf[tap.pos++];\n};\n\nTap.prototype.matchInt = Tap.prototype.matchLong = function (tap) {\n  var n1 = this.readLong();\n  var n2 = tap.readLong();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchFloat = function (tap) {\n  var n1 = this.readFloat();\n  var n2 = tap.readFloat();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchDouble = function (tap) {\n  var n1 = this.readDouble();\n  var n2 = tap.readDouble();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchFixed = function (tap, len) {\n  return this.readFixed(len).compare(tap.readFixed(len));\n};\n\nTap.prototype.matchBytes = Tap.prototype.matchString = function (tap) {\n  var l1 = this.readLong();\n  var p1 = this.pos;\n  this.pos += l1;\n  var l2 = tap.readLong();\n  var p2 = tap.pos;\n  tap.pos += l2;\n  var b1 = this.buf.slice(p1, this.pos);\n  var b2 = tap.buf.slice(p2, tap.pos);\n  return b1.compare(b2);\n};\n\n// Functions for supporting custom long classes.\n//\n// The two following methods allow the long implementations to not have to\n// worry about Avro's zigzag encoding, we directly expose longs as unpacked.\n\nTap.prototype.unpackLongBytes = function () {\n  var res = newBuffer(8);\n  var n = 0;\n  var i = 0; // Byte index in target buffer.\n  var j = 6; // Bit offset in current target buffer byte.\n  var buf = this.buf;\n  var b, neg;\n\n  b = buf[this.pos++];\n  neg = b & 1;\n  res.fill(0);\n\n  n |= (b & 0x7f) >> 1;\n  while (b & 0x80) {\n    b = buf[this.pos++];\n    n |= (b & 0x7f) << j;\n    j += 7;\n    if (j >= 8) {\n      // Flush byte.\n      j -= 8;\n      res[i++] = n;\n      n >>= 8;\n    }\n  }\n  res[i] = n;\n\n  if (neg) {\n    invert(res, 8);\n  }\n\n  return res;\n};\n\nTap.prototype.packLongBytes = function (buf) {\n  var neg = (buf[7] & 0x80) >> 7;\n  var res = this.buf;\n  var j = 1;\n  var k = 0;\n  var m = 3;\n  var n;\n\n  if (neg) {\n    invert(buf, 8);\n    n = 1;\n  } else {\n    n = 0;\n  }\n\n  var parts = [\n    buf.readUIntLE(0, 3),\n    buf.readUIntLE(3, 3),\n    buf.readUIntLE(6, 2)\n  ];\n  // Not reading more than 24 bits because we need to be able to combine the\n  // \"carry\" bits from the previous part and JavaScript only supports bitwise\n  // operations on 32 bit integers.\n  while (m && !parts[--m]) {} // Skip trailing 0s.\n\n  // Leading parts (if any), we never bail early here since we need the\n  // continuation bit to be set.\n  while (k < m) {\n    n |= parts[k++] << j;\n    j += 24;\n    while (j > 7) {\n      res[this.pos++] = (n & 0x7f) | 0x80;\n      n >>= 7;\n      j -= 7;\n    }\n  }\n\n  // Final part, similar to normal packing aside from the initial offset.\n  n |= parts[m] << j;\n  do {\n    res[this.pos] = n & 0x7f;\n    n >>= 7;\n  } while (n && (res[this.pos++] |= 0x80));\n  this.pos++;\n\n  // Restore original buffer (could make this optional?).\n  if (neg) {\n    invert(buf, 8);\n  }\n};\n\n// Helpers.\n\n/**\n * Invert all bits in a buffer.\n *\n * @param buf {Buffer} Non-empty buffer to invert.\n * @param len {Number} Buffer length (must be positive).\n */\nfunction invert(buf, len) {\n  while (len--) {\n    buf[len] = ~buf[len];\n  }\n}\n\n\nmodule.exports = {\n  abstractFunction: abstractFunction,\n  addDeprecatedGetters: addDeprecatedGetters,\n  bufferFrom: bufferFrom,\n  capitalize: capitalize,\n  copyOwnProperties: copyOwnProperties,\n  getHash: getHash,\n  compare: compare,\n  getOption: getOption,\n  impliedNamespace: impliedNamespace,\n  isValidName: isValidName,\n  jsonEnd: jsonEnd,\n  newBuffer: newBuffer,\n  objectValues: objectValues,\n  qualify: qualify,\n  toMap: toMap,\n  singleIndexOf: singleIndexOf,\n  hasDuplicates: hasDuplicates,\n  unqualify: unqualify,\n  BufferPool: BufferPool,\n  Lcg: Lcg,\n  OrderedQueue: OrderedQueue,\n  Tap: Tap\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/utils.js?");

/***/ }),

/***/ "./node_modules/bufferutil/fallback.js":
/*!*********************************************!*\
  !*** ./node_modules/bufferutil/fallback.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nconst mask = (source, mask, output, offset, length) => {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n};\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nconst unmask = (buffer, mask) => {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n};\n\nmodule.exports = { mask, unmask };\n\n\n//# sourceURL=webpack://js-kart/./node_modules/bufferutil/fallback.js?");

/***/ }),

/***/ "./node_modules/bufferutil/index.js":
/*!******************************************!*\
  !*** ./node_modules/bufferutil/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\ntry {\n  module.exports = __webpack_require__(/*! node-gyp-build */ \"./node_modules/node-gyp-build/index.js\")(__dirname);\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./fallback */ \"./node_modules/bufferutil/fallback.js\");\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/bufferutil/index.js?");

/***/ }),

/***/ "./node_modules/node-gyp-build/index.js":
/*!**********************************************!*\
  !*** ./node_modules/node-gyp-build/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar os = __webpack_require__(/*! os */ \"os\")\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire =  true ? require : 0 // eslint-disable-line\n\nvar vars = (process.config && process.config.variables) || {}\nvar prebuildsOnly = !!process.env.PREBUILDS_ONLY\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : (isNwjs() ? 'node-webkit' : 'node')\n\nvar arch = process.env.npm_config_arch || os.arch()\nvar platform = process.env.npm_config_platform || os.platform()\nvar libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')\nvar armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''\nvar uv = (process.versions.uv || '').split('.')[0]\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.path(dir))\n}\n\nload.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  if (!prebuildsOnly) {\n    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n    if (release) return release\n\n    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n    if (debug) return debug\n  }\n\n  var prebuild = resolve(dir)\n  if (prebuild) return prebuild\n\n  var nearby = resolve(path.dirname(process.execPath))\n  if (nearby) return nearby\n\n  var target = [\n    'platform=' + platform,\n    'arch=' + arch,\n    'runtime=' + runtime,\n    'abi=' + abi,\n    'uv=' + uv,\n    armv ? 'armv=' + armv : '',\n    'libc=' + libc,\n    'node=' + process.versions.node,\n    process.versions.electron ? 'electron=' + process.versions.electron : '',\n     true ? 'webpack=true' : 0 // eslint-disable-line\n  ].filter(Boolean).join(' ')\n\n  throw new Error('No native build was found for ' + target + '\\n    loaded from: ' + dir + '\\n')\n\n  function resolve (dir) {\n    // Find matching \"prebuilds/<platform>-<arch>\" directory\n    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)\n    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]\n    if (!tuple) return\n\n    // Find most specific flavor first\n    var prebuilds = path.join(dir, 'prebuilds', tuple.name)\n    var parsed = readdirSync(prebuilds).map(parseTags)\n    var candidates = parsed.filter(matchTags(runtime, abi))\n    var winner = candidates.sort(compareTags(runtime))[0]\n    if (winner) return path.join(prebuilds, winner.file)\n  }\n}\n\nfunction readdirSync (dir) {\n  try {\n    return fs.readdirSync(dir)\n  } catch (err) {\n    return []\n  }\n}\n\nfunction getFirst (dir, filter) {\n  var files = readdirSync(dir).filter(filter)\n  return files[0] && path.join(dir, files[0])\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction parseTuple (name) {\n  // Example: darwin-x64+arm64\n  var arr = name.split('-')\n  if (arr.length !== 2) return\n\n  var platform = arr[0]\n  var architectures = arr[1].split('+')\n\n  if (!platform) return\n  if (!architectures.length) return\n  if (!architectures.every(Boolean)) return\n\n  return { name, platform, architectures }\n}\n\nfunction matchTuple (platform, arch) {\n  return function (tuple) {\n    if (tuple == null) return false\n    if (tuple.platform !== platform) return false\n    return tuple.architectures.includes(arch)\n  }\n}\n\nfunction compareTuples (a, b) {\n  // Prefer single-arch prebuilds over multi-arch\n  return a.architectures.length - b.architectures.length\n}\n\nfunction parseTags (file) {\n  var arr = file.split('.')\n  var extension = arr.pop()\n  var tags = { file: file, specificity: 0 }\n\n  if (extension !== 'node') return\n\n  for (var i = 0; i < arr.length; i++) {\n    var tag = arr[i]\n\n    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {\n      tags.runtime = tag\n    } else if (tag === 'napi') {\n      tags.napi = true\n    } else if (tag.slice(0, 3) === 'abi') {\n      tags.abi = tag.slice(3)\n    } else if (tag.slice(0, 2) === 'uv') {\n      tags.uv = tag.slice(2)\n    } else if (tag.slice(0, 4) === 'armv') {\n      tags.armv = tag.slice(4)\n    } else if (tag === 'glibc' || tag === 'musl') {\n      tags.libc = tag\n    } else {\n      continue\n    }\n\n    tags.specificity++\n  }\n\n  return tags\n}\n\nfunction matchTags (runtime, abi) {\n  return function (tags) {\n    if (tags == null) return false\n    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false\n    if (tags.abi !== abi && !tags.napi) return false\n    if (tags.uv && tags.uv !== uv) return false\n    if (tags.armv && tags.armv !== armv) return false\n    if (tags.libc && tags.libc !== libc) return false\n\n    return true\n  }\n}\n\nfunction runtimeAgnostic (tags) {\n  return tags.runtime === 'node' && tags.napi\n}\n\nfunction compareTags (runtime) {\n  // Precedence: non-agnostic runtime, abi over napi, then by specificity.\n  return function (a, b) {\n    if (a.runtime !== b.runtime) {\n      return a.runtime === runtime ? -1 : 1\n    } else if (a.abi !== b.abi) {\n      return a.abi ? -1 : 1\n    } else if (a.specificity !== b.specificity) {\n      return a.specificity > b.specificity ? -1 : 1\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction isNwjs () {\n  return !!(process.versions && process.versions.nw)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\nfunction isAlpine (platform) {\n  return platform === 'linux' && fs.existsSync('/etc/alpine-release')\n}\n\n// Exposed for unit tests\n// TODO: move to lib\nload.parseTags = parseTags\nload.matchTags = matchTags\nload.compareTags = compareTags\nload.parseTuple = parseTuple\nload.matchTuple = matchTuple\nload.compareTuples = compareTuples\n\n\n//# sourceURL=webpack://js-kart/./node_modules/node-gyp-build/index.js?");

/***/ }),

/***/ "./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"./node_modules/ws/lib/websocket.js\");\n\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"./node_modules/ws/lib/stream.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"./node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"./node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"./node_modules/ws/lib/sender.js\");\n\nWebSocket.WebSocket = WebSocket;\nWebSocket.WebSocketServer = WebSocket.Server;\n\nmodule.exports = WebSocket;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/index.js?");

/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) return target.slice(0, offset);\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"./node_modules/bufferutil/index.js\");\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/buffer-util.js?");

/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/constants.js?");

/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener, options = {}) {\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = listener;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/event-target.js?");

/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/extension.js?");

/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/limiter.js?");

/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"./node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/permessage-deflate.js?");

/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(\n              RangeError,\n              'Max payload size exceeded',\n              false,\n              1009,\n              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n            )\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n        }\n\n        this.emit('message', buf, false);\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else if (data.length === 1) {\n        return error(\n          RangeError,\n          'invalid payload length 1',\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n        }\n\n        const buf = data.slice(2);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n        }\n\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @param {String} errorCode The exposed error code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode] = statusCode;\n  return err;\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/receiver.js?");

/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n\n\n\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        randomFillSync(mask, 0, 4);\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/sender.js?");

/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/stream.js?");

/***/ }),

/***/ "./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/subprotocol.js?");

/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = {\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?bb17\");\n\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/validation.js?");

/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst extension = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"./node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"./node_modules/ws/lib/websocket.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!key || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/websocket-server.js?");

/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"./node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"./node_modules/ws/lib/sender.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = __webpack_require__(/*! ./event-target */ \"./node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    this._sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n\n    websocket._url = address;\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n  let invalidURLMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {\n    invalidURLMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"';\n  } else if (isUnixSocket && !parsedUrl.pathname) {\n    invalidURLMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidURLMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidURLMessage) {\n    const err = new SyntaxError(invalidURLMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalUnixSocket = isUnixSocket;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isUnixSocket\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isUnixSocket\n        ? websocket._originalUnixSocket\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalUnixSocket\n        ? false\n        : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    if (res.headers.upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  req.end();\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/websocket.js?");

/***/ }),

/***/ "./src/server/game.js":
/*!****************************!*\
  !*** ./src/server/game.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Track = __webpack_require__(/*! ../shared_modules/trackGenerator */ \"./src/shared_modules/trackGenerator.js\");\nconst Car = __webpack_require__(/*! ../shared_modules/car */ \"./src/shared_modules/car.js\");\nconst util = __webpack_require__(/*! ../shared_modules/util */ \"./src/shared_modules/util.js\");\nconst PhysX = __webpack_require__(/*! ../shared_modules/physx */ \"./src/shared_modules/physx.js\");\nconst Vec2D = PhysX.Vec2D;\nconst PhysObject = PhysX.PhysObject;\nconst PhysEnv = PhysX.PhysEnv;\n\nconst wall = {\n    density: Infinity,\n    restitution: .5,\n    sFriction: .24,\n    dFriction: .16,\n};\n\nconst cp_material = {\n    density: 0,\n    restitution: 0,\n    sFriction: 0,\n    dFriction: 0,\n};\n\nconst cw = util.CANVAS_WIDTH;\nconst ch = util.CANVAS_HEIGHT;\n\nconst lobby_walls = [\n    [new Vec2D(-cw / 2 + 5,  -ch / 2 + 5),\n     new Vec2D(-cw / 2 + 30, -ch / 2 + 30),\n     new Vec2D( cw / 2 - 30, -ch / 2 + 30),\n     new Vec2D( cw / 2 - 5,  -ch / 2 + 5),],\n\n    [new Vec2D(-cw / 2 + 5,   ch / 2 - 5),\n     new Vec2D(-cw / 2 + 30,  ch / 2 - 30),\n     new Vec2D(-cw / 2 + 30, -ch / 2 + 30),\n     new Vec2D(-cw / 2 + 5,  -ch / 2 + 5),],\n\n    [new Vec2D( cw / 2 - 5,  ch / 2 - 5),\n     new Vec2D( cw / 2 - 30, ch / 2 - 30),\n     new Vec2D(-cw / 2 + 30, ch / 2 - 30),\n     new Vec2D(-cw / 2 + 5,  ch / 2 - 5),],\n\n    [new Vec2D(cw / 2 - 5,  -ch / 2 + 5),\n     new Vec2D(cw / 2 - 30, -ch / 2 + 30),\n     new Vec2D(cw / 2 - 30,  ch / 2 - 30),\n     new Vec2D(cw / 2 - 5,   ch / 2 - 5),],\n]\n\nclass Game {\n    constructor() {\n        this.scene = \"lobby\";\n        this.tick = Math.floor(util.getTime() / 16);\n        this.numPlayers = 0;\n\n        this.env = new PhysEnv();\n\n        this.cars = {};\n        this.track = null;\n        this.walls = [];\n        this.place = 1;\n        this.freezeTime = 0;\n\n        this.initLobby();\n    }\n\n    reset() {\n        this.env.clearObjects();\n        this.track = null;\n        this.walls = [];\n    }\n\n    initLobby() {\n        this.scene = \"lobby\";\n\n        let carArr = Object.entries(this.cars);\n        carArr.sort((a, b) => { return b[1].lap - a[1].lap });\n\n        for(const [id, car] of carArr) {\n            const int_id = parseInt(id);\n\n            car.pos = new Vec2D(0, ch * .6 / (util.MAX_PLAYERS + 1) * (int_id + 1) - ch * .3);\n            car.vel.x = car.vel.y = car.rotVel = car.angle = 0;\n            car.ready = false;\n\n            this.env.addObject(car);\n        }\n\n        let wallPoints = lobby_walls;\n        this.walls = [[]];\n\n        for(const points of wallPoints) {\n            let pos = new Vec2D(0, 0);\n            let new_pts = [];\n\n            for(let point of points) {\n                pos.add(point);\n                new_pts.push(new Vec2D(point.x, point.y));\n            }\n    \n            pos = pos.div(points.length);\n    \n            let obj = new PhysObject(pos, new_pts, wall);\n            this.env.addObject(obj);\n\n            this.walls[0].push(obj);\n        }\n    }\n\n    initRace() {\n        this.scene = \"race\";\n        this.place = 1;\n        this.freezeTime = 5;\n\n        this.env.clearObjects();\n        this.track = new Track(new Vec2D(0, 0));\n        Track.genMesh(this.track);\n\n        const scale = 15;\n        this.walls = [[], []];\n        this.createWalls(scale);\n        this.createCheckpoints();\n\n        let id = 0;\n\n        for(const car of Object.values(this.cars)) {\n            car.ready = false;\n            car.lap = 0;\n            car.lastCheckpoint = 0;\n\n            let dx = ((this.numPlayers-1)/2 - id) * 50 * Math.sin(this.track.spawn.d);\n            let dy = ((this.numPlayers-1)/2 - id) * 50 * -Math.cos(this.track.spawn.d);\n\n            car.pos.x = this.track.spawn.x * scale + dx;\n            car.pos.y = this.track.spawn.y * scale + dy;\n            car.angle = this.track.spawn.d;\n\n            car.vel.x = car.vel.y = car.rotVel = 0;\n\n            this.env.addObject(car);\n\n            id++;\n        }\n\n    }\n\n    createCheckpoints() {\n        for(let curr = 0; curr < this.walls[0].length; curr++) {\n            const next = (curr + 1) % this.walls[0].length;\n            \n\n            let points = [this.walls[1][next].points[2].mult(1),\n                          this.walls[1][curr].points[2].mult(1),\n                          this.walls[0][curr].points[3].mult(1),\n                          this.walls[0][next].points[3].mult(1)]; \n\n            let pos = new Vec2D(0, 0);\n\n            for(let point of points) {\n                pos.add(point);\n            }\n    \n            pos = pos.div(points.length);\n    \n            let cp = new PhysObject(pos, points, cp_material);\n\n            cp.id = (curr + 2 + this.walls[0].length) % this.walls[0].length;\n            cp.func = (A, B) => {\n                if(B instanceof Car) {\n                    if(Math.abs(A.id - B.lastCheckpoint) == 1)\n                        B.lastCheckpoint = A.id;\n\n                    if(A.id == 0 && B.lastCheckpoint > 5) {\n                        B.lastCheckpoint = 0;\n                        B.lap++;\n\n                        if(B.lap >= util.NUM_LAPS) {\n                            B.lap = -1;\n                            B.ready = true;\n                        }\n                    }\n                }\n            };\n    \n            this.env.addObject(cp);\n        }\n    }\n\n    createWalls(scale) {\n        let wallArr = [...this.track.innerWall, ...this.track.outerWall];\n\n        for(const [idx, pts] of wallArr.entries()) {\n\n            let pos = new Vec2D(0, 0);\n            let objPts = [];\n                \n            for(let [i, point] of pts.entries()) {\n                objPts[i] = point.mult(scale);\n                pos.add(objPts[i]);\n            }\n\n            pos.x /= pts.length;\n            pos.y /= pts.length;\n            \n            let obj = new PhysObject(pos, objPts, wall);\n\n            const wall_idx = Math.floor(idx * 2 / wallArr.length);\n\n            this.env.addObject(obj);\n            this.walls[wall_idx].push(obj);\n        }\n    }\n\n    createCar(id) {\n        const pos = new Vec2D(0, ch * .6 / (util.MAX_PLAYERS + 1) * (id + 1) - ch * .3);\n        const hue = 360 / util.MAX_PLAYERS * id;\n        const car = new Car(pos, hue);\n\n        this.env.addObject(car);\n        this.cars[id] = car;\n        this.numPlayers++;\n\n        return car;\n    }\n\n    removeCar(id) {\n        this.env.removeObject(this.cars[id]);\n        \n        delete this.cars[id];\n        this.numPlayers--;\n    }\n\n    addPacket(packets, event, data = null) {\n        switch(event) {\n            case 'id':\n                packets.id = data;\n                break;\n            case 'dynamic':\n                packets.dynamic = {\n                    cars: this.cars,\n                };\n                break;\n            case 'static':\n                packets.static = {\n                    scene: this.scene,\n                    walls: this.walls,\n                };\n                break;\n            default:\n        }\n    }\n\n    lobbyUpdate(packets) {\n        let ready = true;\n    \n        for(const car of Object.values(this.cars)) {\n            if(!car.ready) {\n                ready = false;\n            }\n        }\n\n        this.addPacket(packets, 'dynamic');\n    \n        if(ready && this.numPlayers > 0) {\n            this.reset();\n            this.initRace();\n            packets[2] = this.addPacket(packets, 'static');\n        }\n\n        return packets;\n    }\n\n    raceUpdate(packets) {\n        let ready = true;\n        for(const car of Object.values(this.cars)) {\n            if(!car.ready) {\n                ready = false;\n            } else if(car.lap == -1) {\n                car.lap = this.place;\n                this.place++;\n                car.inputs.up = car.inputs.down = car.inputs.right = car.inputs.left = false;\n            }\n        }\n\n        this.addPacket(packets, 'dynamic');\n\n        if(this.numPlayers == 0 || ready) {\n            this.reset();\n            this.initLobby();\n            this.addPacket(packets, 'static');\n        }\n\n        return packets;\n    }\n\n    update(dt) {\n        let bundle = {\n            packets: {\n                id: null,\n                dynamic: null,\n                static: null,\n            },\n            tick: this.tick, \n        };\n\n        if(this.scene == \"lobby\") {\n            this.lobbyUpdate(bundle.packets);\n        } else {\n            this.raceUpdate(bundle.packets);\n        }\n\n        return bundle;\n    }\n\n    simulate(dt) {\n        if(this.freezeTime > 0) {\n            this.freezeTime -= dt;\n            return;\n        }\n\n        for(const car of Object.values(this.cars))\n            car.controlPlayer(dt);\n\n        this.env.update(dt);\n    }\n}\n\nmodule.exports = Game;\n\n//# sourceURL=webpack://js-kart/./src/server/game.js?");

/***/ }),

/***/ "./src/server/server.js":
/*!******************************!*\
  !*** ./src/server/server.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const avsc = __webpack_require__(/*! ../shared_modules/serialize */ \"./src/shared_modules/serialize.js\")\nconst util = __webpack_require__(/*! ../shared_modules/util */ \"./src/shared_modules/util.js\");\nconst Game = __webpack_require__(/*! ./game */ \"./src/server/game.js\");\nconst WebSocket = __webpack_require__(/*! ws */ \"./node_modules/ws/index.js\");\n\nlet game = new Game();\n\nconst PORT = process.env.PORT || 8181;\nwss = new WebSocket.Server({ port: PORT });\nconsole.log(\"Server started on port: \" + PORT);\n\nwss.on(\"connection\", socket => {\n    processConnection(socket);\n\n    socket.on(\"message\", processMessage);\n    socket.on(\"close\", processClose);\n});\n\nfunction processConnection(socket) {\n    const num_spectators = wss.clients.size - game.numPlayers - 1;\n    const isSpectator = game.scene == \"race\" || num_spectators > 0;\n    let id;\n\n    if(isSpectator) {\n        id = util.min_missing_id(wss.clients, util.MAX_PLAYERS, game.numPlayers); \n    } else {\n        id = util.min_missing_id(wss.clients); \n    }\n\n    addPlayer(socket, id);\n\n    console.log(`New client connected: ID - ${id}`);\n}\n\nfunction updateLatency(socket, packet) {\n    const BUFFER_SIZE = 10;\n\n    // offset measured as \"how far the client is ahead of the server\"\n    const curTime = util.getTime();\n    const latency = (curTime - packet.sTimestamp) / 2;\n    const clockOffset = curTime - (packet.cTimestamp + latency);\n\n    socket.pingBuffer.push(latency);\n    socket.offsetBuffer.push(clockOffset);\n\n    if(socket.pingBuffer.length > BUFFER_SIZE)\n        socket.pingBuffer.splice(0, 1);\n\n    if(socket.offsetBuffer.length > BUFFER_SIZE)\n        socket.offsetBuffer.splice(0, 1);\n\n    socket.latency = 0;\n    socket.pingBuffer.forEach(val => socket.latency += val);\n    socket.latency /= socket.pingBuffer.length;\n\n    socket.clockOffset = 0;\n    socket.offsetBuffer.forEach(val => socket.clockOffset += val);\n    socket.clockOffset /= socket.offsetBuffer.length;\n}\n\nasync function processMessage(buffer) {\n    let message = await avsc.decode(buffer);\n    \n    if(message.packets.ping) {\n        updateLatency(this, message.packets.ping);\n    } else if(message.packets.inputs) {\n        // ensure all late inputs are still processed\n        if(game.tick >= message.tick)\n            message.tick = game.tick + 1;\n\n        util.setBuffer(this.inputBuffer, message.tick, message);\n    }\n}\n\nfunction handleInputs(socket, inputs) {\n    if(socket.id < util.MAX_PLAYERS && !(game.scene == \"race\" && socket.car.ready)) {\n        socket.car.inputs = inputs;\n    }\n\n    if(game.scene == \"lobby\" && inputs.enter) {\n        if(socket.id < util.MAX_PLAYERS) {\n            socket.car.ready = !socket.car.ready;\n        } else {\n            const id = util.min_missing_id(wss.clients);\n            \n            if(id < util.MAX_PLAYERS) {\n                console.log(`Client ${socket.id} changed ID to ${id}`);\n                addPlayer(socket, id);\n            }\n        }\n    }\n}\n\nfunction processClose() {\n    console.log(`Client disconnected: ID - ${this.id}`);\n\n    if(this.id < util.MAX_PLAYERS) {\n        game.removeCar(this.id);\n    }\n}\n\nfunction broadcast(data, pingFlag) {\n    let buffer;\n\n    if(pingFlag) {\n        data.packets.ping = {\n            sTimestamp: util.getTime(),\n            cTimestamp: null,\n            clockOffset: null,\n            latency: null,\n        };\n    } else {\n        buffer = avsc.encode(data);  \n    }\n\n    for(const client of wss.clients) {\n        if(pingFlag) {\n            data.packets.ping.latency = client.latency;\n            data.packets.ping.clockOffset = client.clockOffset;\n            buffer = avsc.encode(data);\n        }\n\n        client.send(buffer);\n    }\n}\n\nfunction addPlayer(socket, id) {\n    socket.id = id;\n    socket.car = null;\n    socket.inputBuffer = [];\n\n    socket.latency = 100;\n    socket.pingBuffer = [100];\n    socket.clockOffset = 0;\n    socket.offsetBuffer = [0];\n\n    if(id < util.MAX_PLAYERS)\n        socket.car = game.createCar(id);\n\n    let bundle = {\n        packets: {},\n        tick: game.tick,\n    };\n\n    game.addPacket(bundle.packets, 'id', id);\n    game.addPacket(bundle.packets, 'dynamic');\n    game.addPacket(bundle.packets, 'static');\n\n    socket.send(avsc.encode(bundle));\n}\n\nlet pingTimer = 0;\nvar timer = new util.interval(16, () => { \n    const curTick = Math.floor(util.getTime() / 16);\n    // const loopTime = util.getTime() - timer.baseline;\n    const dt = .016;\n\n    while(game.tick < curTick) {\n        for(const socket of wss.clients) {\n            let message = util.getBuffer(socket.inputBuffer, game.tick);\n\n            if(message && message.tick == game.tick) {\n                handleInputs(socket, message.packets.inputs);\n            }\n        }\n\n        let bundle = game.update(dt);\n\n        pingTimer += dt;\n        const pingFlag = pingTimer > .1;\n\n        if(pingTimer > .1)\n            pingTimer = 0;\n\n        broadcast(bundle, pingFlag);\n        \n        game.simulate(dt);\n\n        game.tick++;\n    }\n});\n\ngame.tick = Math.floor(util.getTime() / 16);\ntimer.run();\n\n//# sourceURL=webpack://js-kart/./src/server/server.js?");

/***/ }),

/***/ "./src/shared_modules/car.js":
/*!***********************************!*\
  !*** ./src/shared_modules/car.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const PhysX = __webpack_require__(/*! ./physx */ \"./src/shared_modules/physx.js\");\nconst Vec2D = PhysX.Vec2D;\nconst PhysObject = PhysX.PhysObject;\n\nclass Car extends PhysObject {\n    static POINTS = [new Vec2D(0, 1),\n        new Vec2D(0, 19),\n        new Vec2D(12, 22),\n        new Vec2D(40, 19),\n        new Vec2D(40, 1),\n        new Vec2D(12, -2),];\n\n    constructor(pos, hue, material = null) {\n\n        if(!material) {\n            material = {\n                density: 2.5,\n                restitution: .35,\n                sFriction: .06,\n                dFriction: .04,\n            };\n        }\n\n        super(pos, Car.POINTS, material);\n        this.moi *= 10;\n\n        this.inputs = {\n            left: false,\n            right: false,\n            up: false,\n            down: false,\n            shift: false,\n            enter: false,\n        }\n\n        this.ready = false;\n        this.hue = hue;\n        this.lap = -1;\n        this.lastCheckpoint = 0;\n    }\n\n    controlPlayer(dt) {\n        const speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);\n        const maxSpeed = 1000;\n        const isDrifting = false;\n\n        const accFactor = 600 * dt;\n        const maxRotFactor = 2.5;\n        const maxRot = maxRotFactor * Math.min(speed / 100, 1)\n        const rotFactor = 14 * dt;\n        const driftFactor = isDrifting ? .96 : .8;\n        \n        const dx = Math.cos(this.angle);\n        const dy = Math.sin(this.angle);\n\n        const dir = new Vec2D(dx, dy);\n        const orth = new Vec2D(-dy, dx);\n\n        const fwdSpeed = dir.dot(this.vel);\n        const fwdVel = dir.mult(fwdSpeed);\n\n        const orthSpeed = orth.dot(this.vel);\n        const orthVel = orth.mult(orthSpeed * driftFactor);\n\n        this.vel = fwdVel.addRet(orthVel);\n\n        if(this.inputs.up && !this.inputs.down && fwdSpeed < maxSpeed) {\n            const dx = Math.cos(this.angle) * accFactor;\n            const dy = Math.sin(this.angle) * accFactor;\n    \n            this.vel.add(new Vec2D(dx, dy));\n        } else if(this.inputs.down && !this.inputs.up && fwdSpeed > -maxSpeed / 2) {\n            const dx = Math.cos(this.angle) * accFactor;\n            const dy = Math.sin(this.angle) * accFactor;\n    \n            this.vel.sub(new Vec2D(dx, dy));\n        } else {\n            this.vel.x *= isDrifting ? .999 : .99;\n            this.vel.y *= isDrifting ? .999 : .99;\n        }\n    \n        const turningLeft = this.inputs.left && !this.inputs.right; \n        const turningRight = !this.inputs.left && this.inputs.right;\n\n        if((turningLeft && fwdSpeed > 0) || (turningRight && fwdSpeed < 0)) {\n            if(this.rotVel > 0) this.rotVel = 0;\n            if(this.rotVel < -maxRot) this.rotVel = -maxRot;\n\n            this.rotVel -= rotFactor;\n        } else if((turningRight && fwdSpeed > 0) || (turningLeft && fwdSpeed < 0)) {\n            if(this.rotVel < 0) this.rotVel = 0;\n            if(this.rotVel > maxRot) this.rotVel = maxRot;\n\n            this.rotVel += rotFactor;\n        } else {\n            this.rotVel *= .92;\n        }\n    }\n}\n\nmodule.exports = Car;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/car.js?");

/***/ }),

/***/ "./src/shared_modules/physx.js":
/*!*************************************!*\
  !*** ./src/shared_modules/physx.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("function clip(v1, v2, n, o) {\n    let points = [];\n    const d1 = n.dot(v1) - o;\n    const d2 = n.dot(v2) - o;\n\n    if(d1 >= 0) points.push(v1);\n\n    if(d2 >= 0) points.push(v2);\n\n    if(d1 * d2 < 0) {\n        let e = Vec2D.dif(v1, v2);\n        const u = d1 / (d1 - d2);\n        e = e.mult(u);\n        e.add(v1);\n\n        points.push(e);\n    }\n\n    return points;\n}\n\nfunction debugLine(p1, p2, ctx, color = \"red\") {\n    ctx.strokeStyle = color;\n    ctx.beginPath()\n    ctx.moveTo(p1.x, p1.y);\n    ctx.lineTo(p2.x, p2.y);\n    ctx.stroke();\n}\n\nfunction insertionSort(arr, lambda = (x) => x) {\n    let val, j, i;\n    for(i = 1; i < arr.length; i++) {\n        val = arr[i];\n        j = i - 1;\n\n        while(j >= 0 && lambda(arr[j]) > lambda(val)) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = val;\n    }\n}\n\nfunction polygonSupport(points, d) {\n    let furthest = null;\n    let dot = -Infinity;\n\n    for(const point of points) {\n        const proj = point.dot(d);\n        if(proj > dot) {\n            furthest = point;\n            dot = proj;\n        }\n    }\n\n    return furthest;\n}\n\nfunction minkowskiDifSupport(s1, s2, d) {\n    return Vec2D.dif(polygonSupport(s2.points, d.mult(-1)), polygonSupport(s1.points, d));\n}\n\nfunction mean(arr) {\n    let sum = 0;\n    for(const el of arr) {\n        sum += el;\n    }\n    return sum / arr.length;\n}\n\nfunction variance(arr) {\n    let variance = 0;\n    const mean = mean(arr);\n    for(const el of arr) {\n        const dif = el - mean;\n        variance += dif * dif;\n    }\n    return variance / arr.length;\n}\n\nfunction calculateMassAndMoi(obj) {\n    if(obj.material.density == Infinity)\n        return [Infinity, Infinity];\n\n    let mass = 0;\n    // let center = new Vec2D(0, 0);\n    let moi = 0;\n\n    let prev = obj.shape.length - 1;\n    for(let cur = 0; cur < obj.shape.length; cur++) {\n        const a = obj.shape[prev];\n        const b = obj.shape[cur];\n\n        const areaStep = Math.abs(Vec2D.cross(a, b) / 2);\n        const massStep = areaStep * obj.material.density;\n        // const centerStep = a.addRet(b).div(3);\n        const moiStep = massStep / 6 * (a.dot(a) + b.dot(b) + a.dot(b));\n\n        mass += massStep\n        // center.add(centerStep);\n        moi += moiStep;\n    }\n\n    return [mass, moi];\n}\n\nconst wood = {\n    density: 1,\n    restitution: .45,\n    sFriction: .3,\n    dFriction: .2,\n};\n\nconst rubber = {\n    density: 2.5,\n    restitution: .95,\n    sFriction: .6,\n    dFriction: .4,\n};\n\nconst wall = {\n    density: Infinity,\n    restitution: .5,\n    sFriction: .24,\n    dFriction: .16,\n};\n\nclass Vec2D {\n    static rotate(pivot, point, rad) {\n        const dx = (point.x - pivot.x);\n        const dy = (point.y - pivot.y);\n\n        const sin = Math.sin(rad);\n        const cos = Math.cos(rad);\n\n        const nx = dx * cos - dy * sin; \n        const ny = dx * sin + dy * cos;\n\n        return new Vec2D(nx, ny);\n    }\n\n    static mag(vec) {\n        return Math.sqrt(vec.x * vec.x + vec.y * vec.y);\n    }\n    \n    static distance(v1, v2) {\n        return Vec2D.mag(Vec2D.dif(v1, v2));\n    }\n\n    static normalize(vec) {\n        if(vec.x == 0 && vec.y == 0) return new Vec2D(0, 0);\n        const mag = Vec2D.mag(vec);\n        return new Vec2D(vec.x / mag, vec.y / mag);\n    }\n\n    static dif(v1, v2) {\n        return new Vec2D(v2.x - v1.x, v2.y - v1.y);\n    }\n\n    static tripleProd(v1, v2, v3) {\n        const k = v1.x * v2.y - v1.y * v2.x;\n        const nx = -v3.y * k;\n        const ny = v3.x * k;\n        return new Vec2D(nx, ny, 0);\n    }\n\n    static cross(A, B) {\n        if(A.x == undefined) {\n            // scalar x vector\n            return new Vec2D(-A * B.y, A * B.x);\n        } else if(B.x == undefined) {\n            // vector x scalar\n            return new Vec2D(B * A.y, -B * A.x);\n        } else {\n            // vector x vector\n            return A.x * B.y - A.y * B.x;\n        }\n    }\n\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    add(other) {\n        this.x += other.x;\n        this.y += other.y;\n    }\n\n    sub(other) {\n        this.x -= other.x;\n        this.y -= other.y;\n    }\n\n    scale(num) {\n        this.x *= num;\n        this.y *= num;\n    }\n    \n    addRet(other) {\n        return new Vec2D(this.x + other.x, this.y + other.y);\n    }\n\n    subRet(other) {\n        return new Vec2D(this.x - other.x, this.y - other.y);\n    }\n\n    mult(num) {\n        return new Vec2D(this.x * num, this.y * num);\n    }\n\n    div(num) {\n        return new Vec2D(this.x / num, this.y / num);\n    }\n\n    dot(other) {\n        return this.x * other.x + this.y * other.y;\n    }\n}\n\nclass AABB {\n\n    static findAABB(obj) {\n        let b = new Vec2D(Infinity, Infinity);\n        let e = new Vec2D(-Infinity, -Infinity);\n\n        for(const point of obj.points) {\n            b.x = Math.min(point.x, b.x);\n            b.y = Math.min(point.y, b.y);\n\n            e.x = Math.max(point.x, e.x);\n            e.y = Math.max(point.y, e.y);\n        }\n\n        return new AABB(b, e);\n    }\n\n    constructor(b, e) {\n        this.b = b;\n        this.e = e;\n    }\n\n    update(obj) {\n        this.b.add(new Vec2D(Infinity, Infinity));\n        this.e.add(new Vec2D(-Infinity, -Infinity));\n\n        for(const point of obj.points) {\n            this.b.x = Math.min(point.x, this.b.x);\n            this.b.y = Math.min(point.y, this.b.y);\n\n            this.e.x = Math.max(point.x, this.e.x);\n            this.e.y = Math.max(point.y, this.e.y);\n        }\n    }\n\n    draw(ctx) {\n        ctx.strokeStyle = this.color;\n        ctx.strokeRect(this.b.x, this.b.y, this.e.x - this.b.x, this.e.y - this.b.y);\n    }\n}\n\nclass PhysObject {\n\n    static findCOM(points) {\n        let COM = new Vec2D(0, 0);\n        \n        for(const point of points) {\n            COM.add(point);\n        }\n\n        COM.x /= points.length;\n        COM.y /= points.length;\n\n        return COM;\n    }\n\n    constructor(pos, points, material = wood) {\n        this.force = new Vec2D(0, 0);\n        this.acc = new Vec2D(0, 0);\n        this.vel = new Vec2D(0, 0);\n        this.pos = pos;\n\n        this.torque = 0;\n        this.rotAcc = 0;\n        this.rotVel = 0;\n        this.angle = 0;\n\n        this.masks = [];\n\n        const center = PhysObject.findCOM(points);\n        points.forEach((p) => p.sub(center));\n        this.shape = points;\n        this.points = [];\n        for(let i = 0; i < points.length; i++) {\n            this.points[i] = Vec2D.rotate(new Vec2D(0, 0), this.shape[i], this.angle);\n            this.points[i].add(this.pos);\n        }\n\n        this.material = material;\n        const [mass, moi] = calculateMassAndMoi(this);\n\n        this.mass = mass;\n        this.moi = moi;\n        \n        this.AABB = AABB.findAABB(this);\n        this.func = null;\n    }\n\n    // a force consists of a position vector and a direction vector\n    applyForce(force) {\n        const r = new Vec2D(force.pos.x - this.pos.x, force.pos.y - this.pos.y);\n\n        this.force.add(force.dir);\n        this.torque += r.x * force.dir.y - r.y * force.dir.x;\n    }\n\n    stepForces(dt) {\n        this.acc = this.force.div(this.mass);\n        \n        if(this.mass == 0)\n            this.acc = new Vec2D(0, 0);\n        \n        this.vel.add(this.acc.mult(dt));\n        \n        this.pos.add(this.vel.mult(dt));\n        \n        this.rotAcc = this.torque / this.moi;\n\n        if(this.moi == 0)\n            this.rotAcc = 0;\n        \n        this.rotVel += this.rotAcc * dt;\n\n        this.angle += this.rotVel * dt;\n\n        this.force = new Vec2D(0, 0);\n        this.torque = 0;\n    }\n\n    update() {\n        for(let i = 0; i < this.points.length; i++) {\n            this.points[i] = Vec2D.rotate(new Vec2D(0, 0), this.shape[i], this.angle);\n            this.points[i].add(this.pos);\n        }\n\n        this.AABB.update(this);\n    }\n\n    draw(ctx) {\n        ctx.strokeStyle = \"white\";\n        ctx.lineWidth = 1.5;\n\n        ctx.beginPath();\n        for(const point of this.points) {\n            ctx.lineTo(point.x, point.y);\n        }\n        ctx.closePath();\n\n        ctx.stroke();\n    }\n}\n\nclass PhysEnv {\n    constructor(iterations = 1) {\n        this.objects = [];\n        this.intervals = [];\n        this.sweepX = true;\n\n        this.iterations = iterations;\n    }\n\n    addObject(obj) {\n        let start = [obj.AABB.b, this.objects.length];\n        let end = [obj.AABB.e, this.objects.length];\n        \n        this.intervals.push(start, end);\n        this.objects.push(obj);\n    }\n\n    removeObject(obj) {\n        let idx = -1;\n        \n        for(let i = 0; i < this.objects.length; i++) {\n            if(obj == this.objects[i]) {\n                idx = i;\n                this.objects.splice(i, 1);\n                break;\n            }\n        }\n\n        for(let i = this.intervals.length - 1; i >= 0; i--) {\n            if(idx == this.intervals[i][1]) {\n                this.intervals.splice(i, 1);\n            } else if(this.intervals[i][1] > idx) {\n                this.intervals[i][1]--;\n            }\n        }\n    }\n\n    clearObjects() {\n        this.objects = [];\n        this.intervals = [];\n    }\n\n    sweepAndPrune() {\n        let overlaps = [];\n        let activeObjects = {};\n\n        if(this.sweepX) {\n            insertionSort(this.intervals, (x) => x[0].x);\n        } else {\n            insertionSort(this.intervals, (x) => x[0].y);\n        }\n\n        for(let i = this.intervals.length - 1; i >= 0; i--) {\n            const node = this.intervals[i];\n            if(activeObjects[node[1]] != null) {\n                delete activeObjects[node[1]];\n            } else {\n                for(const key in activeObjects) {\n                    if((this.objects[node[1]].mass == Infinity &&\n                        this.objects[activeObjects[key]].mass == Infinity) || \n                       (this.objects[node[1]].mass == 0 &&\n                        this.objects[activeObjects[key]].mass == 0))\n                        continue;\n                    overlaps.push([this.objects[node[1]], this.objects[activeObjects[key]]]);\n                }\n\n                activeObjects[node[1]] = node[1];\n            }\n        }\n\n        // for(const node of this.intervals) {\n        //     if(activeObjects[node[1]] != null) {\n        //         delete activeObjects[node[1]];\n        //     } else {\n        //         for(const key in activeObjects) {\n        //             overlaps.push([this.objects[node[1]], this.objects[activeObjects[key]]]);\n        //         }\n\n        //         activeObjects[node[1]] = node[1];\n        //     }\n        // }\n\n        return overlaps;\n    }\n\n    update(dt) {\n        this.stepForces(dt);\n        for(let i = 0; i < this.iterations; i++) {\n            this.detectCollisions();\n        }\n    }\n\n    stepForces(dt) {\n        for(const obj of this.objects) {\n            obj.stepForces(dt);\n            obj.update();\n        }\n    }\n\n    detectCollisions() {\n        let simplex = [];\n        let possibleCollisions = this.sweepAndPrune();\n        for(let [s1, s2] of possibleCollisions) {\n            if((simplex = this.GJK(s1, s2))) {\n                if(s1.func) s1.func(s1, s2);\n                if(s2.func) s2.func(s2, s1);\n                \n                if(s1.mass == 0 || s2.mass == 0)\n                    continue;\n\n                let masked = false;\n\n                for(let i = 0; i < s1.masks.length; i++) {\n                    for(let j = 0; j < s2.masks.length; j++) {\n                        if(s1.masks[i] == s2.masks[j]) {\n                            masked = true;\n                            \n                            i = s1.masks.length;\n                            j = s2.masks.length;\n                        }\n                    }\n                }\n\n                if(masked)\n                    continue;\n\n                let [normal, depth] = this.EPA(s1, s2, simplex);\n                \n                let contacts = this.findContacts(s1, s2, normal);\n\n                if(contacts == null)\n                    continue;\n\n                for(const contact of contacts)\n                    this.applyImpulses(s1, s2, normal, contact);\n\n                this.resolveIntersections(s1, s2, normal, depth);\n\n                s1.update();\n                s2.update();\n            }\n        }\n    }\n\n    resolveIntersections(s1, s2, normal, depth) {\n        const slop = .1;\n        const percent = .85;\n        const correction = Math.max(depth - slop, 0) * percent;\n        const totalMass = s1.mass + s2.mass;\n        if(s1.mass == Infinity && s2.mass == Infinity) {\n            return;\n        } else if(s1.mass == Infinity) {\n            s2.pos.x += normal.x * correction;\n            s2.pos.y += normal.y * correction;\n        } else if(s2.mass == Infinity) {\n            s1.pos.x -= normal.x * correction;\n            s1.pos.y -= normal.y * correction;\n        } else {\n            s1.pos.x -= normal.x * correction * s2.mass / totalMass;\n            s1.pos.y -= normal.y * correction * s2.mass / totalMass;\n            \n            s2.pos.x += normal.x * correction * s1.mass / totalMass;\n            s2.pos.y += normal.y * correction * s1.mass / totalMass;\n        }\n    }\n\n    applyImpulses(s1, s2, normal, contact) {\n        const r1 = Vec2D.dif(s1.pos, contact);\n        const v1 = s1.vel.addRet(Vec2D.cross(s1.rotVel, r1));\n\n        const r2 = Vec2D.dif(s2.pos, contact);\n        const v2 = s2.vel.addRet(Vec2D.cross(s2.rotVel, r2));\n\n        const abVel = Vec2D.dif(v1, v2);\n        const contactVel = abVel.dot(normal);\n\n        if(contactVel >= 0)\n            return;\n\n        const armA = Vec2D.cross(r1, normal);\n        const armB = Vec2D.cross(r2, normal);\n\n        const rest = Math.min(s1.material.restitution, s2.material.restitution);\n\n        const m = 1 / s1.mass + 1 / s2.mass + armA * armA / s1.moi + armB * armB / s2.moi; \n        const j = (-(rest + 1) * contactVel) / m;\n        const impulse = normal.mult(j);\n\n        s1.vel.sub(impulse.div(s1.mass));\n        s2.vel.add(impulse.div(s2.mass));\n        \n        const r1CrossI = Vec2D.cross(r1, impulse);\n        const r2CrossI = Vec2D.cross(r2, impulse);\n\n        s1.rotVel -= r1CrossI / s1.moi;\n        s2.rotVel += r2CrossI / s2.moi;\n\n        const tangent = Vec2D.normalize(abVel.subRet(normal.mult(contactVel)));\n        const jt = -abVel.dot(tangent) / m;\n\n        const mu = Math.sqrt(s1.material.sFriction * s1.material.sFriction + s2.material.sFriction * s2.material.sFriction);\n\n        if(Math.abs(jt) < j * mu) {\n            var impulset = tangent.mult(jt);\n        } else {\n            const dFriction = Math.sqrt(s1.material.dFriction * s1.material.dFriction + s2.material.dFriction * s2.material.dFriction);\n            var impulset = tangent.mult(-j * dFriction);\n        }\n\n        if(!isFinite(impulset.x) || !isFinite(impulset.y))\n            return;\n\n        s1.vel.sub(impulset.div(s1.mass));\n        s2.vel.add(impulset.div(s2.mass));\n\n        const r1CrossIt = Vec2D.cross(r1, impulset);\n        const r2CrossIt = Vec2D.cross(r2, impulset);\n\n        s1.rotVel -= r1CrossIt / s1.moi;\n        s2.rotVel += r2CrossIt / s2.moi;\n    }\n\n    findContacts(s1, s2, normal) {\n        const [p1, e1] = this.findCollisionEdge(s1, normal);\n        const [p2, e2] = this.findCollisionEdge(s2, normal.mult(-1));\n\n        const e1Dif = Vec2D.dif(e1[1], e1[0]);\n        const e2Dif = Vec2D.dif(e2[1], e2[0]);\n\n        let ref, pRef, eRef, inc, pInc, eInc;\n        if(Math.abs(e1Dif.dot(normal)) <= Math.abs(e2Dif.dot(normal))) {\n            pRef = p1;\n            eRef = e1;\n            ref = e1Dif;\n\n            pInc = p2;\n            eInc = e2;\n            inc = e2Dif;\n        } else {\n            pRef = p2;\n            eRef = e2;\n            ref = e2Dif;\n\n            pInc = p1;\n            eInc = e1;\n            inc = e1Dif;\n        }\n\n        const refV = Vec2D.normalize(ref).mult(-1);\n        const o1 = refV.dot(eRef[0]);\n\n        let cp = clip(eInc[0], eInc[1], refV, o1);\n\n        if(cp.length < 2) return;\n\n        const o2 = refV.dot(eRef[1]);\n        \n        cp = clip(cp[0], cp[1], refV.mult(-1), -o2);\n        \n        if(cp.length < 2) return;\n\n        let refNorm = Vec2D.cross(ref, -1);\n        \n        const max = refNorm.dot(pRef);\n\n        if(refNorm.dot(cp[1]) - max < 0)\n            cp.splice(1, 1);\n\n        if(refNorm.dot(cp[0]) - max < 0)\n            cp.splice(0, 1);\n    \n        return cp;\n    }\n\n    findCollisionEdge(s, normal) {\n        let v = null;\n        let idx = null;\n        let dot = -Infinity;\n    \n        for(const [i, point] of s.points.entries()) {\n            const proj = point.dot(normal);\n            if(proj > dot) {\n                v = point;\n                idx = i;\n                dot = proj;\n            }\n        }\n    \n        const v0 = s.points[(idx - 1 + s.points.length) % s.points.length];\n        const v1 = s.points[(idx + 1) % s.points.length];\n\n        const leftEdge = Vec2D.dif(v, v0);\n        const rightEdge = Vec2D.dif(v, v1);\n\n        if(Vec2D.normalize(rightEdge).dot(normal) <= Vec2D.normalize(leftEdge).dot(normal)) {\n            return [v, [v0, v], leftEdge];\n        } else {\n            return [v, [v, v1], rightEdge];\n        }\n    }\n\n    GJK(s1, s2) {\n        let d = Vec2D.normalize(Vec2D.dif(s1.pos, s2.pos));\n        let simplex = [minkowskiDifSupport(s1, s2, d)];\n        d = Vec2D.dif(simplex[0], new Vec2D(0, 0));\n\n        while(true) {\n            d = Vec2D.normalize(d);\n            const A = minkowskiDifSupport(s1, s2, d);\n            if(A.dot(d) < 0)\n                return false;\n            simplex.push(A);\n            if(this.handleSimplex(simplex, d))\n                return simplex;\n        }\n    }\n\n    handleSimplex(simplex, d) {\n        if(simplex.length == 2)\n            return this.lineCase(simplex, d);\n        return this.triangleCase(simplex, d);\n    }\n\n    lineCase(simplex, d) {\n        let [B, A] = simplex;\n        let AB = Vec2D.dif(A, B);\n        let AO = Vec2D.dif(A, new Vec2D(0, 0));\n        let ABperp = Vec2D.tripleProd(AB, AO, AB);\n        d.x = ABperp.x;\n        d.y = ABperp.y;\n        return false;\n    }\n\n    triangleCase(simplex, d) {\n        let [C, B, A] = simplex;\n\n        let AB = Vec2D.dif(A, B);\n        let AC = Vec2D.dif(A, C);\n        let AO = Vec2D.dif(A, new Vec2D(0, 0));\n\n        let ABperp = Vec2D.tripleProd(AC, AB, AB);\n        let ACperp = Vec2D.tripleProd(AB, AC, AC);\n\n        if(ABperp.dot(AO) > 0) {\n\n            simplex.splice(0, 1);\n\n            d.x = ABperp.x;\n            d.y = ABperp.y;\n\n            return false;\n        } else if(ACperp.dot(AO) > 0) {\n\n            simplex.splice(1, 1);\n\n            d.x = ACperp.x;\n            d.y = ACperp.y;\n\n            return false;\n        }\n        return true;\n    }\n\n    // expanding polytope algorithm\n    EPA(s1, s2, simplex) {\n        while(true) {\n            let [edgeDist, edgeNorm, edgeIDX] = this.findClosestEdge(simplex);\n            let sup = minkowskiDifSupport(s1, s2, edgeNorm);\n\n            const d = sup.dot(edgeNorm);\n            \n            if(d - edgeDist <= 0.01) {\n                return [edgeNorm, edgeDist];\n            } else {\n                simplex.splice(edgeIDX, 0, sup);\n            }\n        }\n    }\n\n    findClosestEdge(simplex) {\n        let dist = Infinity;\n        let normal, idx;\n\n        for(let i = 0; i < simplex.length; i++) {\n            const j = (i + 1) % simplex.length;\n\n            const edge = Vec2D.dif(simplex[i], simplex[j]);\n            const n = Vec2D.normalize(Vec2D.tripleProd(edge, simplex[i], edge));\n\n            const d = n.dot(simplex[i]);\n\n            if(d < dist) {\n                dist = d;\n                normal = n;\n                idx = j;\n            }\n        }\n\n        return [dist, normal, idx];\n    }\n\n    drawObjects(ctx) {\n        for(const obj of this.objects) {\n            obj.draw(ctx);\n        }\n    }\n}\n\nexports.Vec2D = Vec2D;\nexports.PhysEnv = PhysEnv;\nexports.PhysObject = PhysObject;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/physx.js?");

/***/ }),

/***/ "./src/shared_modules/serialize.js":
/*!*****************************************!*\
  !*** ./src/shared_modules/serialize.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("let avro = __webpack_require__(/*! avsc */ \"./node_modules/avsc/lib/index.js\");\nlet util = __webpack_require__(/*! ./util */ \"./src/shared_modules/util.js\");\n\n\nlet car_schema = {\n    name: '_0',\n    default: null,\n    type: [ 'null', {\n        type: 'record',\n        fields: [\n            { name: 'ready', type: 'boolean' },\n            { name: 'lap', type: 'int' },\n            { name: 'hue', type: 'int' },\n            { name: 'angle', type: 'double' },\n            { name: 'rotVel', type: 'double' },\n            { \n                name: 'pos',\n                type: {\n                    type: 'record',\n                    fields: [\n                        { name: 'x', type: 'double' },\n                        { name: 'y', type: 'double' }\n                    ]\n                }\n            },\n            { \n                name: 'vel', \n                type: {\n                    type: 'record',\n                    fields: [\n                        { name: 'x', type: 'double' },\n                        { name: 'y', type: 'double' }\n                    ]\n                }\n            },\n            {\n                name: 'inputs',\n                type: ['null', {\n                    type: 'record',\n                    fields: [\n                        { name: 'left',  type: 'boolean' },\n                        { name: 'right', type: 'boolean' },\n                        { name: 'up',    type: 'boolean' },\n                        { name: 'down',  type: 'boolean' },\n                        { name: 'shift', type: 'boolean' },\n                        { name: 'enter', type: 'boolean' },\n                    ]\n                }]\n            }\n        ]\n    }]\n};\n\ncar_schema_list = [];\n\nfor(let id = 0; id < util.MAX_PLAYERS; id++) {\n    let new_schema = util.copyObj(car_schema);\n    new_schema.name = \"_\" + id;\n\n    car_schema_list.push(new_schema);\n}\n\nconst BUNDLE_TYPE = avro.Type.forSchema({\n    type: 'record',\n    fields: [\n        { name: 'tick', type: 'long' },\n        {\n            name: 'packets', \n            type: {\n                type: 'record',\n                fields: [\n                    { name: 'id', default: null, type: ['null', 'int'] },\n                    {\n                        name: 'dynamic',\n                        default: null,\n                        type: [ 'null', {\n                            type: 'record',\n                            fields: [\n                                { \n                                    name: 'cars', \n                                    type: {\n                                        type: 'record',\n                                        fields: car_schema_list,\n                                    }\n                                }\n                            ]\n                        }]\n                    },\n                    {\n                        name: 'static',\n                        default: null,\n                        type: [ 'null', {\n                            type: 'record',\n                            fields: [\n                                { name: 'scene', type: 'string' },\n                                { \n                                    name: 'walls', \n                                    type: {\n                                        type: 'array',\n                                        items: [\n                                            {\n                                                type: 'array', \n                                                items: [\n                                                    {\n                                                        type: 'record',\n                                                        fields: [\n                                                            {\n                                                                name: 'pos',\n                                                                type: {\n                                                                    type: 'record',\n                                                                    fields: [\n                                                                        { name: 'x', type: 'double' },\n                                                                        { name: 'y', type: 'double' }\n                                                                    ]\n                                                                }\n                                                            },\n                                                            {\n                                                                name: 'points',\n                                                                type: {\n                                                                    type: 'array',\n                                                                    items: [\n                                                                        {\n                                                                            type: 'record',\n                                                                            fields: [\n                                                                                { name: 'x', type: 'double' },\n                                                                                { name: 'y', type: 'double' }\n                                                                            ]\n                                                                        }\n                                                                    ]\n                                                                }\n                                                            }\n                                                        ]\n                                                    }\n                                                ]\n                                            }\n                                        ]\n                                    }\n                                },\n                            ]\n                        }]\n                    },\n                    {\n                        name: 'inputs',\n                        default: null,\n                        type: ['null', {\n                            type: 'record',\n                            fields: [\n                                { name: 'left',  type: 'boolean' },\n                                { name: 'right', type: 'boolean' },\n                                { name: 'up',    type: 'boolean' },\n                                { name: 'down',  type: 'boolean' },\n                                { name: 'shift', type: 'boolean' },\n                                { name: 'enter', type: 'boolean' },\n                            ]\n                        }]\n                    },\n                    { \n                        name: 'ping', \n                        default: null, \n                        type: ['null', {\n                            type: 'record',\n                            fields: [\n                                { name: 'sTimestamp', type: ['long'] },\n                                { name: 'cTimestamp', type: ['long', 'null'] },\n                                { name: 'clockOffset', type: ['double'] },\n                                { name: 'latency', type: ['double'] },\n                            ]\n                        }]\n                    },\n                ]\n            }\n        },\n    ]\n});\n\nlet encode = (data) => {\n    if(data.packets.dynamic) {\n        var cars = data.packets.dynamic.cars;\n        let temp = {};\n\n        for(const [id, car] of Object.entries(cars))\n            temp['_'+id] = car;\n\n        data.packets.dynamic.cars = temp;\n    }\n\n    const buffer = BUNDLE_TYPE.toBuffer(data);\n\n    if(cars)\n        data.packets.dynamic.cars = cars;\n    \n    return buffer;\n}\n\nlet decode = (buf) => {\n    const buffer = Buffer.from(buf, 'utf8')\n    const data = BUNDLE_TYPE.fromBuffer(buffer);\n\n    if(data.packets.dynamic) {\n        let cars = data.packets.dynamic.cars;\n\n        for(const [id, car] of Object.entries(cars)) {\n            delete cars[id];\n\n            if(car)\n                cars[id.substr(1)] = car;\n        }\n    }\n\n    return data;\n}\n\n// let vec = new Vec2D(-1, 1);\n// let car = new Car(vec, 60);\n// let cars = {\n//     '2': car,\n//     '4': car,\n// };\n\n// let walls = [\n//     [[new Vec2D(0, 0), new Vec2D(0, 1), new Vec2D(1, 1), new Vec2D(1, 0)], [new Vec2D(0, 0), new Vec2D(0, -1), new Vec2D(1, -1), new Vec2D(1, 0)]],\n//     [[new Vec2D(0, 0), new Vec2D(0, 1), new Vec2D(-1, 1), new Vec2D(-1, 0)], [new Vec2D(0, 0), new Vec2D(0, -1), new Vec2D(-1, -1), new Vec2D(-1, 0)]],\n// ];\n\n// let bundle = {\n//     tick: 16000000,\n//     packets: {\n//         id: 4,\n//         dynamic: {\n//             cars: cars,\n//         },\n//         static: {\n//             scene: 'lobby',\n//             walls: walls,\n//         },\n//     },\n// };\n\n// const buff = encode(bundle); \n\n// console.log(buff);\n// console.log(decode(buff).packets.dynamic.cars);\n// console.log(bundle.packets.dynamic.cars)\n\nexports.encode = encode;\nexports.decode = decode;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/serialize.js?");

/***/ }),

/***/ "./src/shared_modules/trackGenerator.js":
/*!**********************************************!*\
  !*** ./src/shared_modules/trackGenerator.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const PhysX = __webpack_require__(/*! ./physx */ \"./src/shared_modules/physx.js\");\nconst Vec2D = PhysX.Vec2D;\n\n//https://github.com/josephg/noisejs/blob/master/perlin.js\n\n/*\n * A speed-improved perlin and simplex noise algorithms for 2D.\n *\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n * Converted to Javascript by Joseph Gentle.\n *\n * Version 2012-03-09\n *\n * This code was placed in the public domain by its original author,\n * Stefan Gustavson. You may use it as you see fit, but\n * attribution is appreciated.\n *\n */\n\nvar mod = global.noise = {};\n\nfunction Grad(x, y, z) {\n    this.x = x; this.y = y; this.z = z;\n}\n\nGrad.prototype.dot2 = function(x, y) {\n    return this.x*x + this.y*y;\n};\n\nGrad.prototype.dot3 = function(x, y, z) {\n    return this.x*x + this.y*y + this.z*z;\n};\n\nvar grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\n                new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\n                new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];\n\nvar p = [151,160,137,91,90,15,\n131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\n// To remove the need for index wrapping, double the permutation table length\nvar perm = new Array(512);\nvar gradP = new Array(512);\n\n// This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\nmod.seed = function(seed) {\n    if(seed > 0 && seed < 1) {\n        // Scale the seed out\n        seed *= 65536;\n    }\n\n    seed = Math.floor(seed);\n    if(seed < 256) {\n        seed |= seed << 8;\n    }\n\n    for(var i = 0; i < 256; i++) {\n        var v;\n        if (i & 1) {\n            v = p[i] ^ (seed & 255);\n        } else {\n            v = p[i] ^ ((seed>>8) & 255);\n        }\n\n        perm[i] = perm[i + 256] = v;\n        gradP[i] = gradP[i + 256] = grad3[v % 12];\n    }\n};\n\nmod.seed(0);\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nvar F2 = 0.5*(Math.sqrt(3)-1);\nvar G2 = (3-Math.sqrt(3))/6;\n\nvar F3 = 1/3;\nvar G3 = 1/6;\n\n// 2D simplex noise\nmod.simplex2 = function(xin, yin) {\n    var n0, n1, n2; // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    var s = (xin+yin)*F2; // Hairy factor for 2D\n    var i = Math.floor(xin+s);\n    var j = Math.floor(yin+s);\n    var t = (i+j)*G2;\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\n    var y0 = yin-j+t;\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n        i1=1; j1=0;\n    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n        i1=0; j1=1;\n    }\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n    // c = (3-sqrt(3))/6\n    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n    var y1 = y0 - j1 + G2;\n    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n    var y2 = y0 - 1 + 2 * G2;\n    // Work out the hashed gradient indices of the three simplex corners\n    i &= 255;\n    j &= 255;\n    var gi0 = gradP[i+perm[j]];\n    var gi1 = gradP[i+i1+perm[j+j1]];\n    var gi2 = gradP[i+1+perm[j+1]];\n    // Calculate the contribution from the three corners\n    var t0 = 0.5 - x0*x0-y0*y0;\n    if(t0<0) {\n        n0 = 0;\n    } else {\n        t0 *= t0;\n        n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n    }\n    var t1 = 0.5 - x1*x1-y1*y1;\n    if(t1<0) {\n        n1 = 0;\n    } else {\n        t1 *= t1;\n        n1 = t1 * t1 * gi1.dot2(x1, y1);\n    }\n    var t2 = 0.5 - x2*x2-y2*y2;\n    if(t2<0) {\n        n2 = 0;\n    } else {\n        t2 *= t2;\n        n2 = t2 * t2 * gi2.dot2(x2, y2);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70 * (n0 + n1 + n2);\n};\n\n// 3D simplex noise\nmod.simplex3 = function(xin, yin, zin) {\n    var n0, n1, n2, n3; // Noise contributions from the four corners\n\n    // Skew the input space to determine which simplex cell we're in\n    var s = (xin+yin+zin)*F3; // Hairy factor for 2D\n    var i = Math.floor(xin+s);\n    var j = Math.floor(yin+s);\n    var k = Math.floor(zin+s);\n\n    var t = (i+j+k)*G3;\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\n    var y0 = yin-j+t;\n    var z0 = zin-k+t;\n\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n    if(x0 >= y0) {\n        if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }\n        else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }\n        else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }\n    } else {\n        if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }\n        else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }\n        else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }\n    }\n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n    // c = 1/6.\n    var x1 = x0 - i1 + G3; // Offsets for second corner\n    var y1 = y0 - j1 + G3;\n    var z1 = z0 - k1 + G3;\n\n    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n    var y2 = y0 - j2 + 2 * G3;\n    var z2 = z0 - k2 + 2 * G3;\n\n    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n    var y3 = y0 - 1 + 3 * G3;\n    var z3 = z0 - 1 + 3 * G3;\n\n    // Work out the hashed gradient indices of the four simplex corners\n    i &= 255;\n    j &= 255;\n    k &= 255;\n    var gi0 = gradP[i+   perm[j+   perm[k   ]]];\n    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];\n    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];\n    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];\n\n    // Calculate the contribution from the four corners\n    var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n    if(t0<0) {\n        n0 = 0;\n    } else {\n        t0 *= t0;\n        n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\n    }\n    var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n    if(t1<0) {\n        n1 = 0;\n    } else {\n        t1 *= t1;\n        n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n    }\n    var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n    if(t2<0) {\n        n2 = 0;\n    } else {\n        t2 *= t2;\n        n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n    }\n    var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n    if(t3<0) {\n        n3 = 0;\n    } else {\n        t3 *= t3;\n        n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 32 * (n0 + n1 + n2 + n3);\n\n};\n\n// ##### Perlin noise stuff\n\nfunction fade(t) {\n    return t*t*t*(t*(t*6-15)+10);\n}\n\nfunction lerp(a, b, t) {\n    return (1-t)*a + t*b;\n}\n\n// 2D Perlin Noise\nmod.perlin2 = function(x, y) {\n    // Find unit grid cell containing point\n    var X = Math.floor(x), Y = Math.floor(y);\n    // Get relative xy coordinates of point within that cell\n    x = x - X; y = y - Y;\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n    X = X & 255; Y = Y & 255;\n\n    // Calculate noise contributions from each of the four corners\n    var n00 = gradP[X+perm[Y]].dot2(x, y);\n    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);\n    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);\n    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);\n\n    // Compute the fade curve value for x\n    var u = fade(x);\n\n    // Interpolate the four results\n    return lerp(\n        lerp(n00, n10, u),\n        lerp(n01, n11, u),\n        fade(y));\n};\n\n// 3D Perlin Noise\nmod.perlin3 = function(x, y, z) {\n    // Find unit grid cell containing point\n    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\n    // Get relative xyz coordinates of point within that cell\n    x = x - X; y = y - Y; z = z - Z;\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n    X = X & 255; Y = Y & 255; Z = Z & 255;\n\n    // Calculate noise contributions from each of the eight corners\n    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);\n    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);\n    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);\n    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);\n    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);\n    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);\n    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);\n    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);\n\n    // Compute the fade curve value for x, y, z\n    var u = fade(x);\n    var v = fade(y);\n    var w = fade(z);\n\n    // Interpolate\n    return lerp(\n        lerp(\n        lerp(n000, n100, u),\n        lerp(n001, n101, u), w),\n        lerp(\n        lerp(n010, n110, u),\n        lerp(n011, n111, u), w),\n        v);\n};\n\nfunction getAngle(vertex, point1, point2) {\n    const theta1 = Math.atan2(point1.y - vertex.y, point1.x - vertex.x);\n    const theta2 = Math.atan2(point2.y - vertex.y, point2.x - vertex.x);\n\n    let diff = modulo(theta2 - theta1 + Math.PI, Math.PI * 2) - Math.PI;\n    diff = diff < -Math.PI ? diff + Math.PI * 2 : diff;\n    return diff < -Math.PI ? diff + Math.PI * 2 : diff;\n}\n\nfunction modulo(n, m) {\n    return ((n % m) + m) % m;\n}\n\nclass Straightaway {\n    constructor(startPoint, endPoint) {\n        this.p1 = startPoint;\n        this.p2 = endPoint;\n        this.length = Vec2D.distance(this.p1, this.p2);\n    }\n\n    draw(ctx) {\n        ctx.moveTo(this.p1.x, this.p1.y);\n        ctx.lineTo(this.p2.x, this.p2.y);\n    }\n}\n\nclass Corner {\n    constructor(startPoint, endPoint, focus) {\n        this.p1 = startPoint;\n        this.p2 = endPoint;\n        this.focus = focus;\n\n        this.radius = Vec2D.distance(startPoint, focus);\n        this.theta = getAngle(focus, startPoint, endPoint);\n        this.length = this.radius * this.theta;\n\n        this.startAngle = Math.atan2(startPoint.y - focus.y, startPoint.x - focus.x);\n        this.endAngle = this.startAngle + this.theta;\n        this.counterClockwise = Math.sign(this.theta) < 0;\n    }\n\n    draw(ctx) {\n        ctx.arc(this.focus.x, this.focus.y, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\n    }\n}\n\nclass Track {\n    constructor(center = new Vec2D(0, 0)) {\n        this.parts = [];\n        this.width = 18;\n        this.center = center;\n\n        this.innerWall = [];\n        this.outerWall = [];\n\n        let success = false;\n        while(!success) {\n            this.seedPoints = this.generateSeedPoints(20);\n            success = this.generateTrack();\n        }\n\n        const spawnPart = this.parts[this.parts.length - 1];\n\n        this.spawn = {\n            x: spawnPart.p1.x,\n            y: spawnPart.p1.y,\n            d: Math.atan2(spawnPart.p2.y - spawnPart.p1.y, spawnPart.p2.x - spawnPart.p1.x),\n        };\n    }\n\n    generateTrack() {\n        let lastPoint = null;\n\n        for(let i = 0; i < this.seedPoints.length; i++) {\n            const vertex = this.seedPoints[i];\n            const p1 = this.seedPoints[modulo(i - 1, this.seedPoints.length)];\n            const p2 = this.seedPoints[modulo(i + 1, this.seedPoints.length)];\n\n            const theta1 = Math.atan2(p1.y - vertex.y, p1.x - vertex.x);\n            const theta2 = Math.atan2(p2.y - vertex.y, p2.x - vertex.x);\n            const bisector = getAngle(vertex, p1, p2) / 2;\n            \n            // const dist = Math.min(Point.distance(vertex, p1), Point.distance(vertex, p2));\n            const leg = 20;//Math.max(Math.random() * dist/2, 20);\n\n            const middle = Math.abs(leg / Math.cos(bisector));\n\n            const x1 = Math.cos(theta1) * leg + vertex.x;\n            const y1 = Math.sin(theta1) * leg + vertex.y;\n            const startPoint = new Vec2D(x1, y1);\n\n            const x2 = Math.cos(theta2) * leg + vertex.x;\n            const y2 = Math.sin(theta2) * leg + vertex.y;\n            const endPoint = new Vec2D(x2, y2);\n\n            const x3 = Math.cos(theta1 + bisector) * middle + vertex.x;\n            const y3 = Math.sin(theta1 + bisector) * middle + vertex.y;\n            const focus = new Vec2D(x3, y3);\n\n            if(lastPoint) {\n                this.parts.push(new Straightaway(lastPoint, startPoint));\n            }\n\n            this.parts.push(new Corner(startPoint, endPoint, focus));\n\n            lastPoint = endPoint;\n        }\n\n        if(this.parts.length == 0)\n            return false;\n\n        this.parts.push(new Straightaway(lastPoint, this.parts[0].p1));\n\n        return true;\n    }\n\n    generateSeedPoints(turns) {\n        let points = [];\n        let radius = 100;\n        let minTheta = Math.PI/10;\n        \n        for(let i = 0; i < turns; i++) {\n            let theta = Math.random() * Math.PI * 2;\n\n            let distanced = false;\n            let depth = 0;\n\n            while(!distanced) {\n                depth++;\n                distanced = true;\n                for(const element of points) {\n                    if(Math.abs(element[1] - theta) < minTheta) {\n                        distanced = false;\n                        theta = Math.random() * Math.PI * 2;\n                    }\n                }\n\n                if(depth > 50) {\n                    break;\n                }\n            }\n            if(!distanced) {\n                break;\n            }\n\n            let nx = Math.cos(theta) * radius + this.center.x;\n            let ny = Math.sin(theta) * radius + this.center.y;\n\n            points.push([new Vec2D(nx, ny), theta]);\n        }\n\n        points.sort((a, b) => a[1] - b[1]);\n        points = points.map(x => x[0]);\n\n        //warp points\n        points = Track.perlinIterate(points, 10, 20, .001);\n        points = Track.perlinIterate(points, 10, 4, .01);\n        points = Track.perlinIterate(points, 10, 1, .1);\n\n        //recenter points\n        let offset = Track.getCenter(points);\n        for(const point of points) {\n            point.x += this.center.x - offset.x;\n            point.y += this.center.y - offset.y;\n        }\n\n        //apply separation forces\n        let separated = false;\n        while(!separated) {\n            separated = true;\n            for(const point of points) {\n                const v = Track.getSeparationVector(point, points);\n                point.x += v.x;\n                point.y += v.y;\n\n                if(v.x != 0 || v.y != 0) {\n                    separated = false;\n                }\n            }\n        }\n\n        //straighten edges\n        points = Track.cleanTrack(points);\n\n        return points;\n    }\n\n    static cleanTrack(points) {\n        let straight = false;\n\n        while(!straight) {\n            straight = true;\n            for(let i = 0; i < points.length; i++) {\n                const vertex = points[i];\n                const p1 = points[modulo(i - 1, points.length)];\n                const p2 = points[modulo(i + 1, points.length)];\n                \n                const theta = Math.abs(getAngle(vertex, p1, p2));\n\n                if(theta > Math.PI * .9 || theta < 1.1) {\n                    points.splice(i, 1);\n                    straight = false;\n                    i--;\n                }\n            }\n        }\n\n        return points;\n    }\n\n    static getCenter(points) {\n        let center = new Vec2D(0, 0);\n        \n        for(const point of points) {\n            center.x += point.x / points.length;\n            center.y += point.y / points.length;\n        }\n\n        return center;\n    }\n\n    static perlinIterate(points, iterations, steps, warpFactor) {\n        noise.seed(Math.random());\n\n        for (let i = 0; i < iterations; i++) {\n            for (const point of points) {\n                point.x += noise.simplex2(point.x * warpFactor, point.y * warpFactor) * steps;\n                point.y += noise.simplex2(-point.x * warpFactor, -point.y * warpFactor) * steps;\n            }\n        }\n\n        return points;\n    }\n    \n\tstatic normalize (x, y) {\n\t\tconst dist = Math.sqrt(x*x + y*y);\n\n\t\tif(dist == 0) return [0, 0];\n\n\t\treturn [x/dist, y/dist];\n    }\n    \n    static getSeparationVector(point, cluster) {\n\t\tlet neighbors = 0;\n\t\tlet xForce = 0;\n\t\tlet yForce = 0;\n\n\t\tfor(let i = 0; i < cluster.length; i++) {\n\t\t\tconst xDif = point.x - cluster[i].x;\n\t\t\tconst yDif = point.y - cluster[i].y;\n\t\t\tconst dist = xDif*xDif + yDif*yDif;\n\t\t\tconst minDist = 50;\n\n\t\t\tif(cluster[i] != point && dist < minDist*minDist) {\n\t\t\t\tneighbors++;\n\n\t\t\t\txForce += xDif;\n\t\t\t\tyForce += yDif;\n\t\t\t}\n\t\t}\n\n\t\tif(neighbors == 0) return new Vec2D(0, 0);\n\t\t \n\t\txForce /= neighbors;\t\n        yForce /= neighbors;\n        \n        const vector = this.normalize(xForce, yForce);\n\n\t\treturn new Vec2D(vector[0], vector[1]);\n\t}\n\n    static genMeshCorner(corner, offset) {\n        let points = [];\n    \n        const radius = (corner.theta > 0) ? corner.radius + offset : corner.radius - offset;\n        const freq = 24 / (2 * Math.PI);\n        const pointAmt = Math.ceil(Math.abs(corner.theta) * freq);\n        const dtheta = corner.theta / pointAmt;\n        let theta = corner.startAngle;\n    \n        for(let i = 0; i <= pointAmt; i++) {\n            const nx = corner.focus.x + radius * Math.cos(theta);\n            const ny = corner.focus.y + radius * Math.sin(theta);\n    \n            points.push(new Vec2D(nx, ny));\n    \n            theta += dtheta;\n        }\n    \n        return points;\n    }\n    \n    static genMesh(track) {\n        const offset = track.width / 2;\n        const wallThickness = 2;\n        let innerShape = [[], []];\n        let outerShape = [[], []];\n    \n        for(const part of track.parts) {\n            if(part instanceof Corner) {\n                innerShape[0].push(...Track.genMeshCorner(part, -offset));\n                innerShape[1].push(...Track.genMeshCorner(part, -offset - wallThickness));\n\n                outerShape[1].push(...Track.genMeshCorner(part, offset));\n                outerShape[0].push(...Track.genMeshCorner(part, offset + wallThickness));\n            }\n        }\n\n        let innerWallPts = [];\n        let outerWallPts = [];\n        \n        const length = innerShape[0].length;\n        for(let cur = 0; cur < length; cur++) {\n            let next = cur + 1 < length ? cur + 1 : 0;\n            innerWallPts[cur] = [innerShape[0][cur],\n                                 innerShape[1][cur],\n                                 innerShape[1][next],\n                                 innerShape[0][next]];\n        }\n        \n        for(let cur = 0; cur < length; cur++) {\n            let next = cur + 1 < length ? cur + 1 : 0;\n            outerWallPts[cur] = [outerShape[0][cur],\n                                 outerShape[1][cur],\n                                 outerShape[1][next],\n                                 outerShape[0][next]];\n        }\n\n        track.innerWall = innerWallPts;\n        track.outerWall = outerWallPts;\n    }\n\n    draw(ctx) {\n        ctx.strokeStyle = \"#080F0F\";\n        ctx.lineWidth = this.width;\n\n        let h = 0;\n        for(const part of this.parts) {\n            h += 360 / this.parts.length;\n            ctx.strokeStyle = \"hsl(\"+h+\", 50%, 50%)\";\n            ctx.beginPath();\n            part.draw(ctx);\n            ctx.stroke();\n        }\n    }\n\n    drawMesh(ctx) {\n        ctx.strokeStyle = \"cyan\";\n        ctx.lineWidth = 1;\n\n        for(const pts of this.innerWall) {\n            ctx.beginPath();\n            for(const point of pts) {\n                ctx.lineTo(point.x, point.y);\n            }\n            ctx.closePath();\n            ctx.stroke();\n        }\n\n        for(const pts of this.outerWall) {\n            ctx.beginPath();\n            for(const point of pts) {\n                ctx.lineTo(point.x, point.y);\n            }\n            ctx.closePath();\n            ctx.stroke();\n        }\n    }\n}\n\nmodule.exports = Track;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/trackGenerator.js?");

/***/ }),

/***/ "./src/shared_modules/util.js":
/*!************************************!*\
  !*** ./src/shared_modules/util.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("this.CANVAS_WIDTH = 480;\nthis.CANVAS_HEIGHT = 720;\nthis.BUFFER_SIZE = 1024\nthis.MAX_PLAYERS = 5;\nthis.NUM_LAPS = 3;\n\nthis.getTime = () => {\n    let d = new Date();\n    let t = d.getTime();\n    return t;\n}\n\nfunction interval (duration, fn) {\n    var _this = this\n    this.baseline = undefined\n    \n    this.run = function(){\n        if(_this.baseline === undefined){\n            _this.baseline = new Date().getTime()\n        }\n        fn()\n        var end = new Date().getTime()\n        _this.baseline += duration\n    \n        var nextTick = duration - (end - _this.baseline)\n        if(nextTick<0){\n            nextTick = 0\n        }\n        \n        _this.timer = setTimeout(function(){\n            _this.run(end)\n        }, nextTick)\n    }\n  \n    this.stop = function(){\n        clearTimeout(_this.timer)\n    }\n}\n\nthis.min_missing_id = (clients, min = 0, offset = 0) => {\n    let arr = Array.from(clients).sort((a, b) => a.id - b.id);\n\n    for(var i = 0; i < arr.length - 1; i++) {\n        if(arr[i + offset].id != i + min) {\n            break;\n        }\n    }\n    return i + min;\n}\n\nthis.getBuffer = (buffer, id) => {\n    return buffer[(id + this.BUFFER_SIZE) % this.BUFFER_SIZE];\n}\n\nthis.setBuffer = (buffer, id, data) => {\n    buffer[(id + this.BUFFER_SIZE) % this.BUFFER_SIZE] = data;\n}\n\nthis.copyObj = (obj) => {\n    return JSON.parse(JSON.stringify(obj));\n}\n\nexports = this;\nexports.interval = interval;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/util.js?");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "?bb17":
/*!********************************!*\
  !*** utf-8-validate (ignored) ***!
  \********************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/utf-8-validate_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/server/server.js");
/******/ 	
/******/ })()
;