/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/avsc/lib/containers.js":
/*!*********************************************!*\
  !*** ./node_modules/avsc/lib/containers.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\r\n\r\n// TODO: Add streams which prefix each record with its length.\r\n\r\n\r\n\r\n/**\r\n * This module defines custom streams to write and read Avro files.\r\n *\r\n * In particular, the `Block{En,De}coder` streams are able to deal with Avro\r\n * container files. None of the streams below depend on the filesystem however,\r\n * this way they can also be used in the browser (for example to parse HTTP\r\n * responses).\r\n */\r\n\r\nvar types = __webpack_require__(/*! ./types */ \"./node_modules/avsc/lib/types.js\"),\r\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\r\n    stream = __webpack_require__(/*! stream */ \"stream\"),\r\n    util = __webpack_require__(/*! util */ \"util\"),\r\n    zlib = __webpack_require__(/*! zlib */ \"zlib\");\r\n\r\n\r\nvar OPTS = {namespace: 'org.apache.avro.file'};\r\n\r\nvar LONG_TYPE = types.Type.forSchema('long', OPTS);\r\n\r\nvar MAP_BYTES_TYPE = types.Type.forSchema({type: 'map', values: 'bytes'}, OPTS);\r\n\r\nvar HEADER_TYPE = types.Type.forSchema({\r\n  name: 'Header',\r\n  type: 'record',\r\n  fields : [\r\n    {name: 'magic', type: {type: 'fixed', name: 'Magic', size: 4}},\r\n    {name: 'meta', type: MAP_BYTES_TYPE},\r\n    {name: 'sync', type: {type: 'fixed', name: 'Sync', size: 16}}\r\n  ]\r\n}, OPTS);\r\n\r\nvar BLOCK_TYPE = types.Type.forSchema({\r\n  name: 'Block',\r\n  type: 'record',\r\n  fields : [\r\n    {name: 'count', type: 'long'},\r\n    {name: 'data', type: 'bytes'},\r\n    {name: 'sync', type: 'Sync'}\r\n  ]\r\n}, OPTS);\r\n\r\n// First 4 bytes of an Avro object container file.\r\nvar MAGIC_BYTES = utils.bufferFrom('Obj\\x01');\r\n\r\n// Convenience.\r\nvar f = util.format;\r\nvar Tap = utils.Tap;\r\n\r\n\r\n/** Duplex stream for decoding fragments. */\r\nfunction RawDecoder(schema, opts) {\r\n  opts = opts || {};\r\n\r\n  var noDecode = !!opts.noDecode;\r\n  stream.Duplex.call(this, {\r\n    readableObjectMode: !noDecode,\r\n    allowHalfOpen: false\r\n  });\r\n\r\n  this._type = types.Type.forSchema(schema);\r\n  this._tap = new Tap(utils.newBuffer(0));\r\n  this._writeCb = null;\r\n  this._needPush = false;\r\n  this._readValue = createReader(noDecode, this._type);\r\n  this._finished = false;\r\n\r\n  this.on('finish', function () {\r\n    this._finished = true;\r\n    this._read();\r\n  });\r\n}\r\nutil.inherits(RawDecoder, stream.Duplex);\r\n\r\nRawDecoder.prototype._write = function (chunk, encoding, cb) {\r\n  // Store the write callback and call it when we are done decoding all records\r\n  // in this chunk. If we call it right away, we risk loading the entire input\r\n  // in memory. We only need to store the latest callback since the stream API\r\n  // guarantees that `_write` won't be called again until we call the previous.\r\n  this._writeCb = cb;\r\n\r\n  var tap = this._tap;\r\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\r\n  tap.pos = 0;\r\n  if (this._needPush) {\r\n    this._needPush = false;\r\n    this._read();\r\n  }\r\n};\r\n\r\nRawDecoder.prototype._read = function () {\r\n  this._needPush = false;\r\n\r\n  var tap = this._tap;\r\n  var pos = tap.pos;\r\n  var val = this._readValue(tap);\r\n  if (tap.isValid()) {\r\n    this.push(val);\r\n  } else if (!this._finished) {\r\n    tap.pos = pos;\r\n    this._needPush = true;\r\n    if (this._writeCb) {\r\n      // This should only ever be false on the first read, and only if it\r\n      // happens before the first write.\r\n      this._writeCb();\r\n    }\r\n  } else {\r\n    this.push(null);\r\n  }\r\n};\r\n\r\n\r\n/** Duplex stream for decoding object container files. */\r\nfunction BlockDecoder(opts) {\r\n  opts = opts || {};\r\n\r\n  var noDecode = !!opts.noDecode;\r\n  stream.Duplex.call(this, {\r\n    allowHalfOpen: true, // For async decompressors.\r\n    readableObjectMode: !noDecode\r\n  });\r\n\r\n  this._rType = opts.readerSchema !== undefined ?\r\n    types.Type.forSchema(opts.readerSchema) :\r\n    undefined;\r\n  this._wType = null;\r\n  this._codecs = opts.codecs;\r\n  this._codec = undefined;\r\n  this._parseHook = opts.parseHook;\r\n  this._tap = new Tap(utils.newBuffer(0));\r\n  this._blockTap = new Tap(utils.newBuffer(0));\r\n  this._syncMarker = null;\r\n  this._readValue = null;\r\n  this._noDecode = noDecode;\r\n  this._queue = new utils.OrderedQueue();\r\n  this._decompress = null; // Decompression function.\r\n  this._index = 0; // Next block index.\r\n  this._remaining = undefined; // In the current block.\r\n  this._needPush = false;\r\n  this._finished = false;\r\n\r\n  this.on('finish', function () {\r\n    this._finished = true;\r\n    if (this._needPush) {\r\n      this._read();\r\n    }\r\n  });\r\n}\r\nutil.inherits(BlockDecoder, stream.Duplex);\r\n\r\nBlockDecoder.defaultCodecs = function () {\r\n  return {\r\n    'null': function (buf, cb) { cb(null, buf); },\r\n    'deflate': zlib.inflateRaw\r\n  };\r\n};\r\n\r\nBlockDecoder.getDefaultCodecs = BlockDecoder.defaultCodecs;\r\n\r\nBlockDecoder.prototype._decodeHeader = function () {\r\n  var tap = this._tap;\r\n  if (tap.buf.length < MAGIC_BYTES.length) {\r\n    // Wait until more data arrives.\r\n    return false;\r\n  }\r\n\r\n  if (!MAGIC_BYTES.equals(tap.buf.slice(0, MAGIC_BYTES.length))) {\r\n    this.emit('error', new Error('invalid magic bytes'));\r\n    return false;\r\n  }\r\n\r\n  var header = HEADER_TYPE._read(tap);\r\n  if (!tap.isValid()) {\r\n    return false;\r\n  }\r\n\r\n  this._codec = (header.meta['avro.codec'] || 'null').toString();\r\n  var codecs = this._codecs || BlockDecoder.getDefaultCodecs();\r\n  this._decompress = codecs[this._codec];\r\n  if (!this._decompress) {\r\n    this.emit('error', new Error(f('unknown codec: %s', this._codec)));\r\n    return;\r\n  }\r\n\r\n  try {\r\n    var schema = JSON.parse(header.meta['avro.schema'].toString());\r\n    if (this._parseHook) {\r\n      schema = this._parseHook(schema);\r\n    }\r\n    this._wType = types.Type.forSchema(schema);\r\n  } catch (err) {\r\n    this.emit('error', err);\r\n    return;\r\n  }\r\n\r\n  try {\r\n    this._readValue = createReader(this._noDecode, this._wType, this._rType);\r\n  } catch (err) {\r\n    this.emit('error', err);\r\n    return;\r\n  }\r\n\r\n  this._syncMarker = header.sync;\r\n  this.emit('metadata', this._wType, this._codec, header);\r\n  return true;\r\n};\r\n\r\nBlockDecoder.prototype._write = function (chunk, encoding, cb) {\r\n  var tap = this._tap;\r\n  tap.buf = Buffer.concat([tap.buf, chunk]);\r\n  tap.pos = 0;\r\n\r\n  if (!this._decodeHeader()) {\r\n    process.nextTick(cb);\r\n    return;\r\n  }\r\n\r\n  // We got the header, switch to block decoding mode. Also, call it directly\r\n  // in case we already have all the data (in which case `_write` wouldn't get\r\n  // called anymore).\r\n  this._write = this._writeChunk;\r\n  this._write(utils.newBuffer(0), encoding, cb);\r\n};\r\n\r\nBlockDecoder.prototype._writeChunk = function (chunk, encoding, cb) {\r\n  var tap = this._tap;\r\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\r\n  tap.pos = 0;\r\n\r\n  var nBlocks = 1;\r\n  var block;\r\n  while ((block = tryReadBlock(tap))) {\r\n    if (!this._syncMarker.equals(block.sync)) {\r\n      this.emit('error', new Error('invalid sync marker'));\r\n      return;\r\n    }\r\n    nBlocks++;\r\n    this._decompress(\r\n      block.data,\r\n      this._createBlockCallback(block.data.length, block.count, chunkCb)\r\n    );\r\n  }\r\n  chunkCb();\r\n\r\n  function chunkCb() {\r\n    if (!--nBlocks) {\r\n      cb();\r\n    }\r\n  }\r\n};\r\n\r\nBlockDecoder.prototype._createBlockCallback = function (size, count, cb) {\r\n  var self = this;\r\n  var index = this._index++;\r\n\r\n  return function (cause, data) {\r\n    if (cause) {\r\n      var err = new Error(f('%s codec decompression error', self._codec));\r\n      err.cause = cause;\r\n      self.emit('error', err);\r\n      cb();\r\n    } else {\r\n      self.emit('block', new BlockInfo(count, data.length, size));\r\n      self._queue.push(new BlockData(index, data, cb, count));\r\n      if (self._needPush) {\r\n        self._read();\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\nBlockDecoder.prototype._read = function () {\r\n  this._needPush = false;\r\n\r\n  var tap = this._blockTap;\r\n  if (!this._remaining) {\r\n    var data = this._queue.pop();\r\n    if (!data || !data.count) {\r\n      if (this._finished) {\r\n        this.push(null);\r\n      } else {\r\n        this._needPush = true;\r\n      }\r\n      if (data) {\r\n        data.cb();\r\n      }\r\n      return; // Wait for more data.\r\n    }\r\n    data.cb();\r\n    this._remaining = data.count;\r\n    tap.buf = data.buf;\r\n    tap.pos = 0;\r\n  }\r\n\r\n  this._remaining--;\r\n  var val;\r\n  try {\r\n    val = this._readValue(tap);\r\n    if (!tap.isValid()) {\r\n      throw new Error('truncated block');\r\n    }\r\n  } catch (err) {\r\n    this._remaining = 0;\r\n    this.emit('error', err); // Corrupt data.\r\n    return;\r\n  }\r\n  this.push(val);\r\n};\r\n\r\n\r\n/** Duplex stream for encoding. */\r\nfunction RawEncoder(schema, opts) {\r\n  opts = opts || {};\r\n\r\n  stream.Transform.call(this, {\r\n    writableObjectMode: true,\r\n    allowHalfOpen: false\r\n  });\r\n\r\n  this._type = types.Type.forSchema(schema);\r\n  this._writeValue = function (tap, val) {\r\n    try {\r\n      this._type._write(tap, val);\r\n    } catch (err) {\r\n      this.emit('typeError', err, val, this._type);\r\n    }\r\n  };\r\n  this._tap = new Tap(utils.newBuffer(opts.batchSize || 65536));\r\n\r\n  this.on('typeError', function (err) { this.emit('error', err); });\r\n}\r\nutil.inherits(RawEncoder, stream.Transform);\r\n\r\nRawEncoder.prototype._transform = function (val, encoding, cb) {\r\n  var tap = this._tap;\r\n  var buf = tap.buf;\r\n  var pos = tap.pos;\r\n\r\n  this._writeValue(tap, val);\r\n  if (!tap.isValid()) {\r\n    if (pos) {\r\n      // Emit any valid data.\r\n      this.push(copyBuffer(tap.buf, 0, pos));\r\n    }\r\n    var len = tap.pos - pos;\r\n    if (len > buf.length) {\r\n      // Not enough space for last written object, need to resize.\r\n      tap.buf = utils.newBuffer(2 * len);\r\n    }\r\n    tap.pos = 0;\r\n    this._writeValue(tap, val); // Rewrite last failed write.\r\n  }\r\n\r\n  cb();\r\n};\r\n\r\nRawEncoder.prototype._flush = function (cb) {\r\n  var tap = this._tap;\r\n  var pos = tap.pos;\r\n  if (pos) {\r\n    // This should only ever be false if nothing is written to the stream.\r\n    this.push(tap.buf.slice(0, pos));\r\n  }\r\n  cb();\r\n};\r\n\r\n\r\n/**\r\n * Duplex stream to write object container files.\r\n *\r\n * @param schema\r\n * @param opts {Object}\r\n *\r\n *  + `blockSize`, uncompressed.\r\n *  + `codec`\r\n *  + `codecs`\r\n *  + `metadata``\r\n *  + `noCheck`\r\n *  + `omitHeader`, useful to append to an existing block file.\r\n */\r\nfunction BlockEncoder(schema, opts) {\r\n  opts = opts || {};\r\n\r\n  stream.Duplex.call(this, {\r\n    allowHalfOpen: true, // To support async compressors.\r\n    writableObjectMode: true\r\n  });\r\n\r\n  var type;\r\n  if (types.Type.isType(schema)) {\r\n    type = schema;\r\n    schema = undefined;\r\n  } else {\r\n    // Keep full schema to be able to write it to the header later.\r\n    type = types.Type.forSchema(schema);\r\n  }\r\n\r\n  this._schema = schema;\r\n  this._type = type;\r\n  this._writeValue = function (tap, val) {\r\n    try {\r\n      this._type._write(tap, val);\r\n    } catch (err) {\r\n      this.emit('typeError', err, val, this._type);\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n  this._blockSize = opts.blockSize || 65536;\r\n  this._tap = new Tap(utils.newBuffer(this._blockSize));\r\n  this._codecs = opts.codecs;\r\n  this._codec = opts.codec || 'null';\r\n  this._blockCount = 0;\r\n  this._syncMarker = opts.syncMarker || new utils.Lcg().nextBuffer(16);\r\n  this._queue = new utils.OrderedQueue();\r\n  this._pending = 0;\r\n  this._finished = false;\r\n  this._needHeader = false;\r\n  this._needPush = false;\r\n\r\n  this._metadata = opts.metadata || {};\r\n  if (!MAP_BYTES_TYPE.isValid(this._metadata)) {\r\n    throw new Error('invalid metadata');\r\n  }\r\n\r\n  var codec = this._codec;\r\n  this._compress = (this._codecs || BlockEncoder.getDefaultCodecs())[codec];\r\n  if (!this._compress) {\r\n    throw new Error(f('unsupported codec: %s', codec));\r\n  }\r\n\r\n  if (opts.omitHeader !== undefined) { // Legacy option.\r\n    opts.writeHeader = opts.omitHeader ? 'never' : 'auto';\r\n  }\r\n  switch (opts.writeHeader) {\r\n    case false:\r\n    case 'never':\r\n      break;\r\n    case undefined: // Backwards-compatibility (eager default would be better).\r\n    case 'auto':\r\n      this._needHeader = true;\r\n      break;\r\n    default:\r\n      this._writeHeader();\r\n  }\r\n\r\n  this.on('finish', function () {\r\n    this._finished = true;\r\n    if (this._blockCount) {\r\n      this._flushChunk();\r\n    } else if (this._finished && this._needPush) {\r\n      // We don't need to check `_isPending` since `_blockCount` is always\r\n      // positive after the first flush.\r\n      this.push(null);\r\n    }\r\n  });\r\n\r\n  this.on('typeError', function (err) { this.emit('error', err); });\r\n}\r\nutil.inherits(BlockEncoder, stream.Duplex);\r\n\r\nBlockEncoder.defaultCodecs = function () {\r\n  return {\r\n    'null': function (buf, cb) { cb(null, buf); },\r\n    'deflate': zlib.deflateRaw\r\n  };\r\n};\r\n\r\nBlockEncoder.getDefaultCodecs = BlockEncoder.defaultCodecs;\r\n\r\nBlockEncoder.prototype._writeHeader = function () {\r\n  var schema = JSON.stringify(\r\n    this._schema ? this._schema : this._type.getSchema({exportAttrs: true})\r\n  );\r\n  var meta = utils.copyOwnProperties(\r\n    this._metadata,\r\n    {'avro.schema': utils.bufferFrom(schema), 'avro.codec': utils.bufferFrom(this._codec)},\r\n    true // Overwrite.\r\n  );\r\n  var Header = HEADER_TYPE.getRecordConstructor();\r\n  var header = new Header(MAGIC_BYTES, meta, this._syncMarker);\r\n  this.push(header.toBuffer());\r\n};\r\n\r\nBlockEncoder.prototype._write = function (val, encoding, cb) {\r\n  if (this._needHeader) {\r\n    this._writeHeader();\r\n    this._needHeader = false;\r\n  }\r\n\r\n  var tap = this._tap;\r\n  var pos = tap.pos;\r\n  var flushing = false;\r\n\r\n  if (this._writeValue(tap, val)) {\r\n    if (!tap.isValid()) {\r\n      if (pos) {\r\n        this._flushChunk(pos, cb);\r\n        flushing = true;\r\n      }\r\n      var len = tap.pos - pos;\r\n      if (len > this._blockSize) {\r\n        // Not enough space for last written object, need to resize.\r\n        this._blockSize = len * 2;\r\n      }\r\n      tap.buf = utils.newBuffer(this._blockSize);\r\n      tap.pos = 0;\r\n      this._writeValue(tap, val); // Rewrite last failed write.\r\n    }\r\n    this._blockCount++;\r\n  } else {\r\n    tap.pos = pos;\r\n  }\r\n\r\n  if (!flushing) {\r\n    cb();\r\n  }\r\n};\r\n\r\nBlockEncoder.prototype._flushChunk = function (pos, cb) {\r\n  var tap = this._tap;\r\n  pos = pos || tap.pos;\r\n  this._compress(tap.buf.slice(0, pos), this._createBlockCallback(pos, cb));\r\n  this._blockCount = 0;\r\n};\r\n\r\nBlockEncoder.prototype._read = function () {\r\n  var self = this;\r\n  var data = this._queue.pop();\r\n  if (!data) {\r\n    if (this._finished && !this._pending) {\r\n      process.nextTick(function () { self.push(null); });\r\n    } else {\r\n      this._needPush = true;\r\n    }\r\n    return;\r\n  }\r\n\r\n  this.push(LONG_TYPE.toBuffer(data.count, true));\r\n  this.push(LONG_TYPE.toBuffer(data.buf.length, true));\r\n  this.push(data.buf);\r\n  this.push(this._syncMarker);\r\n\r\n  if (!this._finished) {\r\n    data.cb();\r\n  }\r\n};\r\n\r\nBlockEncoder.prototype._createBlockCallback = function (size, cb) {\r\n  var self = this;\r\n  var index = this._index++;\r\n  var count = this._blockCount;\r\n  this._pending++;\r\n\r\n  return function (cause, data) {\r\n    if (cause) {\r\n      var err = new Error(f('%s codec compression error', self._codec));\r\n      err.cause = cause;\r\n      self.emit('error', err);\r\n      return;\r\n    }\r\n    self._pending--;\r\n    self.emit('block', new BlockInfo(count, size, data.length));\r\n    self._queue.push(new BlockData(index, data, cb, count));\r\n    if (self._needPush) {\r\n      self._needPush = false;\r\n      self._read();\r\n    }\r\n  };\r\n};\r\n\r\n\r\n// Helpers.\r\n\r\n/** Summary information about a block. */\r\nfunction BlockInfo(count, raw, compressed) {\r\n  this.valueCount = count;\r\n  this.rawDataLength = raw;\r\n  this.compressedDataLength = compressed;\r\n}\r\n\r\n/**\r\n * An indexed block.\r\n *\r\n * This can be used to preserve block order since compression and decompression\r\n * can cause some some blocks to be returned out of order.\r\n */\r\nfunction BlockData(index, buf, cb, count) {\r\n  this.index = index;\r\n  this.buf = buf;\r\n  this.cb = cb;\r\n  this.count = count | 0;\r\n}\r\n\r\n/** Maybe get a block. */\r\nfunction tryReadBlock(tap) {\r\n  var pos = tap.pos;\r\n  var block = BLOCK_TYPE._read(tap);\r\n  if (!tap.isValid()) {\r\n    tap.pos = pos;\r\n    return null;\r\n  }\r\n  return block;\r\n}\r\n\r\n/** Create bytes consumer, either reading or skipping records. */\r\nfunction createReader(noDecode, writerType, readerType) {\r\n  if (noDecode) {\r\n    return (function (skipper) {\r\n      return function (tap) {\r\n        var pos = tap.pos;\r\n        skipper(tap);\r\n        return tap.buf.slice(pos, tap.pos);\r\n      };\r\n    })(writerType._skip);\r\n  } else if (readerType) {\r\n    var resolver = readerType.createResolver(writerType);\r\n    return function (tap) { return resolver._read(tap); };\r\n  } else {\r\n    return function (tap) { return writerType._read(tap); };\r\n  }\r\n}\r\n\r\n/** Copy a buffer. This avoids creating a slice of the original buffer. */\r\nfunction copyBuffer(buf, pos, len) {\r\n  var copy = utils.newBuffer(len);\r\n  buf.copy(copy, 0, pos, pos + len);\r\n  return copy;\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  BLOCK_TYPE: BLOCK_TYPE, // For tests.\r\n  HEADER_TYPE: HEADER_TYPE, // Idem.\r\n  MAGIC_BYTES: MAGIC_BYTES, // Idem.\r\n  streams: {\r\n    BlockDecoder: BlockDecoder,\r\n    BlockEncoder: BlockEncoder,\r\n    RawDecoder: RawDecoder,\r\n    RawEncoder: RawEncoder\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/containers.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/files.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/files.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\r\n\r\n\r\n\r\n/**\r\n * Filesystem specifics.\r\n *\r\n * This module contains functions only used by node.js. It is shimmed by\r\n * another module when `avsc` is required from `browserify`.\r\n */\r\n\r\nvar fs = __webpack_require__(/*! fs */ \"fs\"),\r\n    path = __webpack_require__(/*! path */ \"path\");\r\n\r\n/** Default (asynchronous) file loading function for assembling IDLs. */\r\nfunction createImportHook() {\r\n  var imports = {};\r\n  return function (fpath, kind, cb) {\r\n    fpath = path.resolve(fpath);\r\n    if (imports[fpath]) {\r\n      // Already imported, return nothing to avoid duplicating attributes.\r\n      process.nextTick(cb);\r\n      return;\r\n    }\r\n    imports[fpath] = true;\r\n    fs.readFile(fpath, {encoding: 'utf8'}, cb);\r\n  };\r\n}\r\n\r\n/**\r\n * Synchronous file loading function for assembling IDLs.\r\n *\r\n * This is only for internal use (inside `specs.parse`). The returned\r\n * hook should only be called on paths that are guaranteed to exist (where\r\n * `fs.readFileSync` will not throw, otherwise the calling `assemble` call will\r\n * throw rather than return the error to the callback).\r\n */\r\nfunction createSyncImportHook() {\r\n  var imports = {};\r\n  return function (fpath, kind, cb) {\r\n    fpath = path.resolve(fpath);\r\n    if (imports[fpath]) {\r\n      cb();\r\n    } else {\r\n      imports[fpath] = true;\r\n      cb(null, fs.readFileSync(fpath, {encoding: 'utf8'}));\r\n    }\r\n  };\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  createImportHook: createImportHook,\r\n  createSyncImportHook: createSyncImportHook,\r\n  // Proxy a few methods to better shim them for browserify.\r\n  existsSync: fs.existsSync,\r\n  readFileSync: fs.readFileSync\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/files.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\r\n\r\n\r\n\r\n/**\r\n * Node.js entry point (see `etc/browser/` for browserify's entry points).\r\n *\r\n * It also adds Node.js specific functionality (for example a few convenience\r\n * functions to read Avro files from the local filesystem).\r\n */\r\n\r\nvar containers = __webpack_require__(/*! ./containers */ \"./node_modules/avsc/lib/containers.js\"),\r\n    services = __webpack_require__(/*! ./services */ \"./node_modules/avsc/lib/services.js\"),\r\n    specs = __webpack_require__(/*! ./specs */ \"./node_modules/avsc/lib/specs.js\"),\r\n    types = __webpack_require__(/*! ./types */ \"./node_modules/avsc/lib/types.js\"),\r\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\r\n    fs = __webpack_require__(/*! fs */ \"fs\"),\r\n    util = __webpack_require__(/*! util */ \"util\");\r\n\r\n\r\n/** Parse a schema and return the corresponding type or service. */\r\nfunction parse(any, opts) {\r\n  var schemaOrProtocol = specs.read(any);\r\n  return schemaOrProtocol.protocol ?\r\n    services.Service.forProtocol(schemaOrProtocol, opts) :\r\n    types.Type.forSchema(schemaOrProtocol, opts);\r\n}\r\n\r\n/** Extract a container file's header synchronously. */\r\nfunction extractFileHeader(path, opts) {\r\n  opts = opts || {};\r\n\r\n  var decode = opts.decode === undefined ? true : !!opts.decode;\r\n  var size = Math.max(opts.size || 4096, 4);\r\n  var buf = utils.newBuffer(size);\r\n  var fd = fs.openSync(path, 'r');\r\n\r\n  try {\r\n    var pos = fs.readSync(fd, buf, 0, size);\r\n    if (pos < 4 || !containers.MAGIC_BYTES.equals(buf.slice(0, 4))) {\r\n      return null;\r\n    }\r\n\r\n    var tap = new utils.Tap(buf);\r\n    var header = null;\r\n    do {\r\n      header = containers.HEADER_TYPE._read(tap);\r\n    } while (!isValid());\r\n    if (decode !== false) {\r\n      var meta = header.meta;\r\n      meta['avro.schema'] = JSON.parse(meta['avro.schema'].toString());\r\n      if (meta['avro.codec'] !== undefined) {\r\n        meta['avro.codec'] = meta['avro.codec'].toString();\r\n      }\r\n    }\r\n    return header;\r\n  } finally {\r\n    fs.closeSync(fd);\r\n  }\r\n\r\n  function isValid() {\r\n    if (tap.isValid()) {\r\n      return true;\r\n    }\r\n    var len = 2 * tap.buf.length;\r\n    var buf = utils.newBuffer(len);\r\n    len = fs.readSync(fd, buf, 0, len);\r\n    tap.buf = Buffer.concat([tap.buf, buf]);\r\n    tap.pos = 0;\r\n    return false;\r\n  }\r\n}\r\n\r\n/** Readable stream of records from a local Avro file. */\r\nfunction createFileDecoder(path, opts) {\r\n  return fs.createReadStream(path)\r\n    .pipe(new containers.streams.BlockDecoder(opts));\r\n}\r\n\r\n/** Writable stream of records to a local Avro file. */\r\nfunction createFileEncoder(path, schema, opts) {\r\n  var encoder = new containers.streams.BlockEncoder(schema, opts);\r\n  encoder.pipe(fs.createWriteStream(path, {defaultEncoding: 'binary'}));\r\n  return encoder;\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  Service: services.Service,\r\n  Type: types.Type,\r\n  assembleProtocol: specs.assembleProtocol,\r\n  createFileDecoder: createFileDecoder,\r\n  createFileEncoder: createFileEncoder,\r\n  discoverProtocol: services.discoverProtocol,\r\n  extractFileHeader: extractFileHeader,\r\n  parse: parse,\r\n  readProtocol: specs.readProtocol,\r\n  readSchema: specs.readSchema,\r\n  streams: containers.streams,\r\n  types: types.builtins,\r\n  // Deprecated exports.\r\n  Protocol: services.Service,\r\n  assemble: util.deprecate(\r\n    specs.assembleProtocol,\r\n    'use `assembleProtocol` instead'\r\n  ),\r\n  combine: util.deprecate(\r\n    types.Type.forTypes,\r\n    'use `Type.forTypes` intead'\r\n  ),\r\n  infer: util.deprecate(\r\n    types.Type.forValue,\r\n    'use `Type.forValue` instead'\r\n  )\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/index.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/services.js":
/*!*******************************************!*\
  !*** ./node_modules/avsc/lib/services.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\r\n\r\n// TODO: Add broadcast option to client `_emitMessage`, accessible for one-way\r\n// messages.\r\n// TODO: Add `server.mount` method to allow combining servers. The API is as\r\n// follows: a mounted server's (i.e. the method's argument) handlers have lower\r\n// precedence than the original server (i.e. `this`); the mounted server's\r\n// middlewares are only invoked for its handlers.\r\n// TODO: Change `objectMode` client and server channel option to `encoding`\r\n// (accepting `'netty'`, `'standard'`, and `null` or `undefined`). Perhaps also\r\n// expose encoders (API TBD).\r\n\r\n\r\n\r\n/** This module implements Avro's IPC/RPC logic. */\r\n\r\nvar types = __webpack_require__(/*! ./types */ \"./node_modules/avsc/lib/types.js\"),\r\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\r\n    events = __webpack_require__(/*! events */ \"events\"),\r\n    stream = __webpack_require__(/*! stream */ \"stream\"),\r\n    util = __webpack_require__(/*! util */ \"util\");\r\n\r\n\r\n// A few convenience imports.\r\nvar Tap = utils.Tap;\r\nvar Type = types.Type;\r\nvar debug = util.debuglog('avsc:services');\r\nvar f = util.format;\r\n\r\n// Various useful types. We instantiate options once, to share the registry.\r\nvar OPTS = {namespace: 'org.apache.avro.ipc'};\r\n\r\nvar BOOLEAN_TYPE = Type.forSchema('boolean', OPTS);\r\n\r\nvar MAP_BYTES_TYPE = Type.forSchema({type: 'map', values: 'bytes'}, OPTS);\r\n\r\nvar STRING_TYPE = Type.forSchema('string', OPTS);\r\n\r\nvar HANDSHAKE_REQUEST_TYPE = Type.forSchema({\r\n  name: 'HandshakeRequest',\r\n  type: 'record',\r\n  fields: [\r\n    {name: 'clientHash', type: {name: 'MD5', type: 'fixed', size: 16}},\r\n    {name: 'clientProtocol', type: ['null', 'string'], 'default': null},\r\n    {name: 'serverHash', type: 'MD5'},\r\n    {name: 'meta', type: ['null', MAP_BYTES_TYPE], 'default': null}\r\n  ]\r\n}, OPTS);\r\n\r\nvar HANDSHAKE_RESPONSE_TYPE = Type.forSchema({\r\n  name: 'HandshakeResponse',\r\n  type: 'record',\r\n  fields: [\r\n    {\r\n      name: 'match',\r\n      type: {\r\n        name: 'HandshakeMatch',\r\n        type: 'enum',\r\n        symbols: ['BOTH', 'CLIENT', 'NONE']\r\n      }\r\n    },\r\n    {name: 'serverProtocol', type: ['null', 'string'], 'default': null},\r\n    {name: 'serverHash', type: ['null', 'MD5'], 'default': null},\r\n    {name: 'meta', type: ['null', MAP_BYTES_TYPE], 'default': null}\r\n  ]\r\n}, OPTS);\r\n\r\n// Prefix used to differentiate between messages when sharing a stream. This\r\n// length should be smaller than 16. The remainder is used for disambiguating\r\n// between concurrent messages (the current value, 16, therefore supports ~64k\r\n// concurrent messages).\r\nvar PREFIX_LENGTH = 16;\r\n\r\n// Internal message, used to check protocol compatibility.\r\nvar PING_MESSAGE = new Message(\r\n  '', // Empty name (invalid for other \"normal\" messages).\r\n  Type.forSchema({name: 'PingRequest', type: 'record', fields: []}, OPTS),\r\n  Type.forSchema(['string'], OPTS),\r\n  Type.forSchema('null', OPTS)\r\n);\r\n\r\n/** An Avro message, containing its request, response, etc. */\r\nfunction Message(name, reqType, errType, resType, oneWay, doc) {\r\n  this.name = name;\r\n  if (!Type.isType(reqType, 'record')) {\r\n    throw new Error('invalid request type');\r\n  }\r\n  this.requestType = reqType;\r\n  if (\r\n    !Type.isType(errType, 'union') ||\r\n    !Type.isType(errType.getTypes()[0], 'string')\r\n  ) {\r\n    throw new Error('invalid error type');\r\n  }\r\n  this.errorType = errType;\r\n  if (oneWay) {\r\n    if (!Type.isType(resType, 'null') || errType.getTypes().length > 1) {\r\n      throw new Error('inapplicable one-way parameter');\r\n    }\r\n  }\r\n  this.responseType = resType;\r\n  this.oneWay = !!oneWay;\r\n  this.doc = doc !== undefined ? '' + doc : undefined;\r\n  Object.freeze(this);\r\n}\r\n\r\nMessage.forSchema = function (name, schema, opts) {\r\n  opts = opts || {};\r\n  if (!utils.isValidName(name)) {\r\n    throw new Error(f('invalid message name: %s', name));\r\n  }\r\n  // We use a record with a placeholder name here (the user might have set\r\n  // `noAnonymousTypes`, so we can't use an anonymous one). We remove it from\r\n  // the registry afterwards to avoid exposing it outside.\r\n  if (!Array.isArray(schema.request)) {\r\n    throw new Error(f('invalid message request: %s', name));\r\n  }\r\n  var recordName = f('%s.%sRequest', OPTS.namespace, utils.capitalize(name));\r\n  var reqType = Type.forSchema({\r\n    name: recordName,\r\n    type: 'record',\r\n    namespace: opts.namespace || '', // Don't leak request namespace.\r\n    fields: schema.request\r\n  }, opts);\r\n  delete opts.registry[recordName];\r\n  if (!schema.response) {\r\n    throw new Error(f('invalid message response: %s', name));\r\n  }\r\n  var resType = Type.forSchema(schema.response, opts);\r\n  if (schema.errors !== undefined && !Array.isArray(schema.errors)) {\r\n    throw new Error(f('invalid message errors: %s', name));\r\n  }\r\n  var errType = Type.forSchema(['string'].concat(schema.errors || []), opts);\r\n  var oneWay = !!schema['one-way'];\r\n  return new Message(name, reqType, errType, resType, oneWay, schema.doc);\r\n};\r\n\r\nMessage.prototype.schema = Type.prototype.getSchema;\r\n\r\nMessage.prototype._attrs = function (opts) {\r\n  var reqSchema = this.requestType._attrs(opts);\r\n  var schema = {\r\n    request: reqSchema.fields,\r\n    response: this.responseType._attrs(opts)\r\n  };\r\n  var msgDoc = this.doc;\r\n  if (msgDoc !== undefined) {\r\n    schema.doc = msgDoc;\r\n  }\r\n  var errSchema = this.errorType._attrs(opts);\r\n  if (errSchema.length > 1) {\r\n    schema.errors = errSchema.slice(1);\r\n  }\r\n  if (this.oneWay) {\r\n    schema['one-way'] = true;\r\n  }\r\n  return schema;\r\n};\r\n\r\n// Deprecated.\r\n\r\nutils.addDeprecatedGetters(\r\n  Message,\r\n  ['name', 'errorType', 'requestType', 'responseType']\r\n);\r\n\r\nMessage.prototype.isOneWay = util.deprecate(\r\n  function () { return this.oneWay; },\r\n  'use `.oneWay` directly instead of `.isOneWay()`'\r\n);\r\n\r\n/**\r\n * An Avro RPC service.\r\n *\r\n * This constructor shouldn't be called directly, but via the\r\n * `Service.forProtocol` method. This function performs little logic to better\r\n * support efficient copy.\r\n */\r\nfunction Service(name, messages, types, ptcl, server) {\r\n  if (typeof name != 'string') {\r\n    // Let's be helpful in case this class is instantiated directly.\r\n    return Service.forProtocol(name, messages);\r\n  }\r\n\r\n  this.name = name;\r\n  this._messagesByName = messages || {};\r\n  this.messages = Object.freeze(utils.objectValues(this._messagesByName));\r\n\r\n  this._typesByName = types || {};\r\n  this.types = Object.freeze(utils.objectValues(this._typesByName));\r\n\r\n  this.protocol = ptcl;\r\n  // We cache a string rather than a buffer to not retain an entire slab.\r\n  this._hashStr = utils.getHash(JSON.stringify(ptcl)).toString('binary');\r\n  this.doc = ptcl.doc ? '' + ptcl.doc : undefined;\r\n\r\n  // We add a server to each protocol for backwards-compatibility (to allow the\r\n  // use of `protocol.on`). This covers all cases except the use of the\r\n  // `strictErrors` option, which requires moving to the new API.\r\n  this._server = server || this.createServer({silent: true});\r\n  Object.freeze(this);\r\n}\r\n\r\nService.Client = Client;\r\n\r\nService.Server = Server;\r\n\r\nService.compatible = function (clientSvc, serverSvc) {\r\n  try {\r\n    createReaders(clientSvc, serverSvc);\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\nService.forProtocol = function (ptcl, opts) {\r\n  opts = opts || {};\r\n\r\n  var name = ptcl.protocol;\r\n  if (!name) {\r\n    throw new Error('missing protocol name');\r\n  }\r\n  if (ptcl.namespace !== undefined) {\r\n    opts.namespace = ptcl.namespace;\r\n  } else {\r\n    var match = /^(.*)\\.[^.]+$/.exec(name);\r\n    if (match) {\r\n      opts.namespace = match[1];\r\n    }\r\n  }\r\n  name = utils.qualify(name, opts.namespace);\r\n\r\n  if (ptcl.types) {\r\n    ptcl.types.forEach(function (obj) { Type.forSchema(obj, opts); });\r\n  }\r\n  var msgs;\r\n  if (ptcl.messages) {\r\n    msgs = {};\r\n    Object.keys(ptcl.messages).forEach(function (key) {\r\n      msgs[key] = Message.forSchema(key, ptcl.messages[key], opts);\r\n    });\r\n  }\r\n\r\n  return new Service(name, msgs, opts.registry, ptcl);\r\n};\r\n\r\nService.isService = function (any) {\r\n  // Not fool-proof but likely sufficient.\r\n  return !!any && any.hasOwnProperty('_hashStr');\r\n};\r\n\r\nService.prototype.createClient = function (opts) {\r\n  var client = new Client(this, opts);\r\n  process.nextTick(function () {\r\n    // We delay this processing such that we can attach handlers to the client\r\n    // before any channels get created.\r\n    if (opts && opts.server) {\r\n      // Convenience in-memory client. This can be useful to make requests\r\n      // relatively efficiently to an in-process server. Note that it is still\r\n      // is less efficient than direct method calls (because of the\r\n      // serialization, which does provide \"type-safety\" though).\r\n      var obj = {objectMode: true};\r\n      var pts = [new stream.PassThrough(obj), new stream.PassThrough(obj)];\r\n      opts.server.createChannel({readable: pts[0], writable: pts[1]}, obj);\r\n      client.createChannel({readable: pts[1], writable: pts[0]}, obj);\r\n    } else if (opts && opts.transport) {\r\n      // Convenience functionality for the common single channel use-case: we\r\n      // add a single channel using default options to the client.\r\n      client.createChannel(opts.transport);\r\n    }\r\n  });\r\n  return client;\r\n};\r\n\r\nService.prototype.createServer = function (opts) {\r\n  return new Server(this, opts);\r\n};\r\n\r\nObject.defineProperty(Service.prototype, 'hash', {\r\n  enumerable: true,\r\n  get: function () { return utils.bufferFrom(this._hashStr, 'binary'); }\r\n});\r\n\r\nService.prototype.message = function (name) {\r\n  return this._messagesByName[name];\r\n};\r\n\r\nService.prototype.type = function (name) {\r\n  return this._typesByName[name];\r\n};\r\n\r\nService.prototype.inspect = function () {\r\n  return f('<Service %j>', this.name);\r\n};\r\n\r\n// Deprecated methods.\r\n\r\nutils.addDeprecatedGetters(\r\n  Service,\r\n  ['message', 'messages', 'name', 'type', 'types']\r\n);\r\n\r\nService.prototype.createEmitter = util.deprecate(\r\n  function (transport, opts) {\r\n    opts = opts || {};\r\n    var client = this.createClient({\r\n      cache: opts.cache,\r\n      buffering: false,\r\n      strictTypes: opts.strictErrors,\r\n      timeout: opts.timeout\r\n    });\r\n    var channel = client.createChannel(transport, opts);\r\n    forwardErrors(client, channel);\r\n    return channel;\r\n  },\r\n  'use `.createClient()` instead of `.createEmitter()`'\r\n);\r\n\r\nService.prototype.createListener = util.deprecate(\r\n  function (transport, opts) {\r\n    if (opts && opts.strictErrors) {\r\n      throw new Error('use `.createServer()` to support strict errors');\r\n    }\r\n    return this._server.createChannel(transport, opts);\r\n  },\r\n  'use `.createServer().createChannel()` instead of `.createListener()`'\r\n);\r\n\r\nService.prototype.emit = util.deprecate(\r\n  function (name, req, channel, cb) {\r\n    if (!channel || !this.equals(channel.client._svc$)) {\r\n      throw new Error('invalid emitter');\r\n    }\r\n\r\n    var client = channel.client;\r\n    // In case the method is overridden.\r\n    Client.prototype.emitMessage.call(client, name, req, cb && cb.bind(this));\r\n    return channel.getPending();\r\n  },\r\n  'create a client via `.createClient()` to emit messages instead of `.emit()`'\r\n);\r\n\r\nService.prototype.equals = util.deprecate(\r\n  function (any) {\r\n    return (\r\n      Service.isService(any) &&\r\n      this.getFingerprint().equals(any.getFingerprint())\r\n    );\r\n  },\r\n  'equality testing is deprecated, compare the `.protocol`s instead'\r\n);\r\n\r\nService.prototype.getFingerprint = util.deprecate(\r\n  function (algorithm) {\r\n    return utils.getHash(JSON.stringify(this.protocol), algorithm);\r\n  },\r\n  'use `.hash` instead of `.getFingerprint()`'\r\n);\r\n\r\nService.prototype.getSchema = util.deprecate(\r\n  Type.prototype.getSchema,\r\n  'use `.protocol` instead of `.getSchema()`'\r\n);\r\n\r\nService.prototype.on = util.deprecate(\r\n  function (name, handler) {\r\n    var self = this; // This protocol.\r\n    this._server.onMessage(name, function (req, cb) {\r\n      return handler.call(self, req, this.channel, cb);\r\n    });\r\n    return this;\r\n  },\r\n  'use `.createServer().onMessage()` instead of `.on()`'\r\n);\r\n\r\nService.prototype.subprotocol = util.deprecate(\r\n  function () {\r\n    var parent = this._server;\r\n    var opts = {strictTypes: parent._strict, cache: parent._cache};\r\n    var server = new Server(parent.service, opts);\r\n    server._handlers = Object.create(parent._handlers);\r\n    return new Service(\r\n      this.name,\r\n      this._messagesByName,\r\n      this._typesByName,\r\n      this.protocol,\r\n      server\r\n    );\r\n  },\r\n  '`.subprotocol()` will be removed in 5.1'\r\n);\r\n\r\nService.prototype._attrs = function (opts) {\r\n  var ptcl = {protocol: this.name};\r\n\r\n  var types = [];\r\n  this.types.forEach(function (t) {\r\n    if (t.getName() === undefined) {\r\n      // Don't include any unnamed types (e.g. primitives).\r\n      return;\r\n    }\r\n    var typeSchema = t._attrs(opts);\r\n    if (typeof typeSchema != 'string') {\r\n      // Some of the named types might already have been defined in a\r\n      // previous type, in this case we don't include its reference.\r\n      types.push(typeSchema);\r\n    }\r\n  });\r\n  if (types.length) {\r\n    ptcl.types = types;\r\n  }\r\n\r\n  var msgNames = Object.keys(this._messagesByName);\r\n  if (msgNames.length) {\r\n    ptcl.messages = {};\r\n    msgNames.forEach(function (name) {\r\n      ptcl.messages[name] = this._messagesByName[name]._attrs(opts);\r\n    }, this);\r\n  }\r\n\r\n  if (opts && opts.exportAttrs && this.doc !== undefined) {\r\n    ptcl.doc = this.doc;\r\n  }\r\n  return ptcl;\r\n};\r\n\r\n/** Function to retrieve a remote service's protocol. */\r\nfunction discoverProtocol(transport, opts, cb) {\r\n  if (cb === undefined && typeof opts == 'function') {\r\n    cb = opts;\r\n    opts = undefined;\r\n  }\r\n\r\n  var svc = new Service({protocol: 'Empty'}, OPTS);\r\n  var ptclStr;\r\n  svc.createClient({timeout: opts && opts.timeout})\r\n    .createChannel(transport, {\r\n      scope: opts && opts.scope,\r\n      endWritable: typeof transport == 'function' // Stateless transports only.\r\n    }).once('handshake', function (hreq, hres) {\r\n        ptclStr = hres.serverProtocol;\r\n        this.destroy(true);\r\n      })\r\n      .once('eot', function (pending, err) {\r\n        // Stateless transports will throw an interrupted error when the\r\n        // channel is destroyed, we ignore it here.\r\n        if (err && !/interrupted/.test(err)) {\r\n          cb(err); // Likely timeout.\r\n        } else {\r\n          cb(null, JSON.parse(ptclStr));\r\n        }\r\n      });\r\n}\r\n\r\n/** Load-balanced message sender. */\r\nfunction Client(svc, opts) {\r\n  opts = opts || {};\r\n  events.EventEmitter.call(this);\r\n\r\n  // We have to suffix all client properties to be safe, since the message\r\n  // names aren't prefixed with clients (unlike servers).\r\n  this._svc$ = svc;\r\n  this._channels$ = []; // Active channels.\r\n  this._fns$ = []; // Middleware functions.\r\n\r\n  this._buffering$ = !!opts.buffering;\r\n  this._cache$ = opts.cache || {}; // For backwards compatibility.\r\n  this._policy$ = opts.channelPolicy;\r\n  this._strict$ = !!opts.strictTypes;\r\n  this._timeout$ = utils.getOption(opts, 'timeout', 10000);\r\n\r\n  if (opts.remoteProtocols) {\r\n    insertRemoteProtocols(this._cache$, opts.remoteProtocols, svc, true);\r\n  }\r\n\r\n  this._svc$.messages.forEach(function (msg) {\r\n    this[msg.name] = this._createMessageHandler$(msg);\r\n  }, this);\r\n}\r\nutil.inherits(Client, events.EventEmitter);\r\n\r\nClient.prototype.activeChannels = function () {\r\n  return this._channels$.slice();\r\n};\r\n\r\nClient.prototype.createChannel = function (transport, opts) {\r\n  var objectMode = opts && opts.objectMode;\r\n  var channel;\r\n  if (typeof transport == 'function') {\r\n    var writableFactory;\r\n    if (objectMode) {\r\n      writableFactory = transport;\r\n    } else {\r\n      // We provide a default standard-compliant codec. This should support\r\n      // most use-cases (for example when speaking to the official Java and\r\n      // Python implementations over HTTP, or when this library is used for\r\n      // both the emitting and listening sides).\r\n      writableFactory = function (cb) {\r\n        var encoder = new FrameEncoder();\r\n        var writable = transport(function (err, readable) {\r\n          if (err) {\r\n            cb(err);\r\n            return;\r\n          }\r\n          // Since the decoder isn't exposed (so can't have an error handler\r\n          // attached, we forward any errors to the client). Since errors would\r\n          // only get thrown when the decoder flushes (if there is trailing\r\n          // data), at which point the source will have ended, there is no need\r\n          // to add re-piping logic (destination errors trigger an unpipe).\r\n          var decoder = new FrameDecoder()\r\n            .once('error', function (err) { channel.destroy(err); });\r\n          cb(null, readable.pipe(decoder));\r\n        });\r\n        if (writable) {\r\n          encoder.pipe(writable);\r\n          return encoder;\r\n        }\r\n      };\r\n    }\r\n    channel = new StatelessClientChannel(this, writableFactory, opts);\r\n  } else {\r\n    var readable, writable;\r\n    if (isStream(transport)) {\r\n      readable = writable = transport;\r\n    } else {\r\n      readable = transport.readable;\r\n      writable = transport.writable;\r\n    }\r\n    if (!objectMode) {\r\n      // To ease communication with Java servers, we provide a default codec\r\n      // compatible with Java servers' `NettyTransportCodec`'s implementation.\r\n      var decoder = new NettyDecoder();\r\n      readable = readable.pipe(decoder);\r\n      var encoder = new NettyEncoder();\r\n      encoder.pipe(writable);\r\n      writable = encoder;\r\n    }\r\n    channel = new StatefulClientChannel(this, readable, writable, opts);\r\n    if (!objectMode) {\r\n      // Since we never expose the automatically created encoder and decoder,\r\n      // we release them ourselves here when the channel ends. (Unlike for\r\n      // stateless channels, it is conceivable for the underlying stream to be\r\n      // reused afterwards).\r\n      channel.once('eot', function () {\r\n        readable.unpipe(decoder);\r\n        encoder.unpipe(writable);\r\n      });\r\n      // We also forward any (trailing data) error.\r\n      decoder.once('error', function (err) { channel.destroy(err); });\r\n    }\r\n  }\r\n  var channels = this._channels$;\r\n  channels.push(channel);\r\n  channel.once('_drain', function () {\r\n    // Remove the channel from the list of active ones.\r\n    channels.splice(channels.indexOf(this), 1);\r\n  });\r\n  // We restrict buffering to startup, otherwise we risk silently hiding errors\r\n  // (especially since channel timeouts don't apply yet).\r\n  this._buffering$ = false;\r\n  this.emit('channel', channel);\r\n  return channel;\r\n};\r\n\r\nClient.prototype.destroyChannels = function (opts) {\r\n  this._channels$.forEach(function (channel) {\r\n    channel.destroy(opts && opts.noWait);\r\n  });\r\n};\r\n\r\nClient.prototype.emitMessage = function (name, req, opts, cb) {\r\n  var msg = getExistingMessage(this._svc$, name);\r\n  var wreq = new WrappedRequest(msg, {}, req);\r\n  this._emitMessage$(wreq, opts, cb);\r\n};\r\n\r\nClient.prototype.remoteProtocols = function () {\r\n  return getRemoteProtocols(this._cache$, true);\r\n};\r\n\r\nObject.defineProperty(Client.prototype, 'service', {\r\n  enumerable: true,\r\n  get: function () { return this._svc$; }\r\n});\r\n\r\nClient.prototype.use = function (/* fn ... */) {\r\n  var i, l, fn;\r\n  for (i = 0, l = arguments.length; i < l; i++) {\r\n    fn = arguments[i];\r\n    this._fns$.push(fn.length < 3 ? fn(this) : fn);\r\n  }\r\n  return this;\r\n};\r\n\r\nClient.prototype._emitMessage$ = function (wreq, opts, cb) {\r\n  // Common logic between `client.emitMessage` and the \"named\" message methods.\r\n  if (!cb && typeof opts === 'function') {\r\n    cb = opts;\r\n    opts = undefined;\r\n  }\r\n  var self = this;\r\n  var channels = this._channels$;\r\n  var numChannels = channels.length;\r\n  if (!numChannels) {\r\n    if (this._buffering$) {\r\n      debug('no active client channels, buffering call');\r\n      this.once('channel', function () {\r\n        this._emitMessage$(wreq, opts, cb);\r\n      });\r\n    } else {\r\n      var err = new Error('no active channels');\r\n      process.nextTick(function () {\r\n        if (cb) {\r\n          cb.call(new CallContext(wreq._msg), err);\r\n        } else {\r\n          self.emit('error', err);\r\n        }\r\n      });\r\n    }\r\n    return;\r\n  }\r\n\r\n  opts = opts || {};\r\n  if (opts.timeout === undefined) {\r\n    opts.timeout = this._timeout$;\r\n  }\r\n\r\n  var channel;\r\n  if (numChannels === 1) {\r\n    // Common case, optimized away.\r\n    channel = channels[0];\r\n  } else if (this._policy$) {\r\n    channel = this._policy$(this._channels$.slice());\r\n    if (!channel) {\r\n      debug('policy returned no channel, skipping call');\r\n      return;\r\n    }\r\n  } else {\r\n    // Random selection, cheap and likely good enough for most use-cases.\r\n    channel = channels[Math.floor(Math.random() * numChannels)];\r\n  }\r\n\r\n  channel._emit(wreq, opts, function (err, wres) {\r\n    var ctx = this; // Call context.\r\n    var errType = ctx.message.errorType;\r\n    if (err) {\r\n      // System error, likely the message wasn't sent (or an error occurred\r\n      // while decoding the response).\r\n      if (self._strict$) {\r\n        err = errType.clone(err.message, {wrapUnions: true});\r\n      }\r\n      done(err);\r\n      return;\r\n    }\r\n    if (!wres) {\r\n      // This is a one way message.\r\n      done();\r\n      return;\r\n    }\r\n    // Message transmission succeeded, we transmit the message data; massaging\r\n    // any error strings into actual `Error` objects in non-strict mode.\r\n    err = wres.error;\r\n    if (!self._strict$) {\r\n      // Try to coerce an eventual error into more idiomatic JavaScript types:\r\n      // `undefined` becomes `null` and a remote string \"system\" error is\r\n      // wrapped inside an actual `Error` object.\r\n      if (err === undefined) {\r\n        err = null;\r\n      } else {\r\n        if (Type.isType(errType, 'union:unwrapped')) {\r\n          if (typeof err == 'string') {\r\n            err = new Error(err);\r\n          }\r\n        } else if (err && err.string && typeof err.string == 'string') {\r\n          err = new Error(err.string);\r\n        }\r\n      }\r\n    }\r\n    done(err, wres.response);\r\n\r\n    function done(err, res) {\r\n      if (cb) {\r\n        cb.call(ctx, err, res);\r\n      } else if (err) {\r\n        self.emit('error', err);\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nClient.prototype._createMessageHandler$ = function (msg) {\r\n  // jshint -W054\r\n  var fields = msg.requestType.getFields();\r\n  var names = fields.map(function (f) { return f.getName(); });\r\n  var body = 'return function ' + msg.name + '(';\r\n  if (names.length) {\r\n    body += names.join(', ') + ', ';\r\n  }\r\n  body += 'opts, cb) {\\n';\r\n  body += '  var req = {';\r\n  body += names.map(function (n) { return n + ': ' + n; }).join(', ');\r\n  body += '};\\n';\r\n  body += '  return this.emitMessage(\\'' + msg.name + '\\', req, opts, cb);\\n';\r\n  body += '};';\r\n  return (new Function(body))();\r\n};\r\n\r\n/** Message receiver. */\r\nfunction Server(svc, opts) {\r\n  opts = opts || {};\r\n  events.EventEmitter.call(this);\r\n\r\n  this.service = svc;\r\n  this._handlers = {};\r\n  this._fns = []; // Middleware functions.\r\n  this._channels = {}; // Active channels.\r\n  this._nextChannelId = 1;\r\n\r\n  this._cache = opts.cache || {}; // Deprecated.\r\n  this._defaultHandler = opts.defaultHandler;\r\n  this._sysErrFormatter = opts.systemErrorFormatter;\r\n  this._silent = !!opts.silent;\r\n  this._strict = !!opts.strictTypes;\r\n\r\n  if (opts.remoteProtocols) {\r\n    insertRemoteProtocols(this._cache, opts.remoteProtocols, svc, false);\r\n  }\r\n\r\n  svc.messages.forEach(function (msg) {\r\n    var name = msg.name;\r\n    if (!opts.noCapitalize) {\r\n      name = utils.capitalize(name);\r\n    }\r\n    this['on' + name] = this._createMessageHandler(msg);\r\n  }, this);\r\n}\r\nutil.inherits(Server, events.EventEmitter);\r\n\r\nServer.prototype.activeChannels = function () {\r\n  return utils.objectValues(this._channels);\r\n};\r\n\r\nServer.prototype.createChannel = function (transport, opts) {\r\n  var objectMode = opts && opts.objectMode;\r\n  var channel;\r\n  if (typeof transport == 'function') {\r\n    var readableFactory;\r\n    if (objectMode) {\r\n      readableFactory = transport;\r\n    } else {\r\n      readableFactory = function (cb) {\r\n        var decoder = new FrameDecoder()\r\n          .once('error', function (err) { channel.destroy(err); });\r\n        return transport(function (err, writable) {\r\n          if (err) {\r\n            cb(err);\r\n            return;\r\n          }\r\n          var encoder = new FrameEncoder();\r\n          encoder.pipe(writable);\r\n          cb(null, encoder);\r\n        }).pipe(decoder);\r\n      };\r\n    }\r\n    channel = new StatelessServerChannel(this, readableFactory, opts);\r\n  } else {\r\n    var readable, writable;\r\n    if (isStream(transport)) {\r\n      readable = writable = transport;\r\n    } else {\r\n      readable = transport.readable;\r\n      writable = transport.writable;\r\n    }\r\n    if (!objectMode) {\r\n      var decoder = new NettyDecoder();\r\n      readable = readable.pipe(decoder);\r\n      var encoder = new NettyEncoder();\r\n      encoder.pipe(writable);\r\n      writable = encoder;\r\n    }\r\n    channel = new StatefulServerChannel(this, readable, writable, opts);\r\n    if (!objectMode) {\r\n      // Similar to client channels, since we never expose the encoder and\r\n      // decoder, we must release them ourselves here.\r\n      channel.once('eot', function () {\r\n        readable.unpipe(decoder);\r\n        encoder.unpipe(writable);\r\n      });\r\n      decoder.once('error', function (err) { channel.destroy(err); });\r\n    }\r\n  }\r\n\r\n  if (!this.listeners('error').length) {\r\n    this.on('error', this._onError);\r\n  }\r\n  var channelId = this._nextChannelId++;\r\n  var channels = this._channels;\r\n  channels[channelId] = channel\r\n    .once('eot', function () { delete channels[channelId]; });\r\n  this.emit('channel', channel);\r\n  return channel;\r\n};\r\n\r\nServer.prototype.onMessage = function (name, handler) {\r\n  getExistingMessage(this.service, name); // Check message existence.\r\n  this._handlers[name] = handler;\r\n  return this;\r\n};\r\n\r\nServer.prototype.remoteProtocols = function () {\r\n  return getRemoteProtocols(this._cache, false);\r\n};\r\n\r\nServer.prototype.use = function (/* fn ... */) {\r\n  var i, l, fn;\r\n  for (i = 0, l = arguments.length; i < l; i++) {\r\n    fn = arguments[i];\r\n    this._fns.push(fn.length < 3 ? fn(this) : fn);\r\n  }\r\n  return this;\r\n};\r\n\r\nServer.prototype._createMessageHandler = function (msg) {\r\n  // jshint -W054\r\n  var name = msg.name;\r\n  var fields = msg.requestType.fields;\r\n  var numArgs = fields.length;\r\n  var args = fields.length ?\r\n    ', ' + fields.map(function (f) { return 'req.' + f.name; }).join(', ') :\r\n    '';\r\n  // We are careful to not lose the initial handler's number of arguments (or\r\n  // more specifically whether it would have access to the callback or not).\r\n  // This is useful to implement \"smart promisification\" logic downstream.\r\n  var body = 'return function (handler) {\\n';\r\n  body += '  if (handler.length > ' + numArgs + ') {\\n';\r\n  body += '    return this.onMessage(\\'' + name + '\\', function (req, cb) {\\n';\r\n  body += '      return handler.call(this' + args + ', cb);\\n';\r\n  body += '    });\\n';\r\n  body += '  } else {\\n';\r\n  body += '    return this.onMessage(\\'' + name + '\\', function (req) {\\n';\r\n  body += '      return handler.call(this' + args + ');\\n';\r\n  body += '    });\\n';\r\n  body += '  }\\n';\r\n  body += '};\\n';\r\n  return (new Function(body))();\r\n};\r\n\r\nServer.prototype._onError = function (err) {\r\n  /* istanbul ignore if */\r\n  if (!this._silent && err.rpcCode !== 'UNKNOWN_PROTOCOL') {\r\n    console.error();\r\n    if (err.rpcCode) {\r\n      console.error(err.rpcCode);\r\n      console.error(err.cause);\r\n    } else {\r\n      console.error('INTERNAL_SERVER_ERROR');\r\n      console.error(err);\r\n    }\r\n  }\r\n};\r\n\r\n/** Base message emitter class. See below for the two available variants. */\r\nfunction ClientChannel(client, opts) {\r\n  opts = opts || {};\r\n  events.EventEmitter.call(this);\r\n\r\n  this.client = client;\r\n  this.timeout = utils.getOption(opts, 'timeout', client._timeout$);\r\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\r\n  this._prefix = normalizedPrefix(opts.scope);\r\n\r\n  var cache = client._cache$;\r\n  var clientSvc = client._svc$;\r\n  var hash = opts.serverHash;\r\n  if (!hash) {\r\n    hash = clientSvc.hash;\r\n  }\r\n  var adapter = cache[hash];\r\n  if (!adapter) {\r\n    // This might happen even if the server hash option was set if the cache\r\n    // doesn't contain the corresponding adapter. In this case we fall back to\r\n    // the client's protocol (as mandated by the spec).\r\n    hash = clientSvc.hash;\r\n    adapter = cache[hash] = new Adapter(clientSvc, clientSvc, hash);\r\n  }\r\n  this._adapter = adapter;\r\n\r\n  this._registry = new Registry(this, PREFIX_LENGTH);\r\n  this.pending = 0;\r\n  this.destroyed = false;\r\n  this.draining = false;\r\n  this.once('_eot', function (pending, err) {\r\n    // Since this listener is only run once, we will only forward an error if\r\n    // it is present during the initial `destroy` call, which is OK.\r\n    debug('client channel EOT');\r\n    this.destroyed = true;\r\n    this.emit('eot', pending, err);\r\n  });\r\n}\r\nutil.inherits(ClientChannel, events.EventEmitter);\r\n\r\nClientChannel.prototype.destroy = function (noWait) {\r\n  debug('destroying client channel');\r\n  if (!this.draining) {\r\n    this.draining = true;\r\n    this.emit('_drain');\r\n  }\r\n  var registry = this._registry;\r\n  var pending = this.pending;\r\n  if (noWait) {\r\n    registry.clear();\r\n  }\r\n  if (noWait || !pending) {\r\n    if (isError(noWait)) {\r\n      debug('fatal client channel error: %s', noWait);\r\n      this.emit('_eot', pending, noWait);\r\n    } else {\r\n      this.emit('_eot', pending);\r\n    }\r\n  } else {\r\n    debug('client channel entering drain mode (%s pending)', pending);\r\n  }\r\n};\r\n\r\nClientChannel.prototype.ping = function (timeout, cb) {\r\n  if (!cb && typeof timeout == 'function') {\r\n    cb = timeout;\r\n    timeout = undefined;\r\n  }\r\n  var self = this;\r\n  var wreq = new WrappedRequest(PING_MESSAGE);\r\n  this._emit(wreq, {timeout: timeout}, function (err) {\r\n    if (cb) {\r\n      cb.call(self, err);\r\n    } else if (err) {\r\n      self.destroy(err);\r\n    }\r\n  });\r\n};\r\n\r\nClientChannel.prototype._createHandshakeRequest = function (adapter, noSvc) {\r\n  var svc = this.client._svc$;\r\n  return {\r\n    clientHash: svc.hash,\r\n    clientProtocol: noSvc ? null : JSON.stringify(svc.protocol),\r\n    serverHash: adapter._hash\r\n  };\r\n};\r\n\r\nClientChannel.prototype._emit = function (wreq, opts, cb) {\r\n  var msg = wreq._msg;\r\n  var wres = msg.oneWay ? undefined : new WrappedResponse(msg, {});\r\n  var ctx = new CallContext(msg, this);\r\n  var self = this;\r\n  this.pending++;\r\n  process.nextTick(function () {\r\n    if (!msg.name) {\r\n      // Ping request, bypass middleware.\r\n      onTransition(wreq, wres, onCompletion);\r\n    } else {\r\n      self.emit('outgoingCall', ctx, opts);\r\n      var fns = self.client._fns$;\r\n      debug('starting client middleware chain (%s middleware)', fns.length);\r\n      chainMiddleware({\r\n        fns: fns,\r\n        ctx: ctx,\r\n        wreq: wreq,\r\n        wres: wres,\r\n        onTransition: onTransition,\r\n        onCompletion: onCompletion,\r\n        onError: onError\r\n      });\r\n    }\r\n  });\r\n\r\n  function onTransition(wreq, wres, prev) {\r\n    // Serialize the message.\r\n    var err, reqBuf;\r\n    if (self.destroyed) {\r\n      err = new Error('channel destroyed');\r\n    } else {\r\n      try {\r\n        reqBuf = wreq.toBuffer();\r\n      } catch (cause) {\r\n        err = serializationError(\r\n          f('invalid %j request', msg.name),\r\n          wreq,\r\n          [\r\n            {name: 'headers', type: MAP_BYTES_TYPE},\r\n            {name: 'request', type: msg.requestType}\r\n          ]\r\n        );\r\n      }\r\n    }\r\n    if (err) {\r\n      prev(err);\r\n      return;\r\n    }\r\n\r\n    // Generate the response callback.\r\n    var timeout = (opts && opts.timeout !== undefined) ?\r\n      opts.timeout :\r\n      self.timeout;\r\n    var id = self._registry.add(timeout, function (err, resBuf, adapter) {\r\n      if (!err && !msg.oneWay) {\r\n        try {\r\n          adapter._decodeResponse(resBuf, wres, msg);\r\n        } catch (cause) {\r\n          err = cause;\r\n        }\r\n      }\r\n      prev(err);\r\n    });\r\n    id |= self._prefix;\r\n\r\n    debug('sending message %s', id);\r\n    self._send(id, reqBuf, !!msg && msg.oneWay);\r\n  }\r\n\r\n  function onCompletion(err) {\r\n    self.pending--;\r\n    cb.call(ctx, err, wres);\r\n    if (self.draining && !self.destroyed && !self.pending) {\r\n      self.destroy();\r\n    }\r\n  }\r\n\r\n  function onError(err) {\r\n    // This will happen if a middleware callback is called multiple times. We\r\n    // forward the error to the client rather than emit it on the channel since\r\n    // middleware are a client-level abstraction, so better handled there.\r\n    self.client.emit('error', err, self);\r\n  }\r\n};\r\n\r\nClientChannel.prototype._getAdapter = function (hres) {\r\n  var hash = hres.serverHash;\r\n  var cache = this.client._cache$;\r\n  var adapter = cache[hash];\r\n  if (adapter) {\r\n    return adapter;\r\n  }\r\n  var ptcl = JSON.parse(hres.serverProtocol);\r\n  var serverSvc = Service.forProtocol(ptcl);\r\n  adapter = new Adapter(this.client._svc$, serverSvc, hash, true);\r\n  return cache[hash] = adapter;\r\n};\r\n\r\nClientChannel.prototype._matchesPrefix = function (id) {\r\n  return matchesPrefix(id, this._prefix);\r\n};\r\n\r\nClientChannel.prototype._send = utils.abstractFunction;\r\n\r\n// Deprecated.\r\n\r\nutils.addDeprecatedGetters(ClientChannel, ['pending', 'timeout']);\r\n\r\nClientChannel.prototype.getCache = util.deprecate(\r\n  function () { return this.client._cache$; },\r\n  'use `.remoteProtocols()` instead of `.getCache()`'\r\n);\r\n\r\nClientChannel.prototype.getProtocol = util.deprecate(\r\n  function () {\r\n    return this.client._svc$;\r\n  },\r\n  'use `.service` instead or `.getProtocol()`'\r\n);\r\n\r\nClientChannel.prototype.isDestroyed = util.deprecate(\r\n  function () { return this.destroyed; },\r\n  'use `.destroyed` instead of `.isDestroyed`'\r\n);\r\n\r\n/**\r\n * Factory-based client channel.\r\n *\r\n * This channel doesn't keep a persistent connection to the server and requires\r\n * prepending a handshake to each message emitted. Usage examples include\r\n * talking to an HTTP server (where the factory returns an HTTP request).\r\n *\r\n * Since each message will use its own writable/readable stream pair, the\r\n * advantage of this channel is that it is able to keep track of which response\r\n * corresponds to each request without relying on transport ordering. In\r\n * particular, this means these channels are compatible with any server\r\n * implementation.\r\n */\r\nfunction StatelessClientChannel(client, writableFactory, opts) {\r\n  ClientChannel.call(this, client, opts);\r\n  this._writableFactory = writableFactory;\r\n\r\n  if (!opts || !opts.noPing) {\r\n    // Ping the server to check whether the remote protocol is compatible.\r\n    // If not, this will throw an error on the channel.\r\n    debug('emitting ping request');\r\n    this.ping();\r\n  }\r\n}\r\nutil.inherits(StatelessClientChannel, ClientChannel);\r\n\r\nStatelessClientChannel.prototype._send = function (id, reqBuf) {\r\n  var cb = this._registry.get(id);\r\n  var adapter = this._adapter;\r\n  var self = this;\r\n  process.nextTick(emit);\r\n  return true;\r\n\r\n  function emit(retry) {\r\n    if (self.destroyed) {\r\n      // The request's callback will already have been called.\r\n      return;\r\n    }\r\n\r\n    var hreq = self._createHandshakeRequest(adapter, !retry);\r\n\r\n    var writable = self._writableFactory.call(self, function (err, readable) {\r\n      if (err) {\r\n        cb(err);\r\n        return;\r\n      }\r\n      readable.on('data', function (obj) {\r\n        debug('received response %s', obj.id);\r\n        // We don't check that the prefix matches since the ID likely hasn't\r\n        // been propagated to the response (see default stateless codec).\r\n        var buf = Buffer.concat(obj.payload);\r\n        try {\r\n          var parts = readHead(HANDSHAKE_RESPONSE_TYPE, buf);\r\n          var hres = parts.head;\r\n          if (hres.serverHash) {\r\n            adapter = self._getAdapter(hres);\r\n          }\r\n        } catch (cause) {\r\n          cb(cause);\r\n          return;\r\n        }\r\n        var match = hres.match;\r\n        debug('handshake match: %s', match);\r\n        self.emit('handshake', hreq, hres);\r\n        if (match === 'NONE') {\r\n          // Try again, including the full protocol this time.\r\n          process.nextTick(function() { emit(true); });\r\n        } else {\r\n          // Change the default adapter.\r\n          self._adapter = adapter;\r\n          cb(null, parts.tail, adapter);\r\n        }\r\n      });\r\n    });\r\n    if (!writable) {\r\n      cb(new Error('invalid writable stream'));\r\n      return;\r\n    }\r\n    writable.write({\r\n      id: id,\r\n      payload: [HANDSHAKE_REQUEST_TYPE.toBuffer(hreq), reqBuf]\r\n    });\r\n    if (self._endWritable) {\r\n      writable.end();\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Multiplexing client channel.\r\n *\r\n * These channels reuse the same streams (both readable and writable) for all\r\n * messages. This avoids a lot of overhead (e.g. creating new connections,\r\n * re-issuing handshakes) but requires the underlying transport to support\r\n * forwarding message IDs.\r\n */\r\nfunction StatefulClientChannel(client, readable, writable, opts) {\r\n  ClientChannel.call(this, client, opts);\r\n  this._readable = readable;\r\n  this._writable = writable;\r\n  this._connected = !!(opts && opts.noPing);\r\n  this._readable.on('end', onEnd);\r\n  this._writable.on('finish', onFinish);\r\n\r\n  var self = this;\r\n  var timer = null;\r\n  this.once('eot', function () {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      timer = null;\r\n    }\r\n    if (!self._connected) {\r\n      // Clear any buffered calls (they are guaranteed to error out when\r\n      // reaching the transition phase).\r\n      self.emit('_ready');\r\n    }\r\n    // Remove references to this channel to avoid potential memory leaks.\r\n    this._writable.removeListener('finish', onFinish);\r\n    if (this._endWritable) {\r\n      debug('ending transport');\r\n      this._writable.end();\r\n    }\r\n    this._readable\r\n      .removeListener('data', onPing)\r\n      .removeListener('data', onMessage)\r\n      .removeListener('end', onEnd);\r\n  });\r\n\r\n  var hreq; // For handshake events.\r\n  if (this._connected) {\r\n    this._readable.on('data', onMessage);\r\n  } else {\r\n    this._readable.on('data', onPing);\r\n    process.nextTick(ping);\r\n    if (self.timeout) {\r\n      timer = setTimeout(function () {\r\n        self.destroy(new Error('timeout'));\r\n      }, self.timeout);\r\n    }\r\n  }\r\n\r\n  function ping(retry) {\r\n    if (self.destroyed) {\r\n      return;\r\n    }\r\n    hreq = self._createHandshakeRequest(self._adapter, !retry);\r\n    var payload = [\r\n      HANDSHAKE_REQUEST_TYPE.toBuffer(hreq),\r\n      utils.bufferFrom([0, 0]) // No header, no data (empty message name).\r\n    ];\r\n    // We can use a static ID here since we are guaranteed that this message is\r\n    // the only one on the channel (for this scope at least).\r\n    self._writable.write({id: self._prefix, payload: payload});\r\n  }\r\n\r\n  function onPing(obj) {\r\n    if (!self._matchesPrefix(obj.id)) {\r\n      debug('discarding unscoped response %s (still connecting)', obj.id);\r\n      return;\r\n    }\r\n    var buf = Buffer.concat(obj.payload);\r\n    try {\r\n      var hres = readHead(HANDSHAKE_RESPONSE_TYPE, buf).head;\r\n      if (hres.serverHash) {\r\n        self._adapter = self._getAdapter(hres);\r\n      }\r\n    } catch (cause) {\r\n      // This isn't a recoverable error.\r\n      self.destroy(cause);\r\n      return;\r\n    }\r\n    var match = hres.match;\r\n    debug('handshake match: %s', match);\r\n    self.emit('handshake', hreq, hres);\r\n    if (match === 'NONE') {\r\n      process.nextTick(function () { ping(true); });\r\n    } else {\r\n      debug('successfully connected');\r\n      if (timer) {\r\n        clearTimeout(timer);\r\n        timer = null;\r\n      }\r\n      self._readable.removeListener('data', onPing).on('data', onMessage);\r\n      self._connected = true;\r\n      self.emit('_ready');\r\n      hreq = null; // Release reference.\r\n    }\r\n  }\r\n\r\n  // Callback used after a connection has been established.\r\n  function onMessage(obj) {\r\n    var id = obj.id;\r\n    if (!self._matchesPrefix(id)) {\r\n      debug('discarding unscoped message %s', id);\r\n      return;\r\n    }\r\n    var cb = self._registry.get(id);\r\n    if (cb) {\r\n      process.nextTick(function () {\r\n        debug('received message %s', id);\r\n        // Ensure that the initial callback gets called asynchronously, even\r\n        // for completely synchronous transports (otherwise the number of\r\n        // pending requests will sometimes be inconsistent between stateful and\r\n        // stateless transports).\r\n        cb(null, Buffer.concat(obj.payload), self._adapter);\r\n      });\r\n    }\r\n  }\r\n\r\n  function onEnd() { self.destroy(true); }\r\n  function onFinish() { self.destroy(); }\r\n}\r\nutil.inherits(StatefulClientChannel, ClientChannel);\r\n\r\nStatefulClientChannel.prototype._emit = function () {\r\n  // Override this method to allow calling `_emit` even before the channel is\r\n  // connected. Note that we don't perform this logic in `_send` since we want\r\n  // to guarantee that `'handshake'` events are emitted before any\r\n  // `'outgoingCall'` events.\r\n  if (this._connected || this.draining) {\r\n    ClientChannel.prototype._emit.apply(this, arguments);\r\n  } else {\r\n    debug('queuing request');\r\n    var args = [];\r\n    var i, l;\r\n    for (i = 0, l = arguments.length; i < l; i++) {\r\n      args.push(arguments[i]);\r\n    }\r\n    this.once('_ready', function () { this._emit.apply(this, args); });\r\n  }\r\n};\r\n\r\nStatefulClientChannel.prototype._send = function (id, reqBuf, oneWay) {\r\n  if (oneWay) {\r\n    var self = this;\r\n    // Clear the callback, passing in an empty header.\r\n    process.nextTick(function () {\r\n      self._registry.get(id)(null, utils.bufferFrom([0, 0, 0]), self._adapter);\r\n    });\r\n  }\r\n  return this._writable.write({id: id, payload: [reqBuf]});\r\n};\r\n\r\n/** The server-side emitter equivalent. */\r\nfunction ServerChannel(server, opts) {\r\n  opts = opts || {};\r\n  events.EventEmitter.call(this);\r\n\r\n  this.server = server;\r\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\r\n  this._prefix = normalizedPrefix(opts.scope);\r\n\r\n  var cache = server._cache;\r\n  var svc = server.service;\r\n  var hash = svc.hash;\r\n  if (!cache[hash]) {\r\n    // Add the channel's protocol to the cache if it isn't already there. This\r\n    // will save a handshake the first time on channels with the same protocol.\r\n    cache[hash] = new Adapter(svc, svc, hash);\r\n  }\r\n  this._adapter = null;\r\n\r\n  this.destroyed = false;\r\n  this.draining = false;\r\n  this.pending = 0;\r\n  this.once('_eot', function (pending, err) {\r\n    debug('server channel EOT');\r\n    this.emit('eot', pending, err);\r\n  });\r\n}\r\nutil.inherits(ServerChannel, events.EventEmitter);\r\n\r\nServerChannel.prototype.destroy = function (noWait) {\r\n  if (!this.draining) {\r\n    this.draining = true;\r\n    this.emit('_drain');\r\n  }\r\n  if (noWait || !this.pending) {\r\n    this.destroyed = true;\r\n    if (isError(noWait)) {\r\n      debug('fatal server channel error: %s', noWait);\r\n      this.emit('_eot', this.pending, noWait);\r\n    } else {\r\n      this.emit('_eot', this.pending);\r\n    }\r\n  }\r\n};\r\n\r\nServerChannel.prototype._createHandshakeResponse = function (err, hreq) {\r\n  var svc = this.server.service;\r\n  var buf = svc.hash;\r\n  var serverMatch = hreq && hreq.serverHash.equals(buf);\r\n  return {\r\n    match: err ? 'NONE' : (serverMatch ? 'BOTH' : 'CLIENT'),\r\n    serverProtocol: serverMatch ? null : JSON.stringify(svc.protocol),\r\n    serverHash: serverMatch ? null : buf\r\n  };\r\n};\r\n\r\nServerChannel.prototype._getAdapter = function (hreq) {\r\n  var hash = hreq.clientHash;\r\n  var adapter = this.server._cache[hash];\r\n  if (adapter) {\r\n    return adapter;\r\n  }\r\n  if (!hreq.clientProtocol) {\r\n    throw toRpcError('UNKNOWN_PROTOCOL');\r\n  }\r\n  var ptcl = JSON.parse(hreq.clientProtocol);\r\n  var clientSvc = Service.forProtocol(ptcl);\r\n  adapter = new Adapter(clientSvc, this.server.service, hash, true);\r\n  return this.server._cache[hash] = adapter;\r\n};\r\n\r\nServerChannel.prototype._matchesPrefix = function (id) {\r\n  return matchesPrefix(id, this._prefix);\r\n};\r\n\r\nServerChannel.prototype._receive = function (reqBuf, adapter, cb) {\r\n  var self = this;\r\n  var wreq;\r\n  try {\r\n    wreq = adapter._decodeRequest(reqBuf);\r\n  } catch (cause) {\r\n    cb(self._encodeSystemError(toRpcError('INVALID_REQUEST', cause)));\r\n    return;\r\n  }\r\n\r\n  var msg = wreq._msg;\r\n  var wres = new WrappedResponse(msg, {});\r\n  if (!msg.name) {\r\n    // Ping message, we don't invoke middleware logic in this case.\r\n    wres.response = null;\r\n    cb(wres.toBuffer(), false);\r\n    return;\r\n  }\r\n\r\n  var ctx = new CallContext(msg, this);\r\n  self.emit('incomingCall', ctx);\r\n  var fns = this.server._fns;\r\n  debug('starting server middleware chain (%s middleware)', fns.length);\r\n  self.pending++;\r\n  chainMiddleware({\r\n    fns: fns,\r\n    ctx: ctx,\r\n    wreq: wreq,\r\n    wres: wres,\r\n    onTransition: onTransition,\r\n    onCompletion: onCompletion,\r\n    onError: onError\r\n  });\r\n\r\n  function onTransition(wreq, wres, prev) {\r\n    var handler = self.server._handlers[msg.name];\r\n    if (!handler) {\r\n      // The underlying service hasn't implemented a handler.\r\n      var defaultHandler = self.server._defaultHandler;\r\n      if (defaultHandler) {\r\n        // We call the default handler with arguments similar (slightly\r\n        // simpler, there are no phases here) to middleware such that it can\r\n        // easily access the message name (useful to implement proxies).\r\n        defaultHandler.call(ctx, wreq, wres, prev);\r\n      } else {\r\n        var cause = new Error(f('no handler for %s', msg.name));\r\n        prev(toRpcError('NOT_IMPLEMENTED', cause));\r\n      }\r\n    } else {\r\n      var pending = !msg.oneWay;\r\n      try {\r\n        if (pending) {\r\n          handler.call(ctx, wreq.request, function (err, res) {\r\n            pending = false;\r\n            wres.error = err;\r\n            wres.response = res;\r\n            prev();\r\n          });\r\n        } else {\r\n          handler.call(ctx, wreq.request);\r\n          prev();\r\n        }\r\n      } catch (err) {\r\n        // We catch synchronous failures (same as express) and return the\r\n        // failure. Note that the server process can still crash if an error\r\n        // is thrown after the handler returns but before the response is\r\n        // sent (again, same as express). We are careful to only trigger the\r\n        // response callback once, emitting the errors afterwards instead.\r\n        if (pending) {\r\n          pending = false;\r\n          prev(err);\r\n        } else {\r\n          onError(err);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function onCompletion(err) {\r\n    self.pending--;\r\n    var server = self.server;\r\n    var resBuf;\r\n    if (!err) {\r\n      var resErr = wres.error;\r\n      var isStrict = server._strict;\r\n      if (!isStrict) {\r\n        if (isError(resErr)) {\r\n          // If the error type is wrapped, we must wrap the error too.\r\n          wres.error = msg.errorType.clone(resErr.message, {wrapUnions: true});\r\n        } else if (resErr === null) {\r\n          // We also allow `null`'s as error in this mode, converting them to\r\n          // the Avro-compatible `undefined`.\r\n          resErr = wres.error = undefined;\r\n        }\r\n        if (\r\n          resErr === undefined &&\r\n          wres.response === undefined &&\r\n          msg.responseType.isValid(null)\r\n        ) {\r\n          // Finally, for messages with `null` as acceptable response type, we\r\n          // allow `undefined`; converting them to `null`. This allows users to\r\n          // write a more natural `cb()` instead of `cb(null, null)`.\r\n          wres.response = null;\r\n        }\r\n      }\r\n      try {\r\n        resBuf = wres.toBuffer();\r\n      } catch (cause) {\r\n        // Note that we don't add an RPC code here such that the client\r\n        // receives the default `INTERNAL_SERVER_ERROR` one.\r\n        if (wres.error !== undefined) {\r\n          err = serializationError(\r\n            f('invalid %j error', msg.name), // Sic.\r\n            wres,\r\n            [\r\n              {name: 'headers', type: MAP_BYTES_TYPE},\r\n              {name: 'error', type: msg.errorType}\r\n            ]\r\n          );\r\n        } else {\r\n          err = serializationError(\r\n            f('invalid %j response', msg.name),\r\n            wres,\r\n            [\r\n              {name: 'headers', type: MAP_BYTES_TYPE},\r\n              {name: 'response', type: msg.responseType}\r\n            ]\r\n          );\r\n        }\r\n      }\r\n    }\r\n    if (!resBuf) {\r\n      // The headers are only available if the message isn't one-way.\r\n      resBuf = self._encodeSystemError(err, wres.headers);\r\n    } else if (resErr !== undefined) {\r\n      server.emit('error', toRpcError('APPLICATION_ERROR', resErr));\r\n    }\r\n    cb(resBuf, msg.oneWay);\r\n    if (self.draining && !self.pending) {\r\n      self.destroy();\r\n    }\r\n  }\r\n\r\n  function onError(err) {\r\n    // Similar to the client equivalent, we redirect this error to the server\r\n    // since middleware are defined at server-level.\r\n    self.server.emit('error', err, self);\r\n  }\r\n};\r\n\r\n// Deprecated.\r\n\r\nutils.addDeprecatedGetters(ServerChannel, ['pending']);\r\n\r\nServerChannel.prototype.getCache = util.deprecate(\r\n  function () { return this.server._cache; },\r\n  'use `.remoteProtocols()` instead of `.getCache()`'\r\n);\r\n\r\nServerChannel.prototype.getProtocol = util.deprecate(\r\n  function () {\r\n    return this.server.service;\r\n  },\r\n  'use `.service` instead of `.getProtocol()`'\r\n);\r\n\r\nServerChannel.prototype.isDestroyed = util.deprecate(\r\n  function () { return this.destroyed; },\r\n  'use `.destroyed` instead of `.isDestroyed`'\r\n);\r\n\r\n/**\r\n * Encode an error and optional header into a valid Avro response.\r\n *\r\n * @param err {Error} Error to encode.\r\n * @param header {Object} Optional response header.\r\n */\r\nServerChannel.prototype._encodeSystemError = function (err, header) {\r\n  var server = this.server;\r\n  server.emit('error', err, this);\r\n  var errStr;\r\n  if (server._sysErrFormatter) {\r\n    // Format the error into a string to send over the wire.\r\n    errStr = server._sysErrFormatter.call(this, err);\r\n  } else if (err.rpcCode) {\r\n    // By default, only forward the error's message when the RPC code is set\r\n    // (i.e. when this isn't an internal server error).\r\n    errStr = err.message;\r\n  }\r\n  var hdrBuf;\r\n  if (header) {\r\n    try {\r\n      // Propagate the header if possible.\r\n      hdrBuf = MAP_BYTES_TYPE.toBuffer(header);\r\n    } catch (cause) {\r\n      server.emit('error', cause, this);\r\n    }\r\n  }\r\n  return Buffer.concat([\r\n    hdrBuf || utils.bufferFrom([0]),\r\n    utils.bufferFrom([1, 0]), // Error flag and first union index.\r\n    STRING_TYPE.toBuffer(errStr || 'internal server error')\r\n  ]);\r\n};\r\n\r\n/**\r\n * Server channel for stateless transport.\r\n *\r\n * This channel expect a handshake to precede each message.\r\n */\r\nfunction StatelessServerChannel(server, readableFactory, opts) {\r\n  ServerChannel.call(this, server, opts);\r\n\r\n  this._writable = undefined;\r\n  var self = this;\r\n  var readable;\r\n\r\n  process.nextTick(function () {\r\n    // Delay listening to allow handlers to be attached even if the factory is\r\n    // purely synchronous.\r\n    readable = readableFactory.call(self, function (err, writable) {\r\n      process.nextTick(function () {\r\n        // We delay once more here in case this call is synchronous, to allow\r\n        // the readable to always be populated first.\r\n        if (err) {\r\n          onFinish(err);\r\n          return;\r\n        }\r\n        self._writable = writable.on('finish', onFinish);\r\n        self.emit('_writable');\r\n      });\r\n    }).on('data', onRequest).on('end', onEnd);\r\n  });\r\n\r\n\r\n  function onRequest(obj) {\r\n    var id = obj.id;\r\n    var buf = Buffer.concat(obj.payload);\r\n    var err;\r\n    try {\r\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\r\n      var hreq = parts.head;\r\n      var adapter = self._getAdapter(hreq);\r\n    } catch (cause) {\r\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\r\n    }\r\n\r\n    var hres = self._createHandshakeResponse(err, hreq);\r\n    self.emit('handshake', hreq, hres);\r\n    if (err) {\r\n      done(self._encodeSystemError(err));\r\n    } else {\r\n      self._receive(parts.tail, adapter, done);\r\n    }\r\n\r\n    function done(resBuf) {\r\n      if (!self.destroyed) {\r\n        if (!self._writable) {\r\n          self.once('_writable', function () { done(resBuf); });\r\n          return;\r\n        }\r\n        self._writable.write({\r\n          id: id,\r\n          payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\r\n        });\r\n      }\r\n      if (self._writable && self._endWritable) {\r\n        self._writable.end();\r\n      }\r\n    }\r\n  }\r\n\r\n  function onEnd() { self.destroy(); }\r\n\r\n  function onFinish(err) {\r\n    readable\r\n      .removeListener('data', onRequest)\r\n      .removeListener('end', onEnd);\r\n    self.destroy(err || true);\r\n  }\r\n}\r\nutil.inherits(StatelessServerChannel, ServerChannel);\r\n\r\n/**\r\n * Stateful transport listener.\r\n *\r\n * A handshake is done when the channel first receives a message, then all\r\n * messages are sent without.\r\n */\r\nfunction StatefulServerChannel(server, readable, writable, opts) {\r\n  ServerChannel.call(this, server, opts);\r\n  this._adapter = undefined;\r\n  this._writable = writable.on('finish', onFinish);\r\n  this._readable = readable.on('data', onHandshake).on('end', onEnd);\r\n\r\n  this\r\n    .once('_drain', function () {\r\n      // Stop listening to incoming events.\r\n      this._readable\r\n        .removeListener('data', onHandshake)\r\n        .removeListener('data', onRequest)\r\n        .removeListener('end', onEnd);\r\n    })\r\n    .once('eot', function () {\r\n      // Clean up any references to the channel on the underlying streams.\r\n      this._writable.removeListener('finish', onFinish);\r\n      if (this._endWritable) {\r\n        this._writable.end();\r\n      }\r\n    });\r\n\r\n  var self = this;\r\n\r\n  function onHandshake(obj) {\r\n    var id = obj.id;\r\n    if (!self._matchesPrefix(id)) {\r\n      return;\r\n    }\r\n    var buf = Buffer.concat(obj.payload);\r\n    var err;\r\n    try {\r\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\r\n      var hreq = parts.head;\r\n      self._adapter = self._getAdapter(hreq);\r\n    } catch (cause) {\r\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\r\n    }\r\n    var hres = self._createHandshakeResponse(err, hreq);\r\n    self.emit('handshake', hreq, hres);\r\n    if (err) {\r\n      // Either the client's protocol was unknown or it isn't compatible.\r\n      done(self._encodeSystemError(err));\r\n    } else {\r\n      self._readable\r\n        .removeListener('data', onHandshake)\r\n        .on('data', onRequest);\r\n      self._receive(parts.tail, self._adapter, done);\r\n    }\r\n\r\n    function done(resBuf) {\r\n      if (self.destroyed) {\r\n        return;\r\n      }\r\n      self._writable.write({\r\n        id: id,\r\n        payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\r\n      });\r\n    }\r\n  }\r\n\r\n  function onRequest(obj) {\r\n    // These requests are not prefixed with handshakes.\r\n    var id = obj.id;\r\n    if (!self._matchesPrefix(id)) {\r\n      return;\r\n    }\r\n    var reqBuf = Buffer.concat(obj.payload);\r\n    self._receive(reqBuf, self._adapter, function (resBuf, oneWay) {\r\n      if (self.destroyed || oneWay) {\r\n        return;\r\n      }\r\n      self._writable.write({id: id, payload: [resBuf]});\r\n    });\r\n  }\r\n\r\n  function onEnd() { self.destroy(); }\r\n\r\n  function onFinish() { self.destroy(true); }\r\n}\r\nutil.inherits(StatefulServerChannel, ServerChannel);\r\n\r\n// Helpers.\r\n\r\n/** Enhanced request, used inside forward middleware functions. */\r\nfunction WrappedRequest(msg, hdrs, req) {\r\n  this._msg = msg;\r\n  this.headers = hdrs || {};\r\n  this.request = req || {};\r\n}\r\n\r\nWrappedRequest.prototype.toBuffer = function () {\r\n  var msg = this._msg;\r\n  return Buffer.concat([\r\n    MAP_BYTES_TYPE.toBuffer(this.headers),\r\n    STRING_TYPE.toBuffer(msg.name),\r\n    msg.requestType.toBuffer(this.request)\r\n  ]);\r\n};\r\n\r\n/** Enhanced response, used inside forward middleware functions. */\r\nfunction WrappedResponse(msg, hdr, err, res) {\r\n  this._msg = msg;\r\n  this.headers = hdr;\r\n  this.error = err;\r\n  this.response = res;\r\n}\r\n\r\nWrappedResponse.prototype.toBuffer = function () {\r\n  var hdr = MAP_BYTES_TYPE.toBuffer(this.headers);\r\n  var hasError = this.error !== undefined;\r\n  return Buffer.concat([\r\n    hdr,\r\n    BOOLEAN_TYPE.toBuffer(hasError),\r\n    hasError ?\r\n      this._msg.errorType.toBuffer(this.error) :\r\n      this._msg.responseType.toBuffer(this.response)\r\n  ]);\r\n};\r\n\r\n/**\r\n * Context for all middleware and handlers.\r\n *\r\n * It exposes a `locals` object which can be used to pass information between\r\n * each other during a given call.\r\n */\r\nfunction CallContext(msg, channel) {\r\n  this.channel = channel;\r\n  this.locals = {};\r\n  this.message = msg;\r\n  Object.freeze(this);\r\n}\r\n\r\n/**\r\n * Callback registry.\r\n *\r\n * Callbacks added must accept an error as first argument. This is used by\r\n * client channels to store pending calls. This class isn't exposed by the\r\n * public API.\r\n */\r\nfunction Registry(ctx, prefixLength) {\r\n  this._ctx = ctx; // Context for all callbacks.\r\n  this._mask = ~0 >>> (prefixLength | 0); // 16 bits by default.\r\n  this._id = 0; // Unique integer ID for each call.\r\n  this._n = 0; // Number of pending calls.\r\n  this._cbs = {};\r\n}\r\n\r\nRegistry.prototype.get = function (id) { return this._cbs[id & this._mask]; };\r\n\r\nRegistry.prototype.add = function (timeout, fn) {\r\n  this._id = (this._id + 1) & this._mask;\r\n\r\n  var self = this;\r\n  var id = this._id;\r\n  var timer;\r\n  if (timeout > 0) {\r\n    timer = setTimeout(function () { cb(new Error('timeout')); }, timeout);\r\n  }\r\n\r\n  this._cbs[id] = cb;\r\n  this._n++;\r\n  return id;\r\n\r\n  function cb() {\r\n    if (!self._cbs[id]) {\r\n      // The callback has already run.\r\n      return;\r\n    }\r\n    delete self._cbs[id];\r\n    self._n--;\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n    }\r\n    fn.apply(self._ctx, arguments);\r\n  }\r\n};\r\n\r\nRegistry.prototype.clear = function () {\r\n  Object.keys(this._cbs).forEach(function (id) {\r\n    this._cbs[id](new Error('interrupted'));\r\n  }, this);\r\n};\r\n\r\n/**\r\n * Service resolution helper.\r\n *\r\n * It is used both by client and server channels, to respectively decode errors\r\n * and responses, or requests.\r\n */\r\nfunction Adapter(clientSvc, serverSvc, hash, isRemote) {\r\n  this._clientSvc = clientSvc;\r\n  this._serverSvc = serverSvc;\r\n  this._hash = hash; // Convenience to access it when creating handshakes.\r\n  this._isRemote = !!isRemote;\r\n  this._readers = createReaders(clientSvc, serverSvc);\r\n}\r\n\r\nAdapter.prototype._decodeRequest = function (buf) {\r\n  var tap = new Tap(buf);\r\n  var hdr = MAP_BYTES_TYPE._read(tap);\r\n  var name = STRING_TYPE._read(tap);\r\n  var msg, req;\r\n  if (name) {\r\n    msg = this._serverSvc.message(name);\r\n    req = this._readers[name + '?']._read(tap);\r\n  } else {\r\n    msg = PING_MESSAGE;\r\n  }\r\n  if (!tap.isValid()) {\r\n    throw new Error(f('truncated %s request', name || 'ping$'));\r\n  }\r\n  return new WrappedRequest(msg, hdr, req);\r\n};\r\n\r\nAdapter.prototype._decodeResponse = function (buf, wres, msg) {\r\n  var tap = new Tap(buf);\r\n  utils.copyOwnProperties(MAP_BYTES_TYPE._read(tap), wres.headers, true);\r\n  var isError = BOOLEAN_TYPE._read(tap);\r\n  var name = msg.name;\r\n  if (name) {\r\n    var reader = this._readers[name + (isError ? '*' : '!')];\r\n    msg = this._clientSvc.message(name);\r\n    if (isError) {\r\n      wres.error = reader._read(tap);\r\n    } else {\r\n      wres.response = reader._read(tap);\r\n    }\r\n    if (!tap.isValid()) {\r\n      throw new Error(f('truncated %s response', name));\r\n    }\r\n  } else {\r\n    msg = PING_MESSAGE;\r\n  }\r\n};\r\n\r\n/** Standard \"un-framing\" stream. */\r\nfunction FrameDecoder() {\r\n  stream.Transform.call(this, {readableObjectMode: true});\r\n  this._id = undefined;\r\n  this._buf = utils.newBuffer(0);\r\n  this._bufs = [];\r\n\r\n  this.on('finish', function () { this.push(null); });\r\n}\r\nutil.inherits(FrameDecoder, stream.Transform);\r\n\r\nFrameDecoder.prototype._transform = function (buf, encoding, cb) {\r\n  buf = Buffer.concat([this._buf, buf]);\r\n  var frameLength;\r\n  while (\r\n    buf.length >= 4 &&\r\n    buf.length >= (frameLength = buf.readInt32BE(0)) + 4\r\n  ) {\r\n    if (frameLength) {\r\n      this._bufs.push(buf.slice(4, frameLength + 4));\r\n    } else {\r\n      var bufs = this._bufs;\r\n      this._bufs = [];\r\n      this.push({id: null, payload: bufs});\r\n    }\r\n    buf = buf.slice(frameLength + 4);\r\n  }\r\n  this._buf = buf;\r\n  cb();\r\n};\r\n\r\nFrameDecoder.prototype._flush = function (cb) {\r\n  if (this._buf.length || this._bufs.length) {\r\n    var bufs = this._bufs.slice();\r\n    bufs.unshift(this._buf);\r\n    var err = toRpcError('TRAILING_DATA');\r\n    // Attach the data to help debugging (e.g. if the encoded bytes contain a\r\n    // human-readable protocol like HTTP).\r\n    err.trailingData = Buffer.concat(bufs).toString();\r\n    this.emit('error', err);\r\n  }\r\n  cb();\r\n};\r\n\r\n/** Standard framing stream. */\r\nfunction FrameEncoder() {\r\n  stream.Transform.call(this, {writableObjectMode: true});\r\n  this.on('finish', function () { this.push(null); });\r\n}\r\nutil.inherits(FrameEncoder, stream.Transform);\r\n\r\nFrameEncoder.prototype._transform = function (obj, encoding, cb) {\r\n  var bufs = obj.payload;\r\n  var i, l, buf;\r\n  for (i = 0, l = bufs.length; i < l; i++) {\r\n    buf = bufs[i];\r\n    this.push(intBuffer(buf.length));\r\n    this.push(buf);\r\n  }\r\n  this.push(intBuffer(0));\r\n  cb();\r\n};\r\n\r\n/** Netty-compatible decoding stream. */\r\nfunction NettyDecoder() {\r\n  stream.Transform.call(this, {readableObjectMode: true});\r\n  this._id = undefined;\r\n  this._frameCount = 0;\r\n  this._buf = utils.newBuffer(0);\r\n  this._bufs = [];\r\n\r\n  this.on('finish', function () { this.push(null); });\r\n}\r\nutil.inherits(NettyDecoder, stream.Transform);\r\n\r\nNettyDecoder.prototype._transform = function (buf, encoding, cb) {\r\n  buf = Buffer.concat([this._buf, buf]);\r\n\r\n  while (true) {\r\n    if (this._id === undefined) {\r\n      if (buf.length < 8) {\r\n        this._buf = buf;\r\n        cb();\r\n        return;\r\n      }\r\n      this._id = buf.readInt32BE(0);\r\n      this._frameCount = buf.readInt32BE(4);\r\n      buf = buf.slice(8);\r\n    }\r\n\r\n    var frameLength;\r\n    while (\r\n      this._frameCount &&\r\n      buf.length >= 4 &&\r\n      buf.length >= (frameLength = buf.readInt32BE(0)) + 4\r\n    ) {\r\n      this._frameCount--;\r\n      this._bufs.push(buf.slice(4, frameLength + 4));\r\n      buf = buf.slice(frameLength + 4);\r\n    }\r\n\r\n    if (this._frameCount) {\r\n      this._buf = buf;\r\n      cb();\r\n      return;\r\n    } else {\r\n      var obj = {id: this._id, payload: this._bufs};\r\n      this._bufs = [];\r\n      this._id = undefined;\r\n      this.push(obj);\r\n    }\r\n  }\r\n};\r\n\r\nNettyDecoder.prototype._flush = FrameDecoder.prototype._flush;\r\n\r\n/** Netty-compatible encoding stream. */\r\nfunction NettyEncoder() {\r\n  stream.Transform.call(this, {writableObjectMode: true});\r\n  this.on('finish', function () { this.push(null); });\r\n}\r\nutil.inherits(NettyEncoder, stream.Transform);\r\n\r\nNettyEncoder.prototype._transform = function (obj, encoding, cb) {\r\n  var bufs = obj.payload;\r\n  var l = bufs.length;\r\n  var buf;\r\n  // Header: [ ID, number of frames ]\r\n  buf = utils.newBuffer(8);\r\n  buf.writeInt32BE(obj.id, 0);\r\n  buf.writeInt32BE(l, 4);\r\n  this.push(buf);\r\n  // Frames, each: [ length, bytes ]\r\n  var i;\r\n  for (i = 0; i < l; i++) {\r\n    buf = bufs[i];\r\n    this.push(intBuffer(buf.length));\r\n    this.push(buf);\r\n  }\r\n  cb();\r\n};\r\n\r\n/**\r\n * Returns a buffer containing an integer's big-endian representation.\r\n *\r\n * @param n {Number} Integer.\r\n */\r\nfunction intBuffer(n) {\r\n  var buf = utils.newBuffer(4);\r\n  buf.writeInt32BE(n);\r\n  return buf;\r\n}\r\n\r\n/**\r\n * Decode a type used as prefix inside a buffer.\r\n *\r\n * @param type {Type} The type of the prefix.\r\n * @param buf {Buffer} Encoded bytes.\r\n *\r\n * This function will return an object `{head, tail}` where head contains the\r\n * decoded value and tail the rest of the buffer. An error will be thrown if\r\n * the prefix cannot be decoded.\r\n */\r\nfunction readHead(type, buf) {\r\n  var tap = new Tap(buf);\r\n  var head = type._read(tap);\r\n  if (!tap.isValid()) {\r\n    throw new Error(f('truncated %j', type.schema()));\r\n  }\r\n  return {head: head, tail: tap.buf.slice(tap.pos)};\r\n}\r\n\r\n/**\r\n * Generate a decoder, optimizing the case where reader and writer are equal.\r\n *\r\n * @param rtype {Type} Reader's type.\r\n * @param wtype {Type} Writer's type.\r\n */\r\nfunction createReader(rtype, wtype) {\r\n  return rtype.equals(wtype) ? rtype : rtype.createResolver(wtype);\r\n}\r\n\r\n/**\r\n * Generate all readers for a given protocol combination.\r\n *\r\n * @param clientSvc {Service} Client service.\r\n * @param serverSvc {Service} Client service.\r\n */\r\nfunction createReaders(clientSvc, serverSvc) {\r\n  var obj = {};\r\n  clientSvc.messages.forEach(function (c) {\r\n    var n = c.name;\r\n    var s = serverSvc.message(n);\r\n    try {\r\n      if (!s) {\r\n        throw new Error(f('missing server message: %s', n));\r\n      }\r\n      if (s.oneWay !== c.oneWay) {\r\n        throw new Error(f('inconsistent one-way message: %s', n));\r\n      }\r\n      obj[n + '?'] = createReader(s.requestType, c.requestType);\r\n      obj[n + '*'] = createReader(c.errorType, s.errorType);\r\n      obj[n + '!'] = createReader(c.responseType, s.responseType);\r\n    } catch (cause) {\r\n      throw toRpcError('INCOMPATIBLE_PROTOCOL', cause);\r\n    }\r\n  });\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Populate a cache from a list of protocols.\r\n *\r\n * @param cache {Object} Cache of adapters.\r\n * @param svc {Service} The local service (either client or server).\r\n * @param ptcls {Array} Array of protocols to insert.\r\n * @param isClient {Boolean} Whether the local service is a client's or\r\n * server's.\r\n */\r\nfunction insertRemoteProtocols(cache, ptcls, svc, isClient) {\r\n  Object.keys(ptcls).forEach(function (hash) {\r\n    var ptcl = ptcls[hash];\r\n    var clientSvc, serverSvc;\r\n    if (isClient) {\r\n      clientSvc = svc;\r\n      serverSvc = Service.forProtocol(ptcl);\r\n    } else {\r\n      clientSvc = Service.forProtocol(ptcl);\r\n      serverSvc = svc;\r\n    }\r\n    cache[hash] = new Adapter(clientSvc, serverSvc, hash, true);\r\n  });\r\n}\r\n\r\n/**\r\n * Extract remote protocols from a cache\r\n *\r\n * @param cache {Object} Cache of adapters.\r\n * @param isClient {Boolean} Whether the remote protocols extracted should be\r\n * the servers' or clients'.\r\n */\r\nfunction getRemoteProtocols(cache, isClient) {\r\n  var ptcls = {};\r\n  Object.keys(cache).forEach(function (hs) {\r\n    var adapter = cache[hs];\r\n    if (adapter._isRemote) {\r\n      var svc = isClient ? adapter._serverSvc : adapter._clientSvc;\r\n      ptcls[hs] = svc.protocol;\r\n    }\r\n  });\r\n  return ptcls;\r\n}\r\n\r\n/**\r\n * Check whether something is an `Error`.\r\n *\r\n * @param any {Object} Any object.\r\n */\r\nfunction isError(any) {\r\n  // Also not ideal, but avoids brittle `instanceof` checks.\r\n  return !!any && Object.prototype.toString.call(any) === '[object Error]';\r\n}\r\n\r\n/**\r\n * Forward any errors emitted on the source to the destination.\r\n *\r\n * @param src {EventEmitter} The initial source of error events.\r\n * @param dst {EventEmitter} The new target of the source's error events. The\r\n * original source will be provided as second argument (the error being the\r\n * first).\r\n *\r\n * As a convenience, the source will be returned.\r\n */\r\nfunction forwardErrors(src, dst) {\r\n  return src.on('error', function (err) {\r\n    dst.emit('error', err, src);\r\n  });\r\n}\r\n\r\n/**\r\n * Create an error.\r\n *\r\n * @param msg {String} Error message.\r\n * @param cause {Error} The cause of the error. It is available as `cause`\r\n * field on the outer error.\r\n */\r\nfunction toError(msg, cause) {\r\n  var err = new Error(msg);\r\n  err.cause = cause;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Mark an error.\r\n *\r\n * @param rpcCode {String} Code representing the failure.\r\n * @param cause {Error} The cause of the error. It is available as `cause`\r\n * field on the outer error.\r\n *\r\n * This is used to keep the argument of channels' `'error'` event errors.\r\n */\r\nfunction toRpcError(rpcCode, cause) {\r\n  var err = toError(rpcCode.toLowerCase().replace(/_/g, ' '), cause);\r\n  err.rpcCode = (cause && cause.rpcCode) ? cause.rpcCode : rpcCode;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Provide a helpful error to identify why serialization failed.\r\n *\r\n * @param err {Error} The error to decorate.\r\n * @param obj {...} The object containing fields to validated.\r\n * @param fields {Array} Information about the fields to validate.\r\n */\r\nfunction serializationError(msg, obj, fields) {\r\n  var details = [];\r\n  var i, l, field;\r\n  for (i = 0, l = fields.length; i < l; i++) {\r\n    field = fields[i];\r\n    field.type.isValid(obj[field.name], {errorHook: errorHook});\r\n  }\r\n  var detailsStr = details\r\n    .map(function (obj) {\r\n      return f('%s = %j but expected %s', obj.path, obj.value, obj.type);\r\n    })\r\n    .join(', ');\r\n  var err = new Error(f('%s (%s)', msg, detailsStr));\r\n  err.details = details;\r\n  return err;\r\n\r\n  function errorHook(parts, any, type) {\r\n    var strs = [];\r\n    var i, l, part;\r\n    for (i = 0, l = parts.length; i < l; i++) {\r\n      part = parts[i];\r\n      if (isNaN(part)) {\r\n        strs.push('.' + part);\r\n      } else {\r\n        strs.push('[' + part + ']');\r\n      }\r\n    }\r\n    details.push({\r\n      path: field.name + strs.join(''),\r\n      value: any,\r\n      type: type\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Compute a prefix of fixed length from a string.\r\n *\r\n * @param scope {String} Namespace to be hashed.\r\n */\r\nfunction normalizedPrefix(scope) {\r\n  return scope ?\r\n    utils.getHash(scope).readInt16BE(0) << (32 - PREFIX_LENGTH) :\r\n    0;\r\n}\r\n\r\n/**\r\n * Check whether an ID matches the prefix.\r\n *\r\n * @param id {Integer} Number to check.\r\n * @param prefix {Integer} Already shifted prefix.\r\n */\r\nfunction matchesPrefix(id, prefix) {\r\n  return ((id ^ prefix) >> (32 - PREFIX_LENGTH)) === 0;\r\n}\r\n\r\n/**\r\n * Check whether something is a stream.\r\n *\r\n * @param any {Object} Any object.\r\n */\r\nfunction isStream(any) {\r\n  // This is a hacky way of checking that the transport is a stream-like\r\n  // object. We unfortunately can't use `instanceof Stream` checks since\r\n  // some libraries (e.g. websocket-stream) return streams which don't\r\n  // inherit from it.\r\n  return !!(any && any.pipe);\r\n}\r\n\r\n/**\r\n * Get a message, asserting that it exists.\r\n *\r\n * @param svc {Service} The protocol to look into.\r\n * @param name {String} The message's name.\r\n */\r\nfunction getExistingMessage(svc, name) {\r\n  var msg = svc.message(name);\r\n  if (!msg) {\r\n    throw new Error(f('unknown message: %s', name));\r\n  }\r\n  return msg;\r\n}\r\n\r\n/**\r\n * Middleware logic.\r\n *\r\n * This is used both in clients and servers to intercept call handling (e.g. to\r\n * populate headers, do access control).\r\n *\r\n * @param params {Object} The following parameters:\r\n *  + fns {Array} Array of middleware functions.\r\n *  + ctx {Object} Context used to call the middleware functions, onTransition,\r\n *    and onCompletion.\r\n *  + wreq {WrappedRequest}\r\n *  + wres {WrappedResponse}\r\n *  + onTransition {Function} End of forward phase callback. It accepts an\r\n *    eventual error as single argument. This will be used for the backward\r\n *    phase. This function is guaranteed to be called at most once.\r\n *  + onCompletion {Function} Final handler, it takes an error as unique\r\n *    argument. This function is guaranteed to be only at most once.\r\n *  + onError {Function} Error handler, called if an intermediate callback is\r\n *    called multiple times.\r\n */\r\nfunction chainMiddleware(params) {\r\n  var args = [params.wreq, params.wres];\r\n  var cbs = [];\r\n  var cause; // Backpropagated error.\r\n  forward(0);\r\n\r\n  function forward(pos) {\r\n    var isDone = false;\r\n    if (pos < params.fns.length) {\r\n      params.fns[pos].apply(params.ctx, args.concat(function (err, cb) {\r\n        if (isDone) {\r\n          params.onError(toError('duplicate forward middleware call', err));\r\n          return;\r\n        }\r\n        isDone = true;\r\n        if (\r\n          err || (\r\n            params.wres && ( // Non one-way messages.\r\n              params.wres.error !== undefined ||\r\n              params.wres.response !== undefined\r\n            )\r\n          )\r\n        ) {\r\n          // Stop the forward phase, bypass the handler, and start the backward\r\n          // phase. Note that we ignore any callback argument in this case.\r\n          cause = err;\r\n          backward();\r\n          return;\r\n        }\r\n        if (cb) {\r\n          cbs.push(cb);\r\n        }\r\n        forward(++pos);\r\n      }));\r\n    } else {\r\n      // Done with the middleware forward functions, call the handler.\r\n      params.onTransition.apply(params.ctx, args.concat(function (err) {\r\n        if (isDone) {\r\n          params.onError(toError('duplicate handler call', err));\r\n          return;\r\n        }\r\n        isDone = true;\r\n        cause = err;\r\n        process.nextTick(backward);\r\n      }));\r\n    }\r\n  }\r\n\r\n  function backward() {\r\n    var cb = cbs.pop();\r\n    if (cb) {\r\n      var isDone = false;\r\n      cb.call(params.ctx, cause, function (err) {\r\n        if (isDone) {\r\n          params.onError(toError('duplicate backward middleware call', err));\r\n          return;\r\n        }\r\n        // Substitute the error.\r\n        cause = err;\r\n        isDone = true;\r\n        backward();\r\n      });\r\n    } else {\r\n      // Done with all middleware calls.\r\n      params.onCompletion.call(params.ctx, cause);\r\n    }\r\n  }\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  Adapter: Adapter,\r\n  HANDSHAKE_REQUEST_TYPE: HANDSHAKE_REQUEST_TYPE,\r\n  HANDSHAKE_RESPONSE_TYPE: HANDSHAKE_RESPONSE_TYPE,\r\n  Message: Message,\r\n  Registry: Registry,\r\n  Service: Service,\r\n  discoverProtocol: discoverProtocol,\r\n  streams: {\r\n    FrameDecoder: FrameDecoder,\r\n    FrameEncoder: FrameEncoder,\r\n    NettyDecoder: NettyDecoder,\r\n    NettyEncoder: NettyEncoder\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/services.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/specs.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/specs.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\r\n\r\n// TODO: Add minimal templating.\r\n// TODO: Add option to prefix nested type declarations with the outer types'\r\n// names.\r\n\r\n\r\n\r\n/** IDL to protocol (services) and schema (types) parsing logic. */\r\n\r\nvar files = __webpack_require__(/*! ./files */ \"./node_modules/avsc/lib/files.js\"),\r\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\r\n    path = __webpack_require__(/*! path */ \"path\"),\r\n    util = __webpack_require__(/*! util */ \"util\");\r\n\r\n\r\nvar f = util.format;\r\n\r\n\r\n// Default type references defined by Avro.\r\nvar TYPE_REFS = {\r\n  date: {type: 'int', logicalType: 'date'},\r\n  decimal: {type: 'bytes', logicalType: 'decimal'},\r\n  time_ms: {type: 'long', logicalType: 'time-millis'},\r\n  timestamp_ms: {type: 'long', logicalType: 'timestamp-millis'}\r\n};\r\n\r\n\r\n/** Assemble an IDL file into a decoded protocol. */\r\nfunction assembleProtocol(fpath, opts, cb) {\r\n  if (!cb && typeof opts == 'function') {\r\n    cb = opts;\r\n    opts = undefined;\r\n  }\r\n  opts = opts || {};\r\n  if (!opts.importHook) {\r\n    opts.importHook = files.createImportHook();\r\n  }\r\n\r\n  importFile(fpath, function (err, protocol) {\r\n    if (err) {\r\n      cb(err);\r\n      return;\r\n    }\r\n    if (!protocol) {\r\n      cb(new Error('empty root import'));\r\n      return;\r\n    }\r\n    var schemas = protocol.types;\r\n    if (schemas) {\r\n      // Strip redundant namespaces from types before returning the protocol.\r\n      // Note that we keep empty (`''`) nested namespaces when the outer one is\r\n      // non-empty. This allows figuring out whether unqualified imported names\r\n      // should be qualified by the protocol's namespace: they should if their\r\n      // namespace is `undefined` and should not if it is empty.\r\n      var namespace = protocolNamespace(protocol) || '';\r\n      schemas.forEach(function (schema) {\r\n        if (schema.namespace === namespace) {\r\n          delete schema.namespace;\r\n        }\r\n      });\r\n    }\r\n    cb(null, protocol);\r\n  });\r\n\r\n  function importFile(fpath, cb) {\r\n    opts.importHook(fpath, 'idl', function (err, str) {\r\n      if (err) {\r\n        cb(err);\r\n        return;\r\n      }\r\n      if (str === undefined) {\r\n        // This signals an already imported file by the default import hooks.\r\n        // Implementors who wish to disallow duplicate imports should provide a\r\n        // custom hook which throws an error when a duplicate is detected.\r\n        cb();\r\n        return;\r\n      }\r\n      try {\r\n        var reader = new Reader(str, opts);\r\n        var obj = reader._readProtocol(str, opts);\r\n      } catch (err) {\r\n        err.path = fpath; // To help debug which file caused the error.\r\n        cb(err);\r\n        return;\r\n      }\r\n      fetchImports(obj.protocol, obj.imports, path.dirname(fpath), cb);\r\n    });\r\n  }\r\n\r\n  function fetchImports(protocol, imports, dpath, cb) {\r\n    var importedProtocols = [];\r\n    next();\r\n\r\n    function next() {\r\n      var info = imports.shift();\r\n      if (!info) {\r\n        // We are done with this file. We prepend all imported types to this\r\n        // file's and we can return the final result.\r\n        importedProtocols.reverse();\r\n        try {\r\n          importedProtocols.forEach(function (imported) {\r\n            mergeImport(protocol, imported);\r\n          });\r\n        } catch (err) {\r\n          cb(err);\r\n          return;\r\n        }\r\n        cb(null, protocol);\r\n        return;\r\n      }\r\n      var importPath = path.join(dpath, info.name);\r\n      if (info.kind === 'idl') {\r\n        importFile(importPath, function (err, imported) {\r\n          if (err) {\r\n            cb(err);\r\n            return;\r\n          }\r\n          if (imported) {\r\n            importedProtocols.push(imported);\r\n          }\r\n          next();\r\n        });\r\n      } else {\r\n        // We are importing a protocol or schema file.\r\n        opts.importHook(importPath, info.kind, function (err, str) {\r\n          if (err) {\r\n            cb(err);\r\n            return;\r\n          }\r\n          switch (info.kind) {\r\n            case 'protocol':\r\n            case 'schema':\r\n              if (str === undefined) {\r\n                // Skip duplicate import (see related comment above).\r\n                next();\r\n                return;\r\n              }\r\n              try {\r\n                var obj = JSON.parse(str);\r\n              } catch (err) {\r\n                err.path = importPath;\r\n                cb(err);\r\n                return;\r\n              }\r\n              var imported = info.kind === 'schema' ? {types: [obj]} : obj;\r\n              importedProtocols.push(imported);\r\n              next();\r\n              return;\r\n            default:\r\n              cb(new Error(f('invalid import kind: %s', info.kind)));\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  function mergeImport(protocol, imported) {\r\n    // Merge first the types (where we don't need to check for duplicates\r\n    // since instantiating the service will take care of it), then the messages\r\n    // (where we need to, as duplicates will overwrite each other).\r\n    var schemas = imported.types || [];\r\n    schemas.reverse();\r\n    schemas.forEach(function (schema) {\r\n      if (!protocol.types) {\r\n        protocol.types = [];\r\n      }\r\n      // Ensure the imported protocol's namespace is inherited correctly (it\r\n      // might be different from the current one).\r\n      if (schema.namespace === undefined) {\r\n        schema.namespace = protocolNamespace(imported) || '';\r\n      }\r\n      protocol.types.unshift(schema);\r\n    });\r\n    Object.keys(imported.messages || {}).forEach(function (name) {\r\n      if (!protocol.messages) {\r\n        protocol.messages = {};\r\n      }\r\n      if (protocol.messages[name]) {\r\n        throw new Error(f('duplicate message: %s', name));\r\n      }\r\n      protocol.messages[name] = imported.messages[name];\r\n    });\r\n  }\r\n}\r\n\r\n// Parsing functions.\r\n\r\n/**\r\n * Convenience function to parse multiple inputs into protocols and schemas.\r\n *\r\n * It should cover most basic use-cases but has a few limitations:\r\n *\r\n * + It doesn't allow passing options to the parsing step.\r\n * + The protocol/type inference logic can be deceived.\r\n *\r\n * The parsing logic is as follows:\r\n *\r\n * + If `str` contains `path.sep` (on windows `\\`, otherwise `/`) and is a path\r\n *   to an existing file, it will first be read as JSON, then as an IDL\r\n *   specification if JSON parsing failed. If either succeeds, the result is\r\n *   returned, otherwise the next steps are run using the file's content\r\n *   instead of the input path.\r\n * + If `str` is a valid JSON string, it is parsed then returned.\r\n * + If `str` is a valid IDL protocol specification, it is parsed and returned\r\n *   if no imports are present (and an error is thrown if there are any\r\n *   imports).\r\n * + If `str` is a valid IDL type specification, it is parsed and returned.\r\n * + If neither of the above cases apply, `str` is returned.\r\n */\r\nfunction read(str) {\r\n  var schema;\r\n  if (typeof str == 'string' && ~str.indexOf(path.sep) && files.existsSync(str)) {\r\n    // Try interpreting `str` as path to a file contain a JSON schema or an IDL\r\n    // protocol. Note that we add the second check to skip primitive references\r\n    // (e.g. `\"int\"`, the most common use-case for `avro.parse`).\r\n    var contents = files.readFileSync(str, {encoding: 'utf8'});\r\n    try {\r\n      return JSON.parse(contents);\r\n    } catch (err) {\r\n      var opts = {importHook: files.createSyncImportHook()};\r\n      assembleProtocol(str, opts, function (err, protocolSchema) {\r\n        schema = err ? contents : protocolSchema;\r\n      });\r\n    }\r\n  } else {\r\n    schema = str;\r\n  }\r\n  if (typeof schema != 'string' || schema === 'null') {\r\n    // This last predicate is to allow `read('null')` to work similarly to\r\n    // `read('int')` and other primitives (null needs to be handled separately\r\n    // since it is also a valid JSON identifier).\r\n    return schema;\r\n  }\r\n  try {\r\n    return JSON.parse(schema);\r\n  } catch (err) {\r\n    try {\r\n      return Reader.readProtocol(schema);\r\n    } catch (err) {\r\n      try {\r\n        return Reader.readSchema(schema);\r\n      } catch (err) {\r\n        return schema;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction Reader(str, opts) {\r\n  opts = opts || {};\r\n\r\n  this._tk = new Tokenizer(str);\r\n  this._ackVoidMessages = !!opts.ackVoidMessages;\r\n  this._implicitTags = !opts.delimitedCollections;\r\n  this._typeRefs = opts.typeRefs || TYPE_REFS;\r\n}\r\n\r\nReader.readProtocol = function (str, opts) {\r\n  var reader = new Reader(str, opts);\r\n  var protocol = reader._readProtocol();\r\n  if (protocol.imports.length) {\r\n    // Imports can only be resolved when the IDL file is provided via its\r\n    // path, we fail rather than silently ignore imports.\r\n    throw new Error('unresolvable import');\r\n  }\r\n  return protocol.protocol;\r\n};\r\n\r\nReader.readSchema = function (str, opts) {\r\n  var reader = new Reader(str, opts);\r\n  var doc = reader._readJavadoc();\r\n  var schema = reader._readType(doc === undefined ? {} : {doc: doc}, true);\r\n  reader._tk.next({id: '(eof)'}); // Check that we have read everything.\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readProtocol = function () {\r\n  var tk = this._tk;\r\n  var imports = [];\r\n  var types = [];\r\n  var messages = {};\r\n  var pos;\r\n\r\n  // Outer declarations (outside of the protocol block).\r\n  this._readImports(imports);\r\n  var protocolSchema = {};\r\n  var protocolJavadoc = this._readJavadoc();\r\n  if (protocolJavadoc !== undefined) {\r\n    protocolSchema.doc = protocolJavadoc;\r\n  }\r\n  this._readAnnotations(protocolSchema);\r\n  tk.next({val: 'protocol'});\r\n  if (!tk.next({val: '{', silent: true})) {\r\n    // Named protocol.\r\n    protocolSchema.protocol = tk.next({id: 'name'}).val;\r\n    tk.next({val: '{'});\r\n  }\r\n\r\n  // Inner declarations.\r\n  while (!tk.next({val: '}', silent: true})) {\r\n    if (!this._readImports(imports)) {\r\n      var javadoc = this._readJavadoc();\r\n      var typeSchema = this._readType({}, true);\r\n      var numImports = this._readImports(imports, true);\r\n      var message = undefined;\r\n      // We mark our position and try to parse a message from here.\r\n      pos = tk.pos;\r\n      if (!numImports && (message = this._readMessage(typeSchema))) {\r\n        // Note that if any imports were found, we cannot be parsing a message.\r\n        if (javadoc !== undefined && message.schema.doc === undefined) {\r\n          message.schema.doc = javadoc;\r\n        }\r\n        var oneWay = false;\r\n        if (\r\n          message.schema.response === 'void' ||\r\n          message.schema.response.type === 'void'\r\n        ) {\r\n          oneWay = !this._ackVoidMessages && !message.schema.errors;\r\n          if (message.schema.response === 'void') {\r\n            message.schema.response = 'null';\r\n          } else {\r\n            message.schema.response.type = 'null';\r\n          }\r\n        }\r\n        if (oneWay) {\r\n          message.schema['one-way'] = true;\r\n        }\r\n        if (messages[message.name]) {\r\n          // We have to do this check here otherwise the duplicate will be\r\n          // overwritten (and service instantiation won't be able to catch it).\r\n          throw new Error(f('duplicate message: %s', message.name));\r\n        }\r\n        messages[message.name] = message.schema;\r\n      } else {\r\n        // This was a standalone type definition.\r\n        if (javadoc) {\r\n          if (typeof typeSchema == 'string') {\r\n            typeSchema = {doc: javadoc, type: typeSchema};\r\n          } else if (typeSchema.doc === undefined) {\r\n            typeSchema.doc = javadoc;\r\n          }\r\n        }\r\n        types.push(typeSchema);\r\n        // We backtrack until just before the type's type name and swallow an\r\n        // eventual semi-colon (to make type declarations more consistent).\r\n        tk.pos = pos;\r\n        tk.next({val: ';', silent: true});\r\n      }\r\n      javadoc = undefined;\r\n    }\r\n  }\r\n  tk.next({id: '(eof)'});\r\n  if (types.length) {\r\n    protocolSchema.types = types;\r\n  }\r\n  if (Object.keys(messages).length) {\r\n    protocolSchema.messages = messages;\r\n  }\r\n  return {protocol: protocolSchema, imports: imports};\r\n};\r\n\r\nReader.prototype._readAnnotations = function (schema) {\r\n  var tk = this._tk;\r\n  while (tk.next({val: '@', silent: true})) {\r\n    // Annotations are allowed to have names which aren't valid Avro names,\r\n    // we must advance until we hit the first left parenthesis.\r\n    var parts = [];\r\n    while (!tk.next({val: '(', silent: true})) {\r\n      parts.push(tk.next().val);\r\n    }\r\n    schema[parts.join('')] = tk.next({id: 'json'}).val;\r\n    tk.next({val: ')'});\r\n  }\r\n};\r\n\r\nReader.prototype._readMessage = function (responseSchema) {\r\n  var tk = this._tk;\r\n  var schema = {request: [], response: responseSchema};\r\n  this._readAnnotations(schema);\r\n  var name = tk.next().val;\r\n  if (tk.next().val !== '(') {\r\n    // This isn't a message.\r\n    return;\r\n  }\r\n  if (!tk.next({val: ')', silent: true})) {\r\n    do {\r\n      schema.request.push(this._readField());\r\n    } while (!tk.next({val: ')', silent: true}) && tk.next({val: ','}));\r\n  }\r\n  var token = tk.next();\r\n  switch (token.val) {\r\n    case 'throws':\r\n      // It doesn't seem like the IDL is explicit about which syntax to used\r\n      // for multiple errors. We will assume a comma-separated list.\r\n      schema.errors = [];\r\n      do {\r\n        schema.errors.push(this._readType());\r\n      } while (!tk.next({val: ';', silent: true}) && tk.next({val: ','}));\r\n      break;\r\n    case 'oneway':\r\n      schema['one-way'] = true;\r\n      tk.next({val: ';'});\r\n      break;\r\n    case ';':\r\n      break;\r\n    default:\r\n      throw tk.error('invalid message suffix', token);\r\n  }\r\n  return {name: name, schema: schema};\r\n};\r\n\r\nReader.prototype._readJavadoc = function () {\r\n  var token = this._tk.next({id: 'javadoc', emitJavadoc: true, silent: true});\r\n  if (token) {\r\n    return token.val;\r\n  }\r\n};\r\n\r\nReader.prototype._readField = function () {\r\n  var tk = this._tk;\r\n  var javadoc = this._readJavadoc();\r\n  var schema = {type: this._readType()};\r\n  if (javadoc !== undefined && schema.doc === undefined) {\r\n    schema.doc = javadoc;\r\n  }\r\n  this._readAnnotations(schema);\r\n  schema.name = tk.next({id: 'name'}).val;\r\n  if (tk.next({val: '=', silent: true})) {\r\n    schema['default'] = tk.next({id: 'json'}).val;\r\n  }\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readType = function (schema, top) {\r\n  schema = schema || {};\r\n  this._readAnnotations(schema);\r\n  schema.type = this._tk.next({id: 'name'}).val;\r\n  switch (schema.type) {\r\n    case 'record':\r\n    case 'error':\r\n      return this._readRecord(schema);\r\n    case 'fixed':\r\n      return this._readFixed(schema);\r\n    case 'enum':\r\n      return this._readEnum(schema, top);\r\n    case 'map':\r\n      return this._readMap(schema);\r\n    case 'array':\r\n      return this._readArray(schema);\r\n    case 'union':\r\n      if (Object.keys(schema).length > 1) {\r\n        throw new Error('union annotations are not supported');\r\n      }\r\n      return this._readUnion();\r\n    default:\r\n      // Reference.\r\n      var ref = this._typeRefs[schema.type];\r\n      if (ref) {\r\n        delete schema.type; // Always overwrite the type.\r\n        utils.copyOwnProperties(ref, schema);\r\n      }\r\n      return Object.keys(schema).length > 1 ? schema : schema.type;\r\n  }\r\n};\r\n\r\nReader.prototype._readFixed = function (schema) {\r\n  var tk = this._tk;\r\n  if (!tk.next({val: '(', silent: true})) {\r\n    schema.name = tk.next({id: 'name'}).val;\r\n    tk.next({val: '('});\r\n  }\r\n  schema.size = parseInt(tk.next({id: 'number'}).val);\r\n  tk.next({val: ')'});\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readMap = function (schema) {\r\n  var tk = this._tk;\r\n  // Brackets are unwieldy when declaring inline types. We allow for them to be\r\n  // omitted (but we keep the consistency that if the entry bracket is present,\r\n  // the exit one must be as well). Note that this is non-standard.\r\n  var silent = this._implicitTags;\r\n  var implicitTags = tk.next({val: '<', silent: silent}) === undefined;\r\n  schema.values = this._readType();\r\n  tk.next({val: '>', silent: implicitTags});\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readArray = function (schema) {\r\n  var tk = this._tk;\r\n  var silent = this._implicitTags;\r\n  var implicitTags = tk.next({val: '<', silent: silent}) === undefined;\r\n  schema.items = this._readType();\r\n  tk.next({val: '>', silent: implicitTags});\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readEnum = function (schema, top) {\r\n  var tk = this._tk;\r\n  if (!tk.next({val: '{', silent: true})) {\r\n    schema.name = tk.next({id: 'name'}).val;\r\n    tk.next({val: '{'});\r\n  }\r\n  schema.symbols = [];\r\n  do {\r\n    schema.symbols.push(tk.next().val);\r\n  } while (!tk.next({val: '}', silent: true}) && tk.next({val: ','}));\r\n  // To avoid confusing syntax, reader enums (i.e. enums with a default value)\r\n  // can only be defined top-level.\r\n  if (top && tk.next({val: '=', silent: true})) {\r\n    schema.default = tk.next().val;\r\n    tk.next({val: ';'});\r\n  }\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readUnion = function () {\r\n  var tk = this._tk;\r\n  var arr = [];\r\n  tk.next({val: '{'});\r\n  do {\r\n    arr.push(this._readType());\r\n  } while (!tk.next({val: '}', silent: true}) && tk.next({val: ','}));\r\n  return arr;\r\n};\r\n\r\nReader.prototype._readRecord = function (schema) {\r\n  var tk = this._tk;\r\n  if (!tk.next({val: '{', silent: true})) {\r\n    schema.name = tk.next({id: 'name'}).val;\r\n    tk.next({val: '{'});\r\n  }\r\n  schema.fields = [];\r\n  while (!tk.next({val: '}', silent: true})) {\r\n    schema.fields.push(this._readField());\r\n    tk.next({val: ';'});\r\n  }\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readImports = function (imports, maybeMessage) {\r\n  var tk = this._tk;\r\n  var numImports = 0;\r\n  var pos = tk.pos;\r\n  while (tk.next({val: 'import', silent: true})) {\r\n    if (!numImports && maybeMessage && tk.next({val: '(', silent: true})) {\r\n      // This will happen if a message is named import.\r\n      tk.pos = pos;\r\n      return;\r\n    }\r\n    var kind = tk.next({id: 'name'}).val;\r\n    var fname = JSON.parse(tk.next({id: 'string'}).val);\r\n    tk.next({val: ';'});\r\n    imports.push({kind: kind, name: fname});\r\n    numImports++;\r\n  }\r\n  return numImports;\r\n};\r\n\r\n// Helpers.\r\n\r\n/**\r\n * Simple class to split an input string into tokens.\r\n *\r\n * There are different types of tokens, characterized by their `id`:\r\n *\r\n * + `number` numbers.\r\n * + `name` references.\r\n * + `string` double-quoted.\r\n * + `operator`, anything else, always single character.\r\n * + `javadoc`, only emitted when `next` is called with `emitJavadoc` set.\r\n * + `json`, only emitted when `next` is called with `'json'` as `id` (the\r\n *   tokenizer doesn't have enough context to predict these).\r\n */\r\nfunction Tokenizer(str) {\r\n  this._str = str;\r\n  this.pos = 0;\r\n}\r\n\r\nTokenizer.prototype.next = function (opts) {\r\n  var token = {pos: this.pos, id: undefined, val: undefined};\r\n  var javadoc = this._skip(opts && opts.emitJavadoc);\r\n  if (javadoc) {\r\n    token.id = 'javadoc';\r\n    token.val = javadoc;\r\n  } else {\r\n    var pos = this.pos;\r\n    var str = this._str;\r\n    var c = str.charAt(pos);\r\n    if (!c) {\r\n      token.id = '(eof)';\r\n    } else {\r\n      if (opts && opts.id === 'json') {\r\n        token.id = 'json';\r\n        this.pos = this._endOfJson();\r\n      } else if (c === '\"') {\r\n        token.id = 'string';\r\n        this.pos = this._endOfString();\r\n      } else if (/[0-9]/.test(c)) {\r\n        token.id = 'number';\r\n        this.pos = this._endOf(/[0-9]/);\r\n      } else if (/[`A-Za-z_.]/.test(c)) {\r\n        token.id = 'name';\r\n        this.pos = this._endOf(/[`A-Za-z0-9_.]/);\r\n      } else {\r\n        token.id = 'operator';\r\n        this.pos = pos + 1;\r\n      }\r\n      token.val = str.slice(pos, this.pos);\r\n      if (token.id === 'json') {\r\n        // Let's be nice and give a more helpful error message when this occurs\r\n        // (JSON parsing errors wouldn't let us find the location otherwise).\r\n        try {\r\n          token.val = JSON.parse(token.val);\r\n        } catch (err) {\r\n          throw this.error('invalid JSON', token);\r\n        }\r\n      } else if (token.id === 'name') {\r\n        // Unescape names (our parser doesn't need them).\r\n        token.val = token.val.replace(/`/g, '');\r\n      }\r\n    }\r\n  }\r\n\r\n  var err;\r\n  if (opts && opts.id && opts.id !== token.id) {\r\n    err = this.error(f('expected ID %s', opts.id), token);\r\n  } else if (opts && opts.val && opts.val !== token.val) {\r\n    err = this.error(f('expected value %s', opts.val), token);\r\n  }\r\n  if (!err) {\r\n    return token;\r\n  } else if (opts && opts.silent) {\r\n    this.pos = token.pos; // Backtrack to start of token.\r\n    return undefined;\r\n  } else {\r\n    throw err;\r\n  }\r\n};\r\n\r\nTokenizer.prototype.error = function (reason, context) {\r\n  // Context must be either a token or a position.\r\n  var isToken = typeof context != 'number';\r\n  var pos = isToken ? context.pos : context;\r\n  var str = this._str;\r\n  var lineNum = 1;\r\n  var lineStart = 0;\r\n  var i;\r\n  for (i = 0; i < pos; i++) {\r\n    if (str.charAt(i) === '\\n') {\r\n      lineNum++;\r\n      lineStart = i;\r\n    }\r\n  }\r\n  var msg = isToken ? f('invalid token %j: %s', context, reason) : reason;\r\n  var err = new Error(msg);\r\n  err.token = isToken ? context : undefined;\r\n  err.lineNum = lineNum;\r\n  err.colNum = pos - lineStart;\r\n  return err;\r\n};\r\n\r\n/** Skip whitespace and comments. */\r\nTokenizer.prototype._skip = function (emitJavadoc) {\r\n  var str = this._str;\r\n  var isJavadoc = false;\r\n  var pos, c;\r\n\r\n  while ((c = str.charAt(this.pos)) && /\\s/.test(c)) {\r\n    this.pos++;\r\n  }\r\n  pos = this.pos;\r\n  if (c === '/') {\r\n    switch (str.charAt(this.pos + 1)) {\r\n    case '/':\r\n      this.pos += 2;\r\n      while ((c = str.charAt(this.pos)) && c !== '\\n') {\r\n        this.pos++;\r\n      }\r\n      return this._skip(emitJavadoc);\r\n    case '*':\r\n      this.pos += 2;\r\n      if (str.charAt(this.pos) === '*') {\r\n        isJavadoc = true;\r\n      }\r\n      while ((c = str.charAt(this.pos++))) {\r\n        if (c === '*' && str.charAt(this.pos) === '/') {\r\n          this.pos++;\r\n          if (isJavadoc && emitJavadoc) {\r\n            return extractJavadoc(str.slice(pos + 3, this.pos - 2));\r\n          }\r\n          return this._skip(emitJavadoc);\r\n        }\r\n      }\r\n      throw this.error('unterminated comment', pos);\r\n    }\r\n  }\r\n};\r\n\r\n/** Generic end of method. */\r\nTokenizer.prototype._endOf = function (pat) {\r\n  var pos = this.pos;\r\n  var str = this._str;\r\n  while (pat.test(str.charAt(pos))) {\r\n    pos++;\r\n  }\r\n  return pos;\r\n};\r\n\r\n/** Find end of a string. */\r\nTokenizer.prototype._endOfString = function () {\r\n  var pos = this.pos + 1; // Skip first double quote.\r\n  var str = this._str;\r\n  var c;\r\n  while ((c = str.charAt(pos))) {\r\n    if (c === '\"') {\r\n      // The spec doesn't explicitly say so, but IDLs likely only\r\n      // allow double quotes for strings (C- and Java-style).\r\n      return pos + 1;\r\n    }\r\n    if (c === '\\\\') {\r\n      pos += 2;\r\n    } else {\r\n      pos++;\r\n    }\r\n  }\r\n  throw this.error('unterminated string', pos - 1);\r\n};\r\n\r\n/** Find end of JSON object, throwing an error if the end is reached first. */\r\nTokenizer.prototype._endOfJson = function () {\r\n  var pos = utils.jsonEnd(this._str, this.pos);\r\n  if (pos < 0) {\r\n    throw this.error('invalid JSON', pos);\r\n  }\r\n  return pos;\r\n};\r\n\r\n/**\r\n * Extract Javadoc contents from the comment.\r\n *\r\n * The parsing done is very simple and simply removes the line prefixes and\r\n * leading / trailing empty lines. It's better to be conservative with\r\n * formatting rather than risk losing information.\r\n */\r\nfunction extractJavadoc(str) {\r\n  var lines = str\r\n    .replace(/^[ \\t]+|[ \\t]+$/g, '') // Trim whitespace.\r\n    .split('\\n').map(function (line, i) {\r\n      return i ? line.replace(/^\\s*\\*\\s?/, '') : line;\r\n    });\r\n  while (!lines[0]) {\r\n    lines.shift();\r\n  }\r\n  while (!lines[lines.length - 1]) {\r\n    lines.pop();\r\n  }\r\n  return lines.join('\\n');\r\n}\r\n\r\n/** Returns the namespace generated by a protocol. */\r\nfunction protocolNamespace(protocol) {\r\n  if (protocol.namespace) {\r\n    return protocol.namespace;\r\n  }\r\n  var match = /^(.*)\\.[^.]+$/.exec(protocol.protocol);\r\n  return match ? match[1] : undefined;\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  Tokenizer: Tokenizer,\r\n  assembleProtocol: assembleProtocol,\r\n  read: read,\r\n  readProtocol: Reader.readProtocol,\r\n  readSchema: Reader.readSchema\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/specs.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/types.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/types.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\r\n\r\n// TODO: Make it easier to implement custom types. This will likely require\r\n// exposing the `Tap` object, perhaps under another name. Probably worth a\r\n// major release.\r\n// TODO: Allow configuring when to write the size when writing arrays and maps,\r\n// and customizing their block size.\r\n// TODO: Code-generate `compare` and `clone` record and union methods.\r\n\r\n\r\n\r\n/**\r\n * This module defines all Avro data types and their serialization logic.\r\n *\r\n */\r\n\r\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\r\n    buffer = __webpack_require__(/*! buffer */ \"buffer\"), // For `SlowBuffer`.\r\n    util = __webpack_require__(/*! util */ \"util\");\r\n\r\n\r\n// Convenience imports.\r\nvar Tap = utils.Tap;\r\nvar debug = util.debuglog('avsc:types');\r\nvar f = util.format;\r\n\r\n// All non-union concrete (i.e. non-logical) Avro types.\r\nvar TYPES = {\r\n  'array': ArrayType,\r\n  'boolean': BooleanType,\r\n  'bytes': BytesType,\r\n  'double': DoubleType,\r\n  'enum': EnumType,\r\n  'error': RecordType,\r\n  'fixed': FixedType,\r\n  'float': FloatType,\r\n  'int': IntType,\r\n  'long': LongType,\r\n  'map': MapType,\r\n  'null': NullType,\r\n  'record': RecordType,\r\n  'string': StringType\r\n};\r\n\r\n// Random generator.\r\nvar RANDOM = new utils.Lcg();\r\n\r\n// Encoding tap (shared for performance).\r\nvar TAP = new Tap(new buffer.SlowBuffer(1024));\r\n\r\n// Currently active logical type, used for name redirection.\r\nvar LOGICAL_TYPE = null;\r\n\r\n// Underlying types of logical types currently being instantiated. This is used\r\n// to be able to reference names (i.e. for branches) during instantiation.\r\nvar UNDERLYING_TYPES = [];\r\n\r\n/**\r\n * \"Abstract\" base Avro type.\r\n *\r\n * This class' constructor will register any named types to support recursive\r\n * schemas. All type values are represented in memory similarly to their JSON\r\n * representation, except for:\r\n *\r\n * + `bytes` and `fixed` which are represented as `Buffer`s.\r\n * + `union`s which will be \"unwrapped\" unless the `wrapUnions` option is set.\r\n *\r\n *  See individual subclasses for details.\r\n */\r\nfunction Type(schema, opts) {\r\n  var type;\r\n  if (LOGICAL_TYPE) {\r\n    type = LOGICAL_TYPE;\r\n    UNDERLYING_TYPES.push([LOGICAL_TYPE, this]);\r\n    LOGICAL_TYPE = null;\r\n  } else {\r\n    type = this;\r\n  }\r\n\r\n  // Lazily instantiated hash string. It will be generated the first time the\r\n  // type's default fingerprint is computed (for example when using `equals`).\r\n  // We use a mutable object since types are frozen after instantiation.\r\n  this._hash = new Hash();\r\n  this.name = undefined;\r\n  this.aliases = undefined;\r\n  this.doc = (schema && schema.doc) ? '' + schema.doc : undefined;\r\n\r\n  if (schema) {\r\n    // This is a complex (i.e. non-primitive) type.\r\n    var name = schema.name;\r\n    var namespace = schema.namespace === undefined ?\r\n      opts && opts.namespace :\r\n      schema.namespace;\r\n    if (name !== undefined) {\r\n      // This isn't an anonymous type.\r\n      name = maybeQualify(name, namespace);\r\n      if (isPrimitive(name)) {\r\n        // Avro doesn't allow redefining primitive names.\r\n        throw new Error(f('cannot rename primitive type: %j', name));\r\n      }\r\n      var registry = opts && opts.registry;\r\n      if (registry) {\r\n        if (registry[name] !== undefined) {\r\n          throw new Error(f('duplicate type name: %s', name));\r\n        }\r\n        registry[name] = type;\r\n      }\r\n    } else if (opts && opts.noAnonymousTypes) {\r\n      throw new Error(f('missing name property in schema: %j', schema));\r\n    }\r\n    this.name = name;\r\n    this.aliases = schema.aliases ?\r\n      schema.aliases.map(function (s) { return maybeQualify(s, namespace); }) :\r\n      [];\r\n  }\r\n}\r\n\r\nType.forSchema = function (schema, opts) {\r\n  opts = opts || {};\r\n  opts.registry = opts.registry || {};\r\n\r\n  var UnionType = (function (wrapUnions) {\r\n    if (wrapUnions === true) {\r\n      wrapUnions = 'always';\r\n    } else if (wrapUnions === false) {\r\n      wrapUnions = 'never';\r\n    } else if (wrapUnions === undefined) {\r\n      wrapUnions = 'auto';\r\n    } else if (typeof wrapUnions == 'string') {\r\n      wrapUnions = wrapUnions.toLowerCase();\r\n    }\r\n    switch (wrapUnions) {\r\n      case 'always':\r\n        return WrappedUnionType;\r\n      case 'never':\r\n        return UnwrappedUnionType;\r\n      case 'auto':\r\n        return undefined; // Determined dynamically later on.\r\n      default:\r\n        throw new Error(f('invalid wrap unions option: %j', wrapUnions));\r\n    }\r\n  })(opts.wrapUnions);\r\n\r\n  if (schema === null) {\r\n    // Let's be helpful for this common error.\r\n    throw new Error('invalid type: null (did you mean \"null\"?)');\r\n  }\r\n\r\n  if (Type.isType(schema)) {\r\n    return schema;\r\n  }\r\n\r\n  var type;\r\n  if (opts.typeHook && (type = opts.typeHook(schema, opts))) {\r\n    if (!Type.isType(type)) {\r\n      throw new Error(f('invalid typehook return value: %j', type));\r\n    }\r\n    return type;\r\n  }\r\n\r\n  if (typeof schema == 'string') { // Type reference.\r\n    schema = maybeQualify(schema, opts.namespace);\r\n    type = opts.registry[schema];\r\n    if (type) {\r\n      // Type was already defined, return it.\r\n      return type;\r\n    }\r\n    if (isPrimitive(schema)) {\r\n      // Reference to a primitive type. These are also defined names by default\r\n      // so we create the appropriate type and it to the registry for future\r\n      // reference.\r\n      return opts.registry[schema] = Type.forSchema({type: schema}, opts);\r\n    }\r\n    throw new Error(f('undefined type name: %s', schema));\r\n  }\r\n\r\n  if (schema.logicalType && opts.logicalTypes && !LOGICAL_TYPE) {\r\n    var DerivedType = opts.logicalTypes[schema.logicalType];\r\n    if (DerivedType) {\r\n      var namespace = opts.namespace;\r\n      var registry = {};\r\n      Object.keys(opts.registry).forEach(function (key) {\r\n        registry[key] = opts.registry[key];\r\n      });\r\n      try {\r\n        debug('instantiating logical type for %s', schema.logicalType);\r\n        return new DerivedType(schema, opts);\r\n      } catch (err) {\r\n        debug('failed to instantiate logical type for %s', schema.logicalType);\r\n        if (opts.assertLogicalTypes) {\r\n          // The spec mandates that we fall through to the underlying type if\r\n          // the logical type is invalid. We provide this option to ease\r\n          // debugging.\r\n          throw err;\r\n        }\r\n        LOGICAL_TYPE = null;\r\n        opts.namespace = namespace;\r\n        opts.registry = registry;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (Array.isArray(schema)) { // Union.\r\n    // We temporarily clear the logical type since we instantiate the branch's\r\n    // types before the underlying union's type (necessary to decide whether the\r\n    // union is ambiguous or not).\r\n    var logicalType = LOGICAL_TYPE;\r\n    LOGICAL_TYPE = null;\r\n    var types = schema.map(function (obj) {\r\n      return Type.forSchema(obj, opts);\r\n    });\r\n    if (!UnionType) {\r\n      UnionType = isAmbiguous(types) ? WrappedUnionType : UnwrappedUnionType;\r\n    }\r\n    LOGICAL_TYPE = logicalType;\r\n    type = new UnionType(types, opts);\r\n  } else { // New type definition.\r\n    type = (function (typeName) {\r\n      var Type = TYPES[typeName];\r\n      if (Type === undefined) {\r\n        throw new Error(f('unknown type: %j', typeName));\r\n      }\r\n      return new Type(schema, opts);\r\n    })(schema.type);\r\n  }\r\n  return type;\r\n};\r\n\r\nType.forValue = function (val, opts) {\r\n  opts = opts || {};\r\n\r\n  // Sentinel used when inferring the types of empty arrays.\r\n  opts.emptyArrayType = opts.emptyArrayType || Type.forSchema({\r\n    type: 'array', items: 'null'\r\n  });\r\n\r\n  // Optional custom inference hook.\r\n  if (opts.valueHook) {\r\n    var type = opts.valueHook(val, opts);\r\n    if (type !== undefined) {\r\n      if (!Type.isType(type)) {\r\n        throw new Error(f('invalid value hook return value: %j', type));\r\n      }\r\n      return type;\r\n    }\r\n  }\r\n\r\n  // Default inference logic.\r\n  switch (typeof val) {\r\n    case 'string':\r\n      return Type.forSchema('string', opts);\r\n    case 'boolean':\r\n      return Type.forSchema('boolean', opts);\r\n    case 'number':\r\n      if ((val | 0) === val) {\r\n        return Type.forSchema('int', opts);\r\n      } else if (Math.abs(val) < 9007199254740991) {\r\n        return Type.forSchema('float', opts);\r\n      }\r\n      return Type.forSchema('double', opts);\r\n    case 'object':\r\n      if (val === null) {\r\n        return Type.forSchema('null', opts);\r\n      } else if (Array.isArray(val)) {\r\n        if (!val.length) {\r\n          return opts.emptyArrayType;\r\n        }\r\n        return Type.forSchema({\r\n          type: 'array',\r\n          items: Type.forTypes(\r\n            val.map(function (v) { return Type.forValue(v, opts); }),\r\n            opts\r\n          )\r\n        }, opts);\r\n      } else if (Buffer.isBuffer(val)) {\r\n        return Type.forSchema('bytes', opts);\r\n      }\r\n      var fieldNames = Object.keys(val);\r\n      if (fieldNames.some(function (s) { return !utils.isValidName(s); })) {\r\n        // We have to fall back to a map.\r\n        return Type.forSchema({\r\n          type: 'map',\r\n          values: Type.forTypes(fieldNames.map(function (s) {\r\n            return Type.forValue(val[s], opts);\r\n          }), opts)\r\n        }, opts);\r\n      }\r\n      return Type.forSchema({\r\n        type: 'record',\r\n        fields: fieldNames.map(function (s) {\r\n          return {name: s, type: Type.forValue(val[s], opts)};\r\n        })\r\n      }, opts);\r\n    default:\r\n      throw new Error(f('cannot infer type from: %j', val));\r\n  }\r\n};\r\n\r\nType.forTypes = function (types, opts) {\r\n  if (!types.length) {\r\n    throw new Error('no types to combine');\r\n  }\r\n  if (types.length === 1) {\r\n    return types[0]; // Nothing to do.\r\n  }\r\n  opts = opts || {};\r\n\r\n  // Extract any union types, with special care for wrapped unions (see below).\r\n  var expanded = [];\r\n  var numWrappedUnions = 0;\r\n  var isValidWrappedUnion = true;\r\n  types.forEach(function (type) {\r\n    switch (type.typeName) {\r\n      case 'union:unwrapped':\r\n        isValidWrappedUnion = false;\r\n        expanded = expanded.concat(type.types);\r\n        break;\r\n      case 'union:wrapped':\r\n        numWrappedUnions++;\r\n        expanded = expanded.concat(type.types);\r\n        break;\r\n      case 'null':\r\n        expanded.push(type);\r\n        break;\r\n      default:\r\n        isValidWrappedUnion = false;\r\n        expanded.push(type);\r\n    }\r\n  });\r\n  if (numWrappedUnions) {\r\n    if (!isValidWrappedUnion) {\r\n      // It is only valid to combine wrapped unions when no other type is\r\n      // present other than wrapped unions and nulls (otherwise the values of\r\n      // others wouldn't be valid in the resulting union).\r\n      throw new Error('cannot combine wrapped union');\r\n    }\r\n    var branchTypes = {};\r\n    expanded.forEach(function (type) {\r\n      var name = type.branchName;\r\n      var branchType = branchTypes[name];\r\n      if (!branchType) {\r\n        branchTypes[name] = type;\r\n      } else if (!type.equals(branchType)) {\r\n        throw new Error('inconsistent branch type');\r\n      }\r\n    });\r\n    var wrapUnions = opts.wrapUnions;\r\n    var unionType;\r\n    opts.wrapUnions = true;\r\n    try {\r\n      unionType = Type.forSchema(Object.keys(branchTypes).map(function (name) {\r\n        return branchTypes[name];\r\n      }), opts);\r\n    } catch (err) {\r\n      opts.wrapUnions = wrapUnions;\r\n      throw err;\r\n    }\r\n    opts.wrapUnions = wrapUnions;\r\n    return unionType;\r\n  }\r\n\r\n  // Group types by category, similar to the logic for unwrapped unions.\r\n  var bucketized = {};\r\n  expanded.forEach(function (type) {\r\n    var bucket = getTypeBucket(type);\r\n    var bucketTypes = bucketized[bucket];\r\n    if (!bucketTypes) {\r\n      bucketized[bucket] = bucketTypes = [];\r\n    }\r\n    bucketTypes.push(type);\r\n  });\r\n\r\n  // Generate the \"augmented\" type for each group.\r\n  var buckets = Object.keys(bucketized);\r\n  var augmented = buckets.map(function (bucket) {\r\n    var bucketTypes = bucketized[bucket];\r\n    if (bucketTypes.length === 1) {\r\n      return bucketTypes[0];\r\n    } else {\r\n      switch (bucket) {\r\n        case 'null':\r\n        case 'boolean':\r\n          return bucketTypes[0];\r\n        case 'number':\r\n          return combineNumbers(bucketTypes);\r\n        case 'string':\r\n          return combineStrings(bucketTypes, opts);\r\n        case 'buffer':\r\n          return combineBuffers(bucketTypes, opts);\r\n        case 'array':\r\n          // Remove any sentinel arrays (used when inferring from empty arrays)\r\n          // to avoid making things nullable when they shouldn't be.\r\n          bucketTypes = bucketTypes.filter(function (t) {\r\n            return t !== opts.emptyArrayType;\r\n          });\r\n          if (!bucketTypes.length) {\r\n            // We still don't have a real type, just return the sentinel.\r\n            return opts.emptyArrayType;\r\n          }\r\n          return Type.forSchema({\r\n            type: 'array',\r\n            items: Type.forTypes(bucketTypes.map(function (t) {\r\n              return t.itemsType;\r\n            }), opts)\r\n          }, opts);\r\n        default:\r\n          return combineObjects(bucketTypes, opts);\r\n      }\r\n    }\r\n  });\r\n\r\n  if (augmented.length === 1) {\r\n    return augmented[0];\r\n  } else {\r\n    // We return an (unwrapped) union of all augmented types.\r\n    return Type.forSchema(augmented, opts);\r\n  }\r\n};\r\n\r\nType.isType = function (/* any, [prefix] ... */) {\r\n  var l = arguments.length;\r\n  if (!l) {\r\n    return false;\r\n  }\r\n\r\n  var any = arguments[0];\r\n  if (\r\n    !any ||\r\n    typeof any._update != 'function' ||\r\n    typeof any.fingerprint != 'function'\r\n  ) {\r\n    // Not fool-proof, but most likely good enough.\r\n    return false;\r\n  }\r\n\r\n  if (l === 1) {\r\n    // No type names specified, we are done.\r\n    return true;\r\n  }\r\n\r\n  // We check if at least one of the prefixes matches.\r\n  var typeName = any.typeName;\r\n  var i;\r\n  for (i = 1; i < l; i++) {\r\n    if (typeName.indexOf(arguments[i]) === 0) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nType.__reset = function (size) {\r\n  debug('resetting type buffer to %d', size);\r\n  TAP.buf = new buffer.SlowBuffer(size);\r\n};\r\n\r\nObject.defineProperty(Type.prototype, 'branchName', {\r\n  enumerable: true,\r\n  get: function () {\r\n    var type = Type.isType(this, 'logical') ? this.underlyingType : this;\r\n    if (type.name) {\r\n      return type.name;\r\n    }\r\n    if (Type.isType(type, 'abstract')) {\r\n      return type._concreteTypeName;\r\n    }\r\n    return Type.isType(type, 'union') ? undefined : type.typeName;\r\n  }\r\n});\r\n\r\nType.prototype.clone = function (val, opts) {\r\n  if (opts) {\r\n    opts = {\r\n      coerce: !!opts.coerceBuffers | 0, // Coerce JSON to Buffer.\r\n      fieldHook: opts.fieldHook,\r\n      qualifyNames: !!opts.qualifyNames,\r\n      skip: !!opts.skipMissingFields,\r\n      wrap: !!opts.wrapUnions | 0 // Wrap first match into union.\r\n    };\r\n    return this._copy(val, opts);\r\n  } else {\r\n    // If no modifications are required, we can get by with a serialization\r\n    // roundtrip (generally much faster than a standard deep copy).\r\n    return this.fromBuffer(this.toBuffer(val));\r\n  }\r\n};\r\n\r\nType.prototype.compare = utils.abstractFunction;\r\n\r\nType.prototype.compareBuffers = function (buf1, buf2) {\r\n  return this._match(new Tap(buf1), new Tap(buf2));\r\n};\r\n\r\nType.prototype.createResolver = function (type, opts) {\r\n  if (!Type.isType(type)) {\r\n    // More explicit error message than the \"incompatible type\" thrown\r\n    // otherwise (especially because of the overridden `toJSON` method).\r\n    throw new Error(f('not a type: %j', type));\r\n  }\r\n\r\n  if (!Type.isType(this, 'union', 'logical') && Type.isType(type, 'logical')) {\r\n    // Trying to read a logical type as a built-in: unwrap the logical type.\r\n    // Note that we exclude unions to support resolving into unions containing\r\n    // logical types.\r\n    return this.createResolver(type.underlyingType, opts);\r\n  }\r\n\r\n  opts = opts || {};\r\n  opts.registry = opts.registry || {};\r\n\r\n  var resolver, key;\r\n  if (\r\n    Type.isType(this, 'record', 'error') &&\r\n    Type.isType(type, 'record', 'error')\r\n  ) {\r\n    // We allow conversions between records and errors.\r\n    key = this.name + ':' + type.name; // ':' is illegal in Avro type names.\r\n    resolver = opts.registry[key];\r\n    if (resolver) {\r\n      return resolver;\r\n    }\r\n  }\r\n\r\n  resolver = new Resolver(this);\r\n  if (key) { // Register resolver early for recursive schemas.\r\n    opts.registry[key] = resolver;\r\n  }\r\n\r\n  if (Type.isType(type, 'union')) {\r\n    var resolvers = type.types.map(function (t) {\r\n      return this.createResolver(t, opts);\r\n    }, this);\r\n    resolver._read = function (tap) {\r\n      var index = tap.readLong();\r\n      var resolver = resolvers[index];\r\n      if (resolver === undefined) {\r\n        throw new Error(f('invalid union index: %s', index));\r\n      }\r\n      return resolvers[index]._read(tap);\r\n    };\r\n  } else {\r\n    this._update(resolver, type, opts);\r\n  }\r\n\r\n  if (!resolver._read) {\r\n    throw new Error(f('cannot read %s as %s', type, this));\r\n  }\r\n  return Object.freeze(resolver);\r\n};\r\n\r\nType.prototype.decode = function (buf, pos, resolver) {\r\n  var tap = new Tap(buf, pos);\r\n  var val = readValue(this, tap, resolver);\r\n  if (!tap.isValid()) {\r\n    return {value: undefined, offset: -1};\r\n  }\r\n  return {value: val, offset: tap.pos};\r\n};\r\n\r\nType.prototype.encode = function (val, buf, pos) {\r\n  var tap = new Tap(buf, pos);\r\n  this._write(tap, val);\r\n  if (!tap.isValid()) {\r\n    // Don't throw as there is no way to predict this. We also return the\r\n    // number of missing bytes to ease resizing.\r\n    return buf.length - tap.pos;\r\n  }\r\n  return tap.pos;\r\n};\r\n\r\nType.prototype.equals = function (type, opts) {\r\n  var canon = ( // Canonical equality.\r\n    Type.isType(type) &&\r\n    this.fingerprint().equals(type.fingerprint())\r\n  );\r\n  if (!canon || !(opts && opts.strict)) {\r\n    return canon;\r\n  }\r\n  return (\r\n    JSON.stringify(this.schema({exportAttrs: true})) ===\r\n    JSON.stringify(type.schema({exportAttrs: true}))\r\n  );\r\n};\r\n\r\nType.prototype.fingerprint = function (algorithm) {\r\n  if (!algorithm) {\r\n    if (!this._hash.str) {\r\n      var schemaStr = JSON.stringify(this.schema());\r\n      this._hash.str = utils.getHash(schemaStr).toString('binary');\r\n    }\r\n    return utils.bufferFrom(this._hash.str, 'binary');\r\n  } else {\r\n    return utils.getHash(JSON.stringify(this.schema()), algorithm);\r\n  }\r\n};\r\n\r\nType.prototype.fromBuffer = function (buf, resolver, noCheck) {\r\n  var tap = new Tap(buf);\r\n  var val = readValue(this, tap, resolver, noCheck);\r\n  if (!tap.isValid()) {\r\n    throw new Error('truncated buffer');\r\n  }\r\n  if (!noCheck && tap.pos < buf.length) {\r\n    throw new Error('trailing data');\r\n  }\r\n  return val;\r\n};\r\n\r\nType.prototype.fromString = function (str) {\r\n  return this._copy(JSON.parse(str), {coerce: 2});\r\n};\r\n\r\nType.prototype.inspect = function () {\r\n  var typeName = this.typeName;\r\n  var className = getClassName(typeName);\r\n  if (isPrimitive(typeName)) {\r\n    // The class name is sufficient to identify the type.\r\n    return f('<%s>', className);\r\n  } else {\r\n    // We add a little metadata for convenience.\r\n    var obj = this.schema({exportAttrs: true, noDeref: true});\r\n    if (typeof obj == 'object' && !Type.isType(this, 'logical')) {\r\n      obj.type = undefined; // Would be redundant with constructor name.\r\n    }\r\n    return f('<%s %j>', className, obj);\r\n  }\r\n};\r\n\r\nType.prototype.isValid = function (val, opts) {\r\n  // We only have a single flag for now, so no need to complicate things.\r\n  var flags = (opts && opts.noUndeclaredFields) | 0;\r\n  var errorHook = opts && opts.errorHook;\r\n  var hook, path;\r\n  if (errorHook) {\r\n    path = [];\r\n    hook = function (any, type) {\r\n      errorHook.call(this, path.slice(), any, type, val);\r\n    };\r\n  }\r\n  return this._check(val, flags, hook, path);\r\n};\r\n\r\nType.prototype.random = utils.abstractFunction;\r\n\r\nType.prototype.schema = function (opts) {\r\n  // Copy the options to avoid mutating the original options object when we add\r\n  // the registry of dereferenced types.\r\n  return this._attrs({\r\n    exportAttrs: !!(opts && opts.exportAttrs),\r\n    noDeref: !!(opts && opts.noDeref)\r\n  });\r\n};\r\n\r\nType.prototype.toBuffer = function (val) {\r\n  TAP.pos = 0;\r\n  this._write(TAP, val);\r\n  var buf = utils.newBuffer(TAP.pos);\r\n  if (TAP.isValid()) {\r\n    TAP.buf.copy(buf, 0, 0, TAP.pos);\r\n  } else {\r\n    this._write(new Tap(buf), val);\r\n  }\r\n  return buf;\r\n};\r\n\r\nType.prototype.toJSON = function () {\r\n  // Convenience to allow using `JSON.stringify(type)` to get a type's schema.\r\n  return this.schema({exportAttrs: true});\r\n};\r\n\r\nType.prototype.toString = function (val) {\r\n  if (val === undefined) {\r\n    // Consistent behavior with standard `toString` expectations.\r\n    return JSON.stringify(this.schema({noDeref: true}));\r\n  }\r\n  return JSON.stringify(this._copy(val, {coerce: 3}));\r\n};\r\n\r\nType.prototype.wrap = function (val) {\r\n  var Branch = this._branchConstructor;\r\n  return Branch === null ? null : new Branch(val);\r\n};\r\n\r\nType.prototype._attrs = function (opts) {\r\n  // This function handles a lot of the common logic to schema generation\r\n  // across types, for example keeping track of which types have already been\r\n  // de-referenced (i.e. derefed).\r\n  opts.derefed = opts.derefed || {};\r\n  var name = this.name;\r\n  if (name !== undefined) {\r\n    if (opts.noDeref || opts.derefed[name]) {\r\n      return name;\r\n    }\r\n    opts.derefed[name] = true;\r\n  }\r\n  var schema = {};\r\n  // The order in which we add fields to the `schema` object matters here.\r\n  // Since JS objects are unordered, this implementation (unfortunately) relies\r\n  // on engines returning properties in the same order that they are inserted\r\n  // in. This is not in the JS spec, but can be \"somewhat\" safely assumed (see\r\n  // http://stackoverflow.com/q/5525795/1062617).\r\n  if (this.name !== undefined) {\r\n    schema.name = name;\r\n  }\r\n  schema.type = this.typeName;\r\n  var derefedSchema = this._deref(schema, opts);\r\n  if (derefedSchema !== undefined) {\r\n    // We allow the original schema to be overridden (this will happen for\r\n    // primitive types and logical types).\r\n    schema = derefedSchema;\r\n  }\r\n  if (opts.exportAttrs) {\r\n    if (this.aliases && this.aliases.length) {\r\n      schema.aliases = this.aliases;\r\n    }\r\n    if (this.doc !== undefined) {\r\n      schema.doc = this.doc;\r\n    }\r\n  }\r\n  return schema;\r\n};\r\n\r\nType.prototype._createBranchConstructor = function () {\r\n  // jshint -W054\r\n  var name = this.branchName;\r\n  if (name === 'null') {\r\n    return null;\r\n  }\r\n  var attr = ~name.indexOf('.') ? 'this[\\'' + name + '\\']' : 'this.' + name;\r\n  var body = 'return function Branch$(val) { ' + attr + ' = val; };';\r\n  var Branch = (new Function(body))();\r\n  Branch.type = this;\r\n  Branch.prototype.unwrap = new Function('return ' + attr + ';');\r\n  Branch.prototype.unwrapped = Branch.prototype.unwrap; // Deprecated.\r\n  return Branch;\r\n};\r\n\r\nType.prototype._peek = function (tap) {\r\n  var pos = tap.pos;\r\n  var val = this._read(tap);\r\n  tap.pos = pos;\r\n  return val;\r\n};\r\n\r\nType.prototype._check = utils.abstractFunction;\r\nType.prototype._copy = utils.abstractFunction;\r\nType.prototype._deref = utils.abstractFunction;\r\nType.prototype._match = utils.abstractFunction;\r\nType.prototype._read = utils.abstractFunction;\r\nType.prototype._skip = utils.abstractFunction;\r\nType.prototype._update = utils.abstractFunction;\r\nType.prototype._write = utils.abstractFunction;\r\n\r\n// \"Deprecated\" getters (will be explicitly deprecated in 5.1).\r\n\r\nType.prototype.getAliases = function () { return this.aliases; };\r\n\r\nType.prototype.getFingerprint = Type.prototype.fingerprint;\r\n\r\nType.prototype.getName = function (asBranch) {\r\n  return (this.name || !asBranch) ? this.name : this.branchName;\r\n};\r\n\r\nType.prototype.getSchema = Type.prototype.schema;\r\n\r\nType.prototype.getTypeName = function () { return this.typeName; };\r\n\r\n// Implementations.\r\n\r\n/**\r\n * Base primitive Avro type.\r\n *\r\n * Most of the primitive types share the same cloning and resolution\r\n * mechanisms, provided by this class. This class also lets us conveniently\r\n * check whether a type is a primitive using `instanceof`.\r\n */\r\nfunction PrimitiveType(noFreeze) {\r\n  Type.call(this);\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  if (!noFreeze) {\r\n    // Abstract long types can't be frozen at this stage.\r\n    Object.freeze(this);\r\n  }\r\n}\r\nutil.inherits(PrimitiveType, Type);\r\n\r\nPrimitiveType.prototype._update = function (resolver, type) {\r\n  if (type.typeName === this.typeName) {\r\n    resolver._read = this._read;\r\n  }\r\n};\r\n\r\nPrimitiveType.prototype._copy = function (val) {\r\n  this._check(val, undefined, throwInvalidError);\r\n  return val;\r\n};\r\n\r\nPrimitiveType.prototype._deref = function () { return this.typeName; };\r\n\r\nPrimitiveType.prototype.compare = utils.compare;\r\n\r\n/** Nulls. */\r\nfunction NullType() { PrimitiveType.call(this); }\r\nutil.inherits(NullType, PrimitiveType);\r\n\r\nNullType.prototype._check = function (val, flags, hook) {\r\n  var b = val === null;\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nNullType.prototype._read = function () { return null; };\r\n\r\nNullType.prototype._skip = function () {};\r\n\r\nNullType.prototype._write = function (tap, val) {\r\n  if (val !== null) {\r\n    throwInvalidError(val, this);\r\n  }\r\n};\r\n\r\nNullType.prototype._match = function () { return 0; };\r\n\r\nNullType.prototype.compare = NullType.prototype._match;\r\n\r\nNullType.prototype.typeName = 'null';\r\n\r\nNullType.prototype.random = NullType.prototype._read;\r\n\r\n/** Booleans. */\r\nfunction BooleanType() { PrimitiveType.call(this); }\r\nutil.inherits(BooleanType, PrimitiveType);\r\n\r\nBooleanType.prototype._check = function (val, flags, hook) {\r\n  var b = typeof val == 'boolean';\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nBooleanType.prototype._read = function (tap) { return tap.readBoolean(); };\r\n\r\nBooleanType.prototype._skip = function (tap) { tap.skipBoolean(); };\r\n\r\nBooleanType.prototype._write = function (tap, val) {\r\n  if (typeof val != 'boolean') {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeBoolean(val);\r\n};\r\n\r\nBooleanType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchBoolean(tap2);\r\n};\r\n\r\nBooleanType.prototype.typeName = 'boolean';\r\n\r\nBooleanType.prototype.random = function () { return RANDOM.nextBoolean(); };\r\n\r\n/** Integers. */\r\nfunction IntType() { PrimitiveType.call(this); }\r\nutil.inherits(IntType, PrimitiveType);\r\n\r\nIntType.prototype._check = function (val, flags, hook) {\r\n  var b = val === (val | 0);\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nIntType.prototype._read = function (tap) { return tap.readInt(); };\r\n\r\nIntType.prototype._skip = function (tap) { tap.skipInt(); };\r\n\r\nIntType.prototype._write = function (tap, val) {\r\n  if (val !== (val | 0)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeInt(val);\r\n};\r\n\r\nIntType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchInt(tap2);\r\n};\r\n\r\nIntType.prototype.typeName = 'int';\r\n\r\nIntType.prototype.random = function () { return RANDOM.nextInt(1000) | 0; };\r\n\r\n/**\r\n * Longs.\r\n *\r\n * We can't capture all the range unfortunately since JavaScript represents all\r\n * numbers internally as `double`s, so the default implementation plays safe\r\n * and throws rather than potentially silently change the data. See `__with` or\r\n * `AbstractLongType` below for a way to implement a custom long type.\r\n */\r\nfunction LongType() { PrimitiveType.call(this); }\r\nutil.inherits(LongType, PrimitiveType);\r\n\r\nLongType.prototype._check = function (val, flags, hook) {\r\n  var b = typeof val == 'number' && val % 1 === 0 && isSafeLong(val);\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nLongType.prototype._read = function (tap) {\r\n  var n = tap.readLong();\r\n  if (!isSafeLong(n)) {\r\n    throw new Error('potential precision loss');\r\n  }\r\n  return n;\r\n};\r\n\r\nLongType.prototype._skip = function (tap) { tap.skipLong(); };\r\n\r\nLongType.prototype._write = function (tap, val) {\r\n  if (typeof val != 'number' || val % 1 || !isSafeLong(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeLong(val);\r\n};\r\n\r\nLongType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchLong(tap2);\r\n};\r\n\r\nLongType.prototype._update = function (resolver, type) {\r\n  switch (type.typeName) {\r\n    case 'int':\r\n      resolver._read = type._read;\r\n      break;\r\n    case 'abstract:long':\r\n    case 'long':\r\n      resolver._read = this._read; // In case `type` is an `AbstractLongType`.\r\n  }\r\n};\r\n\r\nLongType.prototype.typeName = 'long';\r\n\r\nLongType.prototype.random = function () { return RANDOM.nextInt(); };\r\n\r\nLongType.__with = function (methods, noUnpack) {\r\n  methods = methods || {}; // Will give a more helpful error message.\r\n  // We map some of the methods to a different name to be able to intercept\r\n  // their input and output (otherwise we wouldn't be able to perform any\r\n  // unpacking logic, and the type wouldn't work when nested).\r\n  var mapping = {\r\n    toBuffer: '_toBuffer',\r\n    fromBuffer: '_fromBuffer',\r\n    fromJSON: '_fromJSON',\r\n    toJSON: '_toJSON',\r\n    isValid: '_isValid',\r\n    compare: 'compare'\r\n  };\r\n  var type = new AbstractLongType(noUnpack);\r\n  Object.keys(mapping).forEach(function (name) {\r\n    if (methods[name] === undefined) {\r\n      throw new Error(f('missing method implementation: %s', name));\r\n    }\r\n    type[mapping[name]] = methods[name];\r\n  });\r\n  return Object.freeze(type);\r\n};\r\n\r\n/** Floats. */\r\nfunction FloatType() { PrimitiveType.call(this); }\r\nutil.inherits(FloatType, PrimitiveType);\r\n\r\nFloatType.prototype._check = function (val, flags, hook) {\r\n  var b = typeof val == 'number';\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nFloatType.prototype._read = function (tap) { return tap.readFloat(); };\r\n\r\nFloatType.prototype._skip = function (tap) { tap.skipFloat(); };\r\n\r\nFloatType.prototype._write = function (tap, val) {\r\n  if (typeof val != 'number') {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeFloat(val);\r\n};\r\n\r\nFloatType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchFloat(tap2);\r\n};\r\n\r\nFloatType.prototype._update = function (resolver, type) {\r\n  switch (type.typeName) {\r\n    case 'float':\r\n    case 'int':\r\n      resolver._read = type._read;\r\n      break;\r\n    case 'abstract:long':\r\n    case 'long':\r\n      // No need to worry about precision loss here since we're always rounding\r\n      // to float anyway.\r\n      resolver._read = function (tap) { return tap.readLong(); };\r\n  }\r\n};\r\n\r\nFloatType.prototype.typeName = 'float';\r\n\r\nFloatType.prototype.random = function () { return RANDOM.nextFloat(1e3); };\r\n\r\n/** Doubles. */\r\nfunction DoubleType() { PrimitiveType.call(this); }\r\nutil.inherits(DoubleType, PrimitiveType);\r\n\r\nDoubleType.prototype._check = function (val, flags, hook) {\r\n  var b = typeof val == 'number';\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nDoubleType.prototype._read = function (tap) { return tap.readDouble(); };\r\n\r\nDoubleType.prototype._skip = function (tap) { tap.skipDouble(); };\r\n\r\nDoubleType.prototype._write = function (tap, val) {\r\n  if (typeof val != 'number') {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeDouble(val);\r\n};\r\n\r\nDoubleType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchDouble(tap2);\r\n};\r\n\r\nDoubleType.prototype._update = function (resolver, type) {\r\n  switch (type.typeName) {\r\n    case 'double':\r\n    case 'float':\r\n    case 'int':\r\n      resolver._read = type._read;\r\n      break;\r\n    case 'abstract:long':\r\n    case 'long':\r\n      // Similar to inside `FloatType`, no need to worry about precision loss\r\n      // here since we're always rounding to double anyway.\r\n      resolver._read = function (tap) { return tap.readLong(); };\r\n  }\r\n};\r\n\r\nDoubleType.prototype.typeName = 'double';\r\n\r\nDoubleType.prototype.random = function () { return RANDOM.nextFloat(); };\r\n\r\n/** Strings. */\r\nfunction StringType() { PrimitiveType.call(this); }\r\nutil.inherits(StringType, PrimitiveType);\r\n\r\nStringType.prototype._check = function (val, flags, hook) {\r\n  var b = typeof val == 'string';\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nStringType.prototype._read = function (tap) { return tap.readString(); };\r\n\r\nStringType.prototype._skip = function (tap) { tap.skipString(); };\r\n\r\nStringType.prototype._write = function (tap, val) {\r\n  if (typeof val != 'string') {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeString(val);\r\n};\r\n\r\nStringType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchString(tap2);\r\n};\r\n\r\nStringType.prototype._update = function (resolver, type) {\r\n  switch (type.typeName) {\r\n    case 'bytes':\r\n    case 'string':\r\n      resolver._read = this._read;\r\n  }\r\n};\r\n\r\nStringType.prototype.typeName = 'string';\r\n\r\nStringType.prototype.random = function () {\r\n  return RANDOM.nextString(RANDOM.nextInt(32));\r\n};\r\n\r\n/**\r\n * Bytes.\r\n *\r\n * These are represented in memory as `Buffer`s rather than binary-encoded\r\n * strings. This is more efficient (when decoding/encoding from bytes, the\r\n * common use-case), idiomatic, and convenient.\r\n *\r\n * Note the coercion in `_copy`.\r\n */\r\nfunction BytesType() { PrimitiveType.call(this); }\r\nutil.inherits(BytesType, PrimitiveType);\r\n\r\nBytesType.prototype._check = function (val, flags, hook) {\r\n  var b = Buffer.isBuffer(val);\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nBytesType.prototype._read = function (tap) { return tap.readBytes(); };\r\n\r\nBytesType.prototype._skip = function (tap) { tap.skipBytes(); };\r\n\r\nBytesType.prototype._write = function (tap, val) {\r\n  if (!Buffer.isBuffer(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeBytes(val);\r\n};\r\n\r\nBytesType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchBytes(tap2);\r\n};\r\n\r\nBytesType.prototype._update = StringType.prototype._update;\r\n\r\nBytesType.prototype._copy = function (obj, opts) {\r\n  var buf;\r\n  switch ((opts && opts.coerce) | 0) {\r\n    case 3: // Coerce buffers to strings.\r\n      this._check(obj, undefined, throwInvalidError);\r\n      return obj.toString('binary');\r\n    case 2: // Coerce strings to buffers.\r\n      if (typeof obj != 'string') {\r\n        throw new Error(f('cannot coerce to buffer: %j', obj));\r\n      }\r\n      buf = utils.bufferFrom(obj, 'binary');\r\n      this._check(buf, undefined, throwInvalidError);\r\n      return buf;\r\n    case 1: // Coerce buffer JSON representation to buffers.\r\n      if (!isJsonBuffer(obj)) {\r\n        throw new Error(f('cannot coerce to buffer: %j', obj));\r\n      }\r\n      buf = utils.bufferFrom(obj.data);\r\n      this._check(buf, undefined, throwInvalidError);\r\n      return buf;\r\n    default: // Copy buffer.\r\n      this._check(obj, undefined, throwInvalidError);\r\n      return utils.bufferFrom(obj);\r\n  }\r\n};\r\n\r\nBytesType.prototype.compare = Buffer.compare;\r\n\r\nBytesType.prototype.typeName = 'bytes';\r\n\r\nBytesType.prototype.random = function () {\r\n  return RANDOM.nextBuffer(RANDOM.nextInt(32));\r\n};\r\n\r\n/** Base \"abstract\" Avro union type. */\r\nfunction UnionType(schema, opts) {\r\n  Type.call(this);\r\n\r\n  if (!Array.isArray(schema)) {\r\n    throw new Error(f('non-array union schema: %j', schema));\r\n  }\r\n  if (!schema.length) {\r\n    throw new Error('empty union');\r\n  }\r\n  this.types = Object.freeze(schema.map(function (obj) {\r\n    return Type.forSchema(obj, opts);\r\n  }));\r\n\r\n  this._branchIndices = {};\r\n  this.types.forEach(function (type, i) {\r\n    if (Type.isType(type, 'union')) {\r\n      throw new Error('unions cannot be directly nested');\r\n    }\r\n    var branch = type.branchName;\r\n    if (this._branchIndices[branch] !== undefined) {\r\n      throw new Error(f('duplicate union branch name: %j', branch));\r\n    }\r\n    this._branchIndices[branch] = i;\r\n  }, this);\r\n}\r\nutil.inherits(UnionType, Type);\r\n\r\nUnionType.prototype._branchConstructor = function () {\r\n  throw new Error('unions cannot be directly wrapped');\r\n};\r\n\r\nUnionType.prototype._skip = function (tap) {\r\n  this.types[tap.readLong()]._skip(tap);\r\n};\r\n\r\nUnionType.prototype._match = function (tap1, tap2) {\r\n  var n1 = tap1.readLong();\r\n  var n2 = tap2.readLong();\r\n  if (n1 === n2) {\r\n    return this.types[n1]._match(tap1, tap2);\r\n  } else {\r\n    return n1 < n2 ? -1 : 1;\r\n  }\r\n};\r\n\r\nUnionType.prototype._deref = function (schema, opts) {\r\n  return this.types.map(function (t) { return t._attrs(opts); });\r\n};\r\n\r\nUnionType.prototype.getTypes = function () { return this.types; };\r\n\r\n/**\r\n * \"Natural\" union type.\r\n *\r\n * This representation doesn't require a wrapping object and is therefore\r\n * simpler and generally closer to what users expect. However it cannot be used\r\n * to represent all Avro unions since some lead to ambiguities (e.g. if two\r\n * number types are in the union).\r\n *\r\n * Currently, this union supports at most one type in each of the categories\r\n * below:\r\n *\r\n * + `null`\r\n * + `boolean`\r\n * + `int`, `long`, `float`, `double`\r\n * + `string`, `enum`\r\n * + `bytes`, `fixed`\r\n * + `array`\r\n * + `map`, `record`\r\n */\r\nfunction UnwrappedUnionType(schema, opts) {\r\n  UnionType.call(this, schema, opts);\r\n\r\n  this._dynamicBranches = null;\r\n  this._bucketIndices = {};\r\n  this.types.forEach(function (type, index) {\r\n    if (Type.isType(type, 'abstract', 'logical')) {\r\n      if (!this._dynamicBranches) {\r\n        this._dynamicBranches = [];\r\n      }\r\n      this._dynamicBranches.push({index: index, type: type});\r\n    } else {\r\n      var bucket = getTypeBucket(type);\r\n      if (this._bucketIndices[bucket] !== undefined) {\r\n        throw new Error(f('ambiguous unwrapped union: %j', this));\r\n      }\r\n      this._bucketIndices[bucket] = index;\r\n    }\r\n  }, this);\r\n\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(UnwrappedUnionType, UnionType);\r\n\r\nUnwrappedUnionType.prototype._getIndex = function (val) {\r\n  var index = this._bucketIndices[getValueBucket(val)];\r\n  if (this._dynamicBranches) {\r\n    // Slower path, we must run the value through all branches.\r\n    index = this._getBranchIndex(val, index);\r\n  }\r\n  return index;\r\n};\r\n\r\nUnwrappedUnionType.prototype._getBranchIndex = function (any, index) {\r\n  var logicalBranches = this._dynamicBranches;\r\n  var i, l, branch;\r\n  for (i = 0, l = logicalBranches.length; i < l; i++) {\r\n    branch = logicalBranches[i];\r\n    if (branch.type._check(any)) {\r\n      if (index === undefined) {\r\n        index = branch.index;\r\n      } else {\r\n        // More than one branch matches the value so we aren't guaranteed to\r\n        // infer the correct type. We throw rather than corrupt data. This can\r\n        // be fixed by \"tightening\" the logical types.\r\n        throw new Error('ambiguous conversion');\r\n      }\r\n    }\r\n  }\r\n  return index;\r\n};\r\n\r\nUnwrappedUnionType.prototype._check = function (val, flags, hook, path) {\r\n  var index = this._getIndex(val);\r\n  var b = index !== undefined;\r\n  if (b) {\r\n    return this.types[index]._check(val, flags, hook, path);\r\n  }\r\n  if (hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nUnwrappedUnionType.prototype._read = function (tap) {\r\n  var index = tap.readLong();\r\n  var branchType = this.types[index];\r\n  if (branchType) {\r\n    return branchType._read(tap);\r\n  } else {\r\n    throw new Error(f('invalid union index: %s', index));\r\n  }\r\n};\r\n\r\nUnwrappedUnionType.prototype._write = function (tap, val) {\r\n  var index = this._getIndex(val);\r\n  if (index === undefined) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeLong(index);\r\n  if (val !== null) {\r\n    this.types[index]._write(tap, val);\r\n  }\r\n};\r\n\r\nUnwrappedUnionType.prototype._update = function (resolver, type, opts) {\r\n  // jshint -W083\r\n  // (The loop exits after the first function is created.)\r\n  var i, l, typeResolver;\r\n  for (i = 0, l = this.types.length; i < l; i++) {\r\n    try {\r\n      typeResolver = this.types[i].createResolver(type, opts);\r\n    } catch (err) {\r\n      continue;\r\n    }\r\n    resolver._read = function (tap) { return typeResolver._read(tap); };\r\n    return;\r\n  }\r\n};\r\n\r\nUnwrappedUnionType.prototype._copy = function (val, opts) {\r\n  var coerce = opts && opts.coerce | 0;\r\n  var wrap = opts && opts.wrap | 0;\r\n  var index;\r\n  if (wrap === 2) {\r\n    // We are parsing a default, so always use the first branch's type.\r\n    index = 0;\r\n  } else {\r\n    switch (coerce) {\r\n      case 1:\r\n        // Using the `coerceBuffers` option can cause corruption and erroneous\r\n        // failures with unwrapped unions (in rare cases when the union also\r\n        // contains a record which matches a buffer's JSON representation).\r\n        if (isJsonBuffer(val) && this._bucketIndices.buffer !== undefined) {\r\n          index = this._bucketIndices.buffer;\r\n        } else {\r\n          index = this._getIndex(val);\r\n        }\r\n        break;\r\n      case 2:\r\n        // Decoding from JSON, we must unwrap the value.\r\n        if (val === null) {\r\n          index = this._bucketIndices['null'];\r\n        } else if (typeof val === 'object') {\r\n          var keys = Object.keys(val);\r\n          if (keys.length === 1) {\r\n            index = this._branchIndices[keys[0]];\r\n            val = val[keys[0]];\r\n          }\r\n        }\r\n        break;\r\n      default:\r\n        index = this._getIndex(val);\r\n    }\r\n    if (index === undefined) {\r\n      throwInvalidError(val, this);\r\n    }\r\n  }\r\n  var type = this.types[index];\r\n  if (val === null || wrap === 3) {\r\n    return type._copy(val, opts);\r\n  } else {\r\n    switch (coerce) {\r\n      case 3:\r\n        // Encoding to JSON, we wrap the value.\r\n        var obj = {};\r\n        obj[type.branchName] = type._copy(val, opts);\r\n        return obj;\r\n      default:\r\n        return type._copy(val, opts);\r\n    }\r\n  }\r\n};\r\n\r\nUnwrappedUnionType.prototype.compare = function (val1, val2) {\r\n  var index1 = this._getIndex(val1);\r\n  var index2 = this._getIndex(val2);\r\n  if (index1 === undefined) {\r\n    throwInvalidError(val1, this);\r\n  } else if (index2 === undefined) {\r\n    throwInvalidError(val2, this);\r\n  } else if (index1 === index2) {\r\n    return this.types[index1].compare(val1, val2);\r\n  } else {\r\n    return utils.compare(index1, index2);\r\n  }\r\n};\r\n\r\nUnwrappedUnionType.prototype.typeName = 'union:unwrapped';\r\n\r\nUnwrappedUnionType.prototype.random = function () {\r\n  var index = RANDOM.nextInt(this.types.length);\r\n  return this.types[index].random();\r\n};\r\n\r\n/**\r\n * Compatible union type.\r\n *\r\n * Values of this type are represented in memory similarly to their JSON\r\n * representation (i.e. inside an object with single key the name of the\r\n * contained type).\r\n *\r\n * This is not ideal, but is the most efficient way to unambiguously support\r\n * all unions. Here are a few reasons why the wrapping object is necessary:\r\n *\r\n * + Unions with multiple number types would have undefined behavior, unless\r\n *   numbers are wrapped (either everywhere, leading to large performance and\r\n *   convenience costs; or only when necessary inside unions, making it hard to\r\n *   understand when numbers are wrapped or not).\r\n * + Fixed types would have to be wrapped to be distinguished from bytes.\r\n * + Using record's constructor names would work (after a slight change to use\r\n *   the fully qualified name), but would mean that generic objects could no\r\n *   longer be valid records (making it inconvenient to do simple things like\r\n *   creating new records).\r\n */\r\nfunction WrappedUnionType(schema, opts) {\r\n  UnionType.call(this, schema, opts);\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(WrappedUnionType, UnionType);\r\n\r\nWrappedUnionType.prototype._check = function (val, flags, hook, path) {\r\n  var b = false;\r\n  if (val === null) {\r\n    // Shortcut type lookup in this case.\r\n    b = this._branchIndices['null'] !== undefined;\r\n  } else if (typeof val == 'object') {\r\n    var keys = Object.keys(val);\r\n    if (keys.length === 1) {\r\n      // We require a single key here to ensure that writes are correct and\r\n      // efficient as soon as a record passes this check.\r\n      var name = keys[0];\r\n      var index = this._branchIndices[name];\r\n      if (index !== undefined) {\r\n        if (hook) {\r\n          // Slow path.\r\n          path.push(name);\r\n          b = this.types[index]._check(val[name], flags, hook, path);\r\n          path.pop();\r\n          return b;\r\n        } else {\r\n          return this.types[index]._check(val[name], flags);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nWrappedUnionType.prototype._read = function (tap) {\r\n  var type = this.types[tap.readLong()];\r\n  if (!type) {\r\n    throw new Error(f('invalid union index'));\r\n  }\r\n  var Branch = type._branchConstructor;\r\n  if (Branch === null) {\r\n    return null;\r\n  } else {\r\n    return new Branch(type._read(tap));\r\n  }\r\n};\r\n\r\nWrappedUnionType.prototype._write = function (tap, val) {\r\n  var index, keys, name;\r\n  if (val === null) {\r\n    index = this._branchIndices['null'];\r\n    if (index === undefined) {\r\n      throwInvalidError(val, this);\r\n    }\r\n    tap.writeLong(index);\r\n  } else {\r\n    keys = Object.keys(val);\r\n    if (keys.length === 1) {\r\n      name = keys[0];\r\n      index = this._branchIndices[name];\r\n    }\r\n    if (index === undefined) {\r\n      throwInvalidError(val, this);\r\n    }\r\n    tap.writeLong(index);\r\n    this.types[index]._write(tap, val[name]);\r\n  }\r\n};\r\n\r\nWrappedUnionType.prototype._update = function (resolver, type, opts) {\r\n  // jshint -W083\r\n  // (The loop exits after the first function is created.)\r\n  var i, l, typeResolver, Branch;\r\n  for (i = 0, l = this.types.length; i < l; i++) {\r\n    try {\r\n      typeResolver = this.types[i].createResolver(type, opts);\r\n    } catch (err) {\r\n      continue;\r\n    }\r\n    Branch = this.types[i]._branchConstructor;\r\n    if (Branch) {\r\n      resolver._read = function (tap) {\r\n        return new Branch(typeResolver._read(tap));\r\n      };\r\n    } else {\r\n      resolver._read = function () { return null; };\r\n    }\r\n    return;\r\n  }\r\n};\r\n\r\nWrappedUnionType.prototype._copy = function (val, opts) {\r\n  var wrap = opts && opts.wrap | 0;\r\n  if (wrap === 2) {\r\n    var firstType = this.types[0];\r\n    // Promote into first type (used for schema defaults).\r\n    if (val === null && firstType.typeName === 'null') {\r\n      return null;\r\n    }\r\n    return new firstType._branchConstructor(firstType._copy(val, opts));\r\n  }\r\n  if (val === null && this._branchIndices['null'] !== undefined) {\r\n    return null;\r\n  }\r\n\r\n  var i, l, obj;\r\n  if (typeof val == 'object') {\r\n    var keys = Object.keys(val);\r\n    if (keys.length === 1) {\r\n      var name = keys[0];\r\n      i = this._branchIndices[name];\r\n      if (i === undefined && opts.qualifyNames) {\r\n        // We are a bit more flexible than in `_check` here since we have\r\n        // to deal with other serializers being less strict, so we fall\r\n        // back to looking up unqualified names.\r\n        var j, type;\r\n        for (j = 0, l = this.types.length; j < l; j++) {\r\n          type = this.types[j];\r\n          if (type.name && name === utils.unqualify(type.name)) {\r\n            i = j;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      if (i !== undefined) {\r\n        obj = this.types[i]._copy(val[name], opts);\r\n      }\r\n    }\r\n  }\r\n  if (wrap === 1 && obj === undefined) {\r\n    // Try promoting into first match (convenience, slow).\r\n    i = 0;\r\n    l = this.types.length;\r\n    while (i < l && obj === undefined) {\r\n      try {\r\n        obj = this.types[i]._copy(val, opts);\r\n      } catch (err) {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n  if (obj !== undefined) {\r\n    return wrap === 3 ? obj : new this.types[i]._branchConstructor(obj);\r\n  }\r\n  throwInvalidError(val, this);\r\n};\r\n\r\nWrappedUnionType.prototype.compare = function (val1, val2) {\r\n  var name1 = val1 === null ? 'null' : Object.keys(val1)[0];\r\n  var name2 = val2 === null ? 'null' : Object.keys(val2)[0];\r\n  var index = this._branchIndices[name1];\r\n  if (name1 === name2) {\r\n    return name1 === 'null' ?\r\n      0 :\r\n      this.types[index].compare(val1[name1], val2[name1]);\r\n  } else {\r\n    return utils.compare(index, this._branchIndices[name2]);\r\n  }\r\n};\r\n\r\nWrappedUnionType.prototype.typeName = 'union:wrapped';\r\n\r\nWrappedUnionType.prototype.random = function () {\r\n  var index = RANDOM.nextInt(this.types.length);\r\n  var type = this.types[index];\r\n  var Branch = type._branchConstructor;\r\n  if (!Branch) {\r\n    return null;\r\n  }\r\n  return new Branch(type.random());\r\n};\r\n\r\n/**\r\n * Avro enum type.\r\n *\r\n * Represented as strings (with allowed values from the set of symbols). Using\r\n * integers would be a reasonable option, but the performance boost is arguably\r\n * offset by the legibility cost and the extra deviation from the JSON encoding\r\n * convention.\r\n *\r\n * An integer representation can still be used (e.g. for compatibility with\r\n * TypeScript `enum`s) by overriding the `EnumType` with a `LongType` (e.g. via\r\n * `parse`'s registry).\r\n */\r\nfunction EnumType(schema, opts) {\r\n  Type.call(this, schema, opts);\r\n  if (!Array.isArray(schema.symbols) || !schema.symbols.length) {\r\n    throw new Error(f('invalid enum symbols: %j', schema.symbols));\r\n  }\r\n  this.symbols = Object.freeze(schema.symbols.slice());\r\n  this._indices = {};\r\n  this.symbols.forEach(function (symbol, i) {\r\n    if (!utils.isValidName(symbol)) {\r\n      throw new Error(f('invalid %s symbol: %j', this, symbol));\r\n    }\r\n    if (this._indices[symbol] !== undefined) {\r\n      throw new Error(f('duplicate %s symbol: %j', this, symbol));\r\n    }\r\n    this._indices[symbol] = i;\r\n  }, this);\r\n  this.default = schema.default;\r\n  if (this.default !== undefined && this._indices[this.default] === undefined) {\r\n    throw new Error(f('invalid %s default: %j', this, this.default));\r\n  }\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(EnumType, Type);\r\n\r\nEnumType.prototype._check = function (val, flags, hook) {\r\n  var b = this._indices[val] !== undefined;\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nEnumType.prototype._read = function (tap) {\r\n  var index = tap.readLong();\r\n  var symbol = this.symbols[index];\r\n  if (symbol === undefined) {\r\n    throw new Error(f('invalid %s enum index: %s', this.name, index));\r\n  }\r\n  return symbol;\r\n};\r\n\r\nEnumType.prototype._skip = function (tap) { tap.skipLong(); };\r\n\r\nEnumType.prototype._write = function (tap, val) {\r\n  var index = this._indices[val];\r\n  if (index === undefined) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeLong(index);\r\n};\r\n\r\nEnumType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchLong(tap2);\r\n};\r\n\r\nEnumType.prototype.compare = function (val1, val2) {\r\n  return utils.compare(this._indices[val1], this._indices[val2]);\r\n};\r\n\r\nEnumType.prototype._update = function (resolver, type, opts) {\r\n  var symbols = this.symbols;\r\n  if (\r\n    type.typeName === 'enum' &&\r\n    hasCompatibleName(this, type, !opts.ignoreNamespaces) &&\r\n    (\r\n      type.symbols.every(function (s) { return ~symbols.indexOf(s); }) ||\r\n      this.default !== undefined\r\n    )\r\n  ) {\r\n    resolver.symbols = type.symbols.map(function (s) {\r\n      return this._indices[s] === undefined ? this.default : s;\r\n    }, this);\r\n    resolver._read = type._read;\r\n  }\r\n};\r\n\r\nEnumType.prototype._copy = function (val) {\r\n  this._check(val, undefined, throwInvalidError);\r\n  return val;\r\n};\r\n\r\nEnumType.prototype._deref = function (schema) {\r\n  schema.symbols = this.symbols;\r\n};\r\n\r\nEnumType.prototype.getSymbols = function () { return this.symbols; };\r\n\r\nEnumType.prototype.typeName = 'enum';\r\n\r\nEnumType.prototype.random = function () {\r\n  return RANDOM.choice(this.symbols);\r\n};\r\n\r\n/** Avro fixed type. Represented simply as a `Buffer`. */\r\nfunction FixedType(schema, opts) {\r\n  Type.call(this, schema, opts);\r\n  if (schema.size !== (schema.size | 0) || schema.size < 0) {\r\n    throw new Error(f('invalid %s size', this.branchName));\r\n  }\r\n  this.size = schema.size | 0;\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(FixedType, Type);\r\n\r\nFixedType.prototype._check = function (val, flags, hook) {\r\n  var b = Buffer.isBuffer(val) && val.length === this.size;\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nFixedType.prototype._read = function (tap) {\r\n  return tap.readFixed(this.size);\r\n};\r\n\r\nFixedType.prototype._skip = function (tap) {\r\n  tap.skipFixed(this.size);\r\n};\r\n\r\nFixedType.prototype._write = function (tap, val) {\r\n  if (!Buffer.isBuffer(val) || val.length !== this.size) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeFixed(val, this.size);\r\n};\r\n\r\nFixedType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchFixed(tap2, this.size);\r\n};\r\n\r\nFixedType.prototype.compare = Buffer.compare;\r\n\r\nFixedType.prototype._update = function (resolver, type, opts) {\r\n  if (\r\n    type.typeName === 'fixed' &&\r\n    this.size === type.size &&\r\n    hasCompatibleName(this, type, !opts.ignoreNamespaces)\r\n  ) {\r\n    resolver.size = this.size;\r\n    resolver._read = this._read;\r\n  }\r\n};\r\n\r\nFixedType.prototype._copy = BytesType.prototype._copy;\r\n\r\nFixedType.prototype._deref = function (schema) { schema.size = this.size; };\r\n\r\nFixedType.prototype.getSize = function () { return this.size; };\r\n\r\nFixedType.prototype.typeName = 'fixed';\r\n\r\nFixedType.prototype.random = function () {\r\n  return RANDOM.nextBuffer(this.size);\r\n};\r\n\r\n/** Avro map. Represented as vanilla objects. */\r\nfunction MapType(schema, opts) {\r\n  Type.call(this);\r\n  if (!schema.values) {\r\n    throw new Error(f('missing map values: %j', schema));\r\n  }\r\n  this.valuesType = Type.forSchema(schema.values, opts);\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(MapType, Type);\r\n\r\nMapType.prototype._check = function (val, flags, hook, path) {\r\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\r\n    if (hook) {\r\n      hook(val, this);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  var keys = Object.keys(val);\r\n  var b = true;\r\n  var i, l, j, key;\r\n  if (hook) {\r\n    // Slow path.\r\n    j = path.length;\r\n    path.push('');\r\n    for (i = 0, l = keys.length; i < l; i++) {\r\n      key = path[j] = keys[i];\r\n      if (!this.valuesType._check(val[key], flags, hook, path)) {\r\n        b = false;\r\n      }\r\n    }\r\n    path.pop();\r\n  } else {\r\n    for (i = 0, l = keys.length; i < l; i++) {\r\n      if (!this.valuesType._check(val[keys[i]], flags)) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return b;\r\n};\r\n\r\nMapType.prototype._read = function (tap) {\r\n  var values = this.valuesType;\r\n  var val = {};\r\n  var n;\r\n  while ((n = readArraySize(tap))) {\r\n    while (n--) {\r\n      var key = tap.readString();\r\n      val[key] = values._read(tap);\r\n    }\r\n  }\r\n  return val;\r\n};\r\n\r\nMapType.prototype._skip = function (tap) {\r\n  var values = this.valuesType;\r\n  var len, n;\r\n  while ((n = tap.readLong())) {\r\n    if (n < 0) {\r\n      len = tap.readLong();\r\n      tap.pos += len;\r\n    } else {\r\n      while (n--) {\r\n        tap.skipString();\r\n        values._skip(tap);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nMapType.prototype._write = function (tap, val) {\r\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n\r\n  var values = this.valuesType;\r\n  var keys = Object.keys(val);\r\n  var n = keys.length;\r\n  var i, key;\r\n  if (n) {\r\n    tap.writeLong(n);\r\n    for (i = 0; i < n; i++) {\r\n      key = keys[i];\r\n      tap.writeString(key);\r\n      values._write(tap, val[key]);\r\n    }\r\n  }\r\n  tap.writeLong(0);\r\n};\r\n\r\nMapType.prototype._match = function () {\r\n  throw new Error('maps cannot be compared');\r\n};\r\n\r\nMapType.prototype._update = function (rsv, type, opts) {\r\n  if (type.typeName === 'map') {\r\n    rsv.valuesType = this.valuesType.createResolver(type.valuesType, opts);\r\n    rsv._read = this._read;\r\n  }\r\n};\r\n\r\nMapType.prototype._copy = function (val, opts) {\r\n  if (val && typeof val == 'object' && !Array.isArray(val)) {\r\n    var values = this.valuesType;\r\n    var keys = Object.keys(val);\r\n    var i, l, key;\r\n    var copy = {};\r\n    for (i = 0, l = keys.length; i < l; i++) {\r\n      key = keys[i];\r\n      copy[key] = values._copy(val[key], opts);\r\n    }\r\n    return copy;\r\n  }\r\n  throwInvalidError(val, this);\r\n};\r\n\r\nMapType.prototype.compare = MapType.prototype._match;\r\n\r\nMapType.prototype.typeName = 'map';\r\n\r\nMapType.prototype.getValuesType = function () { return this.valuesType; };\r\n\r\nMapType.prototype.random = function () {\r\n  var val = {};\r\n  var i, l;\r\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\r\n    val[RANDOM.nextString(RANDOM.nextInt(20))] = this.valuesType.random();\r\n  }\r\n  return val;\r\n};\r\n\r\nMapType.prototype._deref = function (schema, opts) {\r\n  schema.values = this.valuesType._attrs(opts);\r\n};\r\n\r\n/** Avro array. Represented as vanilla arrays. */\r\nfunction ArrayType(schema, opts) {\r\n  Type.call(this);\r\n  if (!schema.items) {\r\n    throw new Error(f('missing array items: %j', schema));\r\n  }\r\n  this.itemsType = Type.forSchema(schema.items, opts);\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(ArrayType, Type);\r\n\r\nArrayType.prototype._check = function (val, flags, hook, path) {\r\n  if (!Array.isArray(val)) {\r\n    if (hook) {\r\n      hook(val, this);\r\n    }\r\n    return false;\r\n  }\r\n  var items = this.itemsType;\r\n  var b = true;\r\n  var i, l, j;\r\n  if (hook) {\r\n    // Slow path.\r\n    j = path.length;\r\n    path.push('');\r\n    for (i = 0, l = val.length; i < l; i++) {\r\n      path[j] = '' + i;\r\n      if (!items._check(val[i], flags, hook, path)) {\r\n        b = false;\r\n      }\r\n    }\r\n    path.pop();\r\n  } else {\r\n    for (i = 0, l = val.length; i < l; i++) {\r\n      if (!items._check(val[i], flags)) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return b;\r\n};\r\n\r\nArrayType.prototype._read = function (tap) {\r\n  var items = this.itemsType;\r\n  var i = 0;\r\n  var val, n;\r\n  while ((n = tap.readLong())) {\r\n    if (n < 0) {\r\n      n = -n;\r\n      tap.skipLong(); // Skip size.\r\n    }\r\n    // Initializing the array on the first batch gives a ~10% speedup. See\r\n    // https://github.com/mtth/avsc/pull/338 for more context.\r\n    val = val || new Array(n)\r\n    while (n--) {\r\n      val[i++] = items._read(tap);\r\n    }\r\n  }\r\n  return val || [];\r\n};\r\n\r\nArrayType.prototype._skip = function (tap) {\r\n  var items = this.itemsType;\r\n  var len, n;\r\n  while ((n = tap.readLong())) {\r\n    if (n < 0) {\r\n      len = tap.readLong();\r\n      tap.pos += len;\r\n    } else {\r\n      while (n--) {\r\n        items._skip(tap);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nArrayType.prototype._write = function (tap, val) {\r\n  if (!Array.isArray(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  var items = this.itemsType;\r\n  var n = val.length;\r\n  var i;\r\n  if (n) {\r\n    tap.writeLong(n);\r\n    for (i = 0; i < n; i++) {\r\n      items._write(tap, val[i]);\r\n    }\r\n  }\r\n  tap.writeLong(0);\r\n};\r\n\r\nArrayType.prototype._match = function (tap1, tap2) {\r\n  var n1 = tap1.readLong();\r\n  var n2 = tap2.readLong();\r\n  var f;\r\n  while (n1 && n2) {\r\n    f = this.itemsType._match(tap1, tap2);\r\n    if (f) {\r\n      return f;\r\n    }\r\n    if (!--n1) {\r\n      n1 = readArraySize(tap1);\r\n    }\r\n    if (!--n2) {\r\n      n2 = readArraySize(tap2);\r\n    }\r\n  }\r\n  return utils.compare(n1, n2);\r\n};\r\n\r\nArrayType.prototype._update = function (resolver, type, opts) {\r\n  if (type.typeName === 'array') {\r\n    resolver.itemsType = this.itemsType.createResolver(type.itemsType, opts);\r\n    resolver._read = this._read;\r\n  }\r\n};\r\n\r\nArrayType.prototype._copy = function (val, opts) {\r\n  if (!Array.isArray(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  var items = new Array(val.length);\r\n  var i, l;\r\n  for (i = 0, l = val.length; i < l; i++) {\r\n    items[i] = this.itemsType._copy(val[i], opts);\r\n  }\r\n  return items;\r\n};\r\n\r\nArrayType.prototype._deref = function (schema, opts) {\r\n  schema.items = this.itemsType._attrs(opts);\r\n};\r\n\r\nArrayType.prototype.compare = function (val1, val2) {\r\n  var n1 = val1.length;\r\n  var n2 = val2.length;\r\n  var i, l, f;\r\n  for (i = 0, l = Math.min(n1, n2); i < l; i++) {\r\n    if ((f = this.itemsType.compare(val1[i], val2[i]))) {\r\n      return f;\r\n    }\r\n  }\r\n  return utils.compare(n1, n2);\r\n};\r\n\r\nArrayType.prototype.getItemsType = function () { return this.itemsType; };\r\n\r\nArrayType.prototype.typeName = 'array';\r\n\r\nArrayType.prototype.random = function () {\r\n  var arr = [];\r\n  var i, l;\r\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\r\n    arr.push(this.itemsType.random());\r\n  }\r\n  return arr;\r\n};\r\n\r\n/**\r\n * Avro record.\r\n *\r\n * Values are represented as instances of a programmatically generated\r\n * constructor (similar to a \"specific record\"), available via the\r\n * `getRecordConstructor` method. This \"specific record class\" gives\r\n * significant speedups over using generics objects.\r\n *\r\n * Note that vanilla objects are still accepted as valid as long as their\r\n * fields match (this makes it much more convenient to do simple things like\r\n * update nested records).\r\n *\r\n * This type is also used for errors (similar, except for the extra `Error`\r\n * constructor call) and for messages (see comment below).\r\n */\r\nfunction RecordType(schema, opts) {\r\n  // Force creation of the options object in case we need to register this\r\n  // record's name.\r\n  opts = opts || {};\r\n\r\n  // Save the namespace to restore it as we leave this record's scope.\r\n  var namespace = opts.namespace;\r\n  if (schema.namespace !== undefined) {\r\n    opts.namespace = schema.namespace;\r\n  } else if (schema.name) {\r\n    // Fully qualified names' namespaces are used when no explicit namespace\r\n    // attribute was specified.\r\n    var ns = utils.impliedNamespace(schema.name);\r\n    if (ns !== undefined) {\r\n      opts.namespace = ns;\r\n    }\r\n  }\r\n  Type.call(this, schema, opts);\r\n\r\n  if (!Array.isArray(schema.fields)) {\r\n    throw new Error(f('non-array record fields: %j', schema.fields));\r\n  }\r\n  if (utils.hasDuplicates(schema.fields, function (f) { return f.name; })) {\r\n    throw new Error(f('duplicate field name: %j', schema.fields));\r\n  }\r\n  this._fieldsByName = {};\r\n  this.fields = Object.freeze(schema.fields.map(function (f) {\r\n    var field = new Field(f, opts);\r\n    this._fieldsByName[field.name] = field;\r\n    return field;\r\n  }, this));\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  this._isError = schema.type === 'error';\r\n  this.recordConstructor = this._createConstructor(\r\n    opts.errorStackTraces,\r\n    opts.omitRecordMethods\r\n  );\r\n  this._read = this._createReader();\r\n  this._skip = this._createSkipper();\r\n  this._write = this._createWriter();\r\n  this._check = this._createChecker();\r\n\r\n  opts.namespace = namespace;\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(RecordType, Type);\r\n\r\nRecordType.prototype._getConstructorName = function () {\r\n  return this.name ?\r\n    utils.capitalize(utils.unqualify(this.name)) :\r\n    this._isError ? 'Error$' : 'Record$';\r\n};\r\n\r\nRecordType.prototype._createConstructor = function (errorStack, plainRecords) {\r\n  // jshint -W054\r\n  var outerArgs = [];\r\n  var innerArgs = [];\r\n  var ds = []; // Defaults.\r\n  var innerBody = '';\r\n  var i, l, field, name, defaultValue, hasDefault, stackField;\r\n  for (i = 0, l = this.fields.length; i < l; i++) {\r\n    field = this.fields[i];\r\n    defaultValue = field.defaultValue;\r\n    hasDefault = defaultValue() !== undefined;\r\n    name = field.name;\r\n    if (\r\n      errorStack && this._isError && name === 'stack' &&\r\n      Type.isType(field.type, 'string') && !hasDefault\r\n    ) {\r\n      // We keep track of whether we've encountered a valid stack field (in\r\n      // particular, without a default) to populate a stack trace below.\r\n      stackField = field;\r\n    }\r\n    innerArgs.push('v' + i);\r\n    innerBody += '  ';\r\n    if (!hasDefault) {\r\n      innerBody += 'this.' + name + ' = v' + i + ';\\n';\r\n    } else {\r\n      innerBody += 'if (v' + i + ' === undefined) { ';\r\n      innerBody += 'this.' + name + ' = d' + ds.length + '(); ';\r\n      innerBody += '} else { this.' + name + ' = v' + i + '; }\\n';\r\n      outerArgs.push('d' + ds.length);\r\n      ds.push(defaultValue);\r\n    }\r\n  }\r\n  if (stackField) {\r\n    // We should populate a stack trace.\r\n    innerBody += '  if (this.stack === undefined) { ';\r\n    /* istanbul ignore else */\r\n    if (typeof Error.captureStackTrace == 'function') {\r\n      // v8 runtimes, the easy case.\r\n      innerBody += 'Error.captureStackTrace(this, this.constructor);';\r\n    } else {\r\n      // A few other runtimes (e.g. SpiderMonkey), might not work everywhere.\r\n      innerBody += 'this.stack = Error().stack;';\r\n    }\r\n    innerBody += ' }\\n';\r\n  }\r\n  var outerBody = 'return function ' + this._getConstructorName() + '(';\r\n  outerBody += innerArgs.join() + ') {\\n' + innerBody + '};';\r\n  var Record = new Function(outerArgs.join(), outerBody).apply(undefined, ds);\r\n  if (plainRecords) {\r\n    return Record;\r\n  }\r\n\r\n  var self = this;\r\n  Record.getType = function () { return self; };\r\n  Record.type = self;\r\n  if (this._isError) {\r\n    util.inherits(Record, Error);\r\n    Record.prototype.name = this._getConstructorName();\r\n  }\r\n  Record.prototype.clone = function (o) { return self.clone(this, o); };\r\n  Record.prototype.compare = function (v) { return self.compare(this, v); };\r\n  Record.prototype.isValid = function (o) { return self.isValid(this, o); };\r\n  Record.prototype.toBuffer = function () { return self.toBuffer(this); };\r\n  Record.prototype.toString = function () { return self.toString(this); };\r\n  Record.prototype.wrap = function () { return self.wrap(this); };\r\n  Record.prototype.wrapped = Record.prototype.wrap; // Deprecated.\r\n  return Record;\r\n};\r\n\r\nRecordType.prototype._createChecker = function () {\r\n  // jshint -W054\r\n  var names = [];\r\n  var values = [];\r\n  var name = this._getConstructorName();\r\n  var body = 'return function check' + name + '(v, f, h, p) {\\n';\r\n  body += '  if (\\n';\r\n  body += '    v === null ||\\n';\r\n  body += '    typeof v != \\'object\\' ||\\n';\r\n  body += '    (f && !this._checkFields(v))\\n';\r\n  body += '  ) {\\n';\r\n  body += '    if (h) { h(v, this); }\\n';\r\n  body += '    return false;\\n';\r\n  body += '  }\\n';\r\n  if (!this.fields.length) {\r\n    // Special case, empty record. We handle this directly.\r\n    body += '  return true;\\n';\r\n  } else {\r\n    for (i = 0, l = this.fields.length; i < l; i++) {\r\n      field = this.fields[i];\r\n      names.push('t' + i);\r\n      values.push(field.type);\r\n      if (field.defaultValue() !== undefined) {\r\n        body += '  var v' + i + ' = v.' + field.name + ';\\n';\r\n      }\r\n    }\r\n    body += '  if (h) {\\n';\r\n    body += '    var b = 1;\\n';\r\n    body += '    var j = p.length;\\n';\r\n    body += '    p.push(\\'\\');\\n';\r\n    var i, l, field;\r\n    for (i = 0, l = this.fields.length; i < l; i++) {\r\n      field = this.fields[i];\r\n      body += '    p[j] = \\'' + field.name + '\\';\\n';\r\n      body += '    b &= ';\r\n      if (field.defaultValue() === undefined) {\r\n        body += 't' + i + '._check(v.' + field.name + ', f, h, p);\\n';\r\n      } else {\r\n        body += 'v' + i + ' === undefined || ';\r\n        body += 't' + i + '._check(v' + i + ', f, h, p);\\n';\r\n      }\r\n    }\r\n    body += '    p.pop();\\n';\r\n    body += '    return !!b;\\n';\r\n    body += '  } else {\\n    return (\\n      ';\r\n    body += this.fields.map(function (field, i) {\r\n      return field.defaultValue() === undefined ?\r\n        't' + i + '._check(v.' + field.name + ', f)' :\r\n        '(v' + i + ' === undefined || t' + i + '._check(v' + i + ', f))';\r\n    }).join(' &&\\n      ');\r\n    body += '\\n    );\\n  }\\n';\r\n  }\r\n  body += '};';\r\n  return new Function(names.join(), body).apply(undefined, values);\r\n};\r\n\r\nRecordType.prototype._createReader = function () {\r\n  // jshint -W054\r\n  var names = [];\r\n  var values = [this.recordConstructor];\r\n  var i, l;\r\n  for (i = 0, l = this.fields.length; i < l; i++) {\r\n    names.push('t' + i);\r\n    values.push(this.fields[i].type);\r\n  }\r\n  var name = this._getConstructorName();\r\n  var body = 'return function read' + name + '(t) {\\n';\r\n  body += '  return new ' + name + '(\\n    ';\r\n  body += names.map(function (s) { return s + '._read(t)'; }).join(',\\n    ');\r\n  body += '\\n  );\\n};';\r\n  names.unshift(name);\r\n  // We can do this since the JS spec guarantees that function arguments are\r\n  // evaluated from left to right.\r\n  return new Function(names.join(), body).apply(undefined, values);\r\n};\r\n\r\nRecordType.prototype._createSkipper = function () {\r\n  // jshint -W054\r\n  var args = [];\r\n  var body = 'return function skip' + this._getConstructorName() + '(t) {\\n';\r\n  var values = [];\r\n  var i, l;\r\n  for (i = 0, l = this.fields.length; i < l; i++) {\r\n    args.push('t' + i);\r\n    values.push(this.fields[i].type);\r\n    body += '  t' + i + '._skip(t);\\n';\r\n  }\r\n  body += '}';\r\n  return new Function(args.join(), body).apply(undefined, values);\r\n};\r\n\r\nRecordType.prototype._createWriter = function () {\r\n  // jshint -W054\r\n  // We still do default handling here, in case a normal JS object is passed.\r\n  var args = [];\r\n  var name = this._getConstructorName();\r\n  var body = 'return function write' + name + '(t, v) {\\n';\r\n  var values = [];\r\n  var i, l, field, value;\r\n  for (i = 0, l = this.fields.length; i < l; i++) {\r\n    field = this.fields[i];\r\n    args.push('t' + i);\r\n    values.push(field.type);\r\n    body += '  ';\r\n    if (field.defaultValue() === undefined) {\r\n      body += 't' + i + '._write(t, v.' + field.name + ');\\n';\r\n    } else {\r\n      value = field.type.toBuffer(field.defaultValue()).toString('binary');\r\n      // Convert the default value to a binary string ahead of time. We aren't\r\n      // converting it to a buffer to avoid retaining too much memory. If we\r\n      // had our own buffer pool, this could be an idea in the future.\r\n      args.push('d' + i);\r\n      values.push(value);\r\n      body += 'var v' + i + ' = v.' + field.name + ';\\n';\r\n      body += 'if (v' + i + ' === undefined) {\\n';\r\n      body += '    t.writeBinary(d' + i + ', ' + value.length + ');\\n';\r\n      body += '  } else {\\n    t' + i + '._write(t, v' + i + ');\\n  }\\n';\r\n    }\r\n  }\r\n  body += '}';\r\n  return new Function(args.join(), body).apply(undefined, values);\r\n};\r\n\r\nRecordType.prototype._update = function (resolver, type, opts) {\r\n  // jshint -W054\r\n  if (!hasCompatibleName(this, type, !opts.ignoreNamespaces)) {\r\n    throw new Error(f('no alias found for %s', type.name));\r\n  }\r\n\r\n  var rFields = this.fields;\r\n  var wFields = type.fields;\r\n  var wFieldsMap = utils.toMap(wFields, function (f) { return f.name; });\r\n\r\n  var innerArgs = []; // Arguments for reader constructor.\r\n  var resolvers = {}; // Resolvers keyed by writer field name.\r\n  var i, j, field, name, names, matches, fieldResolver;\r\n  for (i = 0; i < rFields.length; i++) {\r\n    field = rFields[i];\r\n    names = getAliases(field);\r\n    matches = [];\r\n    for (j = 0; j < names.length; j++) {\r\n      name = names[j];\r\n      if (wFieldsMap[name]) {\r\n        matches.push(name);\r\n      }\r\n    }\r\n    if (matches.length > 1) {\r\n      throw new Error(\r\n        f('ambiguous aliasing for %s.%s (%s)', type.name, field.name, matches)\r\n      );\r\n    }\r\n    if (!matches.length) {\r\n      if (field.defaultValue() === undefined) {\r\n        throw new Error(\r\n          f('no matching field for default-less %s.%s', type.name, field.name)\r\n        );\r\n      }\r\n      innerArgs.push('undefined');\r\n    } else {\r\n      name = matches[0];\r\n      fieldResolver = {\r\n        resolver: field.type.createResolver(wFieldsMap[name].type, opts),\r\n        name: '_' + field.name, // Reader field name.\r\n      };\r\n      if (!resolvers[name]) {\r\n        resolvers[name] = [fieldResolver];\r\n      } else {\r\n        resolvers[name].push(fieldResolver);\r\n      }\r\n      innerArgs.push(fieldResolver.name);\r\n    }\r\n  }\r\n\r\n  // See if we can add a bypass for unused fields at the end of the record.\r\n  var lazyIndex = -1;\r\n  i = wFields.length;\r\n  while (i && resolvers[wFields[--i].name] === undefined) {\r\n    lazyIndex = i;\r\n  }\r\n\r\n  var uname = this._getConstructorName();\r\n  var args = [uname];\r\n  var values = [this.recordConstructor];\r\n  var body = '  return function read' + uname + '(t, b) {\\n';\r\n  for (i = 0; i < wFields.length; i++) {\r\n    if (i === lazyIndex) {\r\n      body += '  if (!b) {\\n';\r\n    }\r\n    field = type.fields[i];\r\n    name = field.name;\r\n    if (resolvers[name] === undefined) {\r\n      body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';\r\n      args.push('r' + i);\r\n      values.push(field.type);\r\n      body += 'r' + i + '._skip(t);\\n';\r\n    } else {\r\n      j = resolvers[name].length;\r\n      while (j--) {\r\n        body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';\r\n        args.push('r' + i + 'f' + j);\r\n        fieldResolver = resolvers[name][j];\r\n        values.push(fieldResolver.resolver);\r\n        body += 'var ' + fieldResolver.name + ' = ';\r\n        body += 'r' + i + 'f' + j + '._' + (j ? 'peek' : 'read') + '(t);\\n';\r\n      }\r\n    }\r\n  }\r\n  if (~lazyIndex) {\r\n    body += '  }\\n';\r\n  }\r\n  body += '  return new ' + uname + '(' + innerArgs.join() + ');\\n};';\r\n\r\n  resolver._read = new Function(args.join(), body).apply(undefined, values);\r\n};\r\n\r\nRecordType.prototype._match = function (tap1, tap2) {\r\n  var fields = this.fields;\r\n  var i, l, field, order, type;\r\n  for (i = 0, l = fields.length; i < l; i++) {\r\n    field = fields[i];\r\n    order = field._order;\r\n    type = field.type;\r\n    if (order) {\r\n      order *= type._match(tap1, tap2);\r\n      if (order) {\r\n        return order;\r\n      }\r\n    } else {\r\n      type._skip(tap1);\r\n      type._skip(tap2);\r\n    }\r\n  }\r\n  return 0;\r\n};\r\n\r\nRecordType.prototype._checkFields = function (obj) {\r\n  var keys = Object.keys(obj);\r\n  var i, l;\r\n  for (i = 0, l = keys.length; i < l; i++) {\r\n    if (!this._fieldsByName[keys[i]]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nRecordType.prototype._copy = function (val, opts) {\r\n  // jshint -W058\r\n  var hook = opts && opts.fieldHook;\r\n  var values = [undefined];\r\n  var i, l, field, value;\r\n  for (i = 0, l = this.fields.length; i < l; i++) {\r\n    field = this.fields[i];\r\n    value = val[field.name];\r\n    if (value === undefined && field.hasOwnProperty('defaultValue')) {\r\n      value = field.defaultValue();\r\n    }\r\n    if ((opts && !opts.skip) || value !== undefined) {\r\n      value = field.type._copy(value, opts);\r\n    }\r\n    if (hook) {\r\n      value = hook(field, value, this);\r\n    }\r\n    values.push(value);\r\n  }\r\n  var Record = this.recordConstructor;\r\n  return new (Record.bind.apply(Record, values))();\r\n};\r\n\r\nRecordType.prototype._deref = function (schema, opts) {\r\n  schema.fields = this.fields.map(function (field) {\r\n    var fieldType = field.type;\r\n    var fieldSchema = {\r\n      name: field.name,\r\n      type: fieldType._attrs(opts)\r\n    };\r\n    if (opts.exportAttrs) {\r\n      var val = field.defaultValue();\r\n      if (val !== undefined) {\r\n        // We must both unwrap all unions and coerce buffers to strings.\r\n        fieldSchema['default'] = fieldType._copy(val, {coerce: 3, wrap: 3});\r\n      }\r\n      var fieldOrder = field.order;\r\n      if (fieldOrder !== 'ascending') {\r\n        fieldSchema.order = fieldOrder;\r\n      }\r\n      var fieldAliases = field.aliases;\r\n      if (fieldAliases.length) {\r\n        fieldSchema.aliases = fieldAliases;\r\n      }\r\n      var fieldDoc = field.doc;\r\n      if (fieldDoc !== undefined) {\r\n        fieldSchema.doc = fieldDoc;\r\n      }\r\n    }\r\n    return fieldSchema;\r\n  });\r\n};\r\n\r\nRecordType.prototype.compare = function (val1, val2) {\r\n  var fields = this.fields;\r\n  var i, l, field, name, order, type;\r\n  for (i = 0, l = fields.length; i < l; i++) {\r\n    field = fields[i];\r\n    name = field.name;\r\n    order = field._order;\r\n    type = field.type;\r\n    if (order) {\r\n      order *= type.compare(val1[name], val2[name]);\r\n      if (order) {\r\n        return order;\r\n      }\r\n    }\r\n  }\r\n  return 0;\r\n};\r\n\r\nRecordType.prototype.random = function () {\r\n  // jshint -W058\r\n  var fields = this.fields.map(function (f) { return f.type.random(); });\r\n  fields.unshift(undefined);\r\n  var Record = this.recordConstructor;\r\n  return new (Record.bind.apply(Record, fields))();\r\n};\r\n\r\nRecordType.prototype.field = function (name) {\r\n  return this._fieldsByName[name];\r\n};\r\n\r\nRecordType.prototype.getField = RecordType.prototype.field;\r\n\r\nRecordType.prototype.getFields = function () { return this.fields; };\r\n\r\nRecordType.prototype.getRecordConstructor = function () {\r\n  return this.recordConstructor;\r\n};\r\n\r\nObject.defineProperty(RecordType.prototype, 'typeName', {\r\n  enumerable: true,\r\n  get: function () { return this._isError ? 'error' : 'record'; }\r\n});\r\n\r\n/** Derived type abstract class. */\r\nfunction LogicalType(schema, opts) {\r\n  this._logicalTypeName = schema.logicalType;\r\n  Type.call(this);\r\n  LOGICAL_TYPE = this;\r\n  try {\r\n    this._underlyingType = Type.forSchema(schema, opts);\r\n  } finally {\r\n    LOGICAL_TYPE = null;\r\n    // Remove the underlying type now that we're done instantiating. Note that\r\n    // in some (rare) cases, it might not have been inserted; for example, if\r\n    // this constructor was manually called with an already instantiated type.\r\n    var l = UNDERLYING_TYPES.length;\r\n    if (l && UNDERLYING_TYPES[l - 1][0] === this) {\r\n      UNDERLYING_TYPES.pop();\r\n    }\r\n  }\r\n  // We create a separate branch constructor for logical types to keep them\r\n  // monomorphic.\r\n  if (Type.isType(this.underlyingType, 'union')) {\r\n    this._branchConstructor = this.underlyingType._branchConstructor;\r\n  } else {\r\n    this._branchConstructor = this.underlyingType._createBranchConstructor();\r\n  }\r\n  // We don't freeze derived types to allow arbitrary properties. Implementors\r\n  // can still do so in the subclass' constructor at their convenience.\r\n}\r\nutil.inherits(LogicalType, Type);\r\n\r\nObject.defineProperty(LogicalType.prototype, 'typeName', {\r\n  enumerable: true,\r\n  get: function () { return 'logical:' + this._logicalTypeName; }\r\n});\r\n\r\nObject.defineProperty(LogicalType.prototype, 'underlyingType', {\r\n  enumerable: true,\r\n  get: function () {\r\n    if (this._underlyingType) {\r\n      return this._underlyingType;\r\n    }\r\n    // If the field wasn't present, it means the logical type isn't complete\r\n    // yet: we're waiting on its underlying type to be fully instantiated. In\r\n    // this case, it will be present in the `UNDERLYING_TYPES` array.\r\n    var i, l, arr;\r\n    for (i = 0, l = UNDERLYING_TYPES.length; i < l; i++) {\r\n      arr = UNDERLYING_TYPES[i];\r\n      if (arr[0] === this) {\r\n        return arr[1];\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\nLogicalType.prototype.getUnderlyingType = function () {\r\n  return this.underlyingType;\r\n};\r\n\r\nLogicalType.prototype._read = function (tap) {\r\n  return this._fromValue(this.underlyingType._read(tap));\r\n};\r\n\r\nLogicalType.prototype._write = function (tap, any) {\r\n  this.underlyingType._write(tap, this._toValue(any));\r\n};\r\n\r\nLogicalType.prototype._check = function (any, flags, hook, path) {\r\n  try {\r\n    var val = this._toValue(any);\r\n  } catch (err) {\r\n    // Handled below.\r\n  }\r\n  if (val === undefined) {\r\n    if (hook) {\r\n      hook(any, this);\r\n    }\r\n    return false;\r\n  }\r\n  return this.underlyingType._check(val, flags, hook, path);\r\n};\r\n\r\nLogicalType.prototype._copy = function (any, opts) {\r\n  var type = this.underlyingType;\r\n  switch (opts && opts.coerce) {\r\n    case 3: // To string.\r\n      return type._copy(this._toValue(any), opts);\r\n    case 2: // From string.\r\n      return this._fromValue(type._copy(any, opts));\r\n    default: // Normal copy.\r\n      return this._fromValue(type._copy(this._toValue(any), opts));\r\n  }\r\n};\r\n\r\nLogicalType.prototype._update = function (resolver, type, opts) {\r\n  var _fromValue = this._resolve(type, opts);\r\n  if (_fromValue) {\r\n    resolver._read = function (tap) { return _fromValue(type._read(tap)); };\r\n  }\r\n};\r\n\r\nLogicalType.prototype.compare = function (obj1, obj2) {\r\n  var val1 = this._toValue(obj1);\r\n  var val2 = this._toValue(obj2);\r\n  return this.underlyingType.compare(val1, val2);\r\n};\r\n\r\nLogicalType.prototype.random = function () {\r\n  return this._fromValue(this.underlyingType.random());\r\n};\r\n\r\nLogicalType.prototype._deref = function (schema, opts) {\r\n  var type = this.underlyingType;\r\n  var isVisited = type.name !== undefined && opts.derefed[type.name];\r\n  schema = type._attrs(opts);\r\n  if (!isVisited && opts.exportAttrs) {\r\n    if (typeof schema == 'string') {\r\n      schema = {type: schema};\r\n    }\r\n    schema.logicalType = this._logicalTypeName;\r\n    this._export(schema);\r\n  }\r\n  return schema;\r\n};\r\n\r\nLogicalType.prototype._skip = function (tap) {\r\n  this.underlyingType._skip(tap);\r\n};\r\n\r\n// Unlike the other methods below, `_export` has a reasonable default which we\r\n// can provide (not exporting anything).\r\nLogicalType.prototype._export = function (/* schema */) {};\r\n\r\n// Methods to be implemented.\r\nLogicalType.prototype._fromValue = utils.abstractFunction;\r\nLogicalType.prototype._toValue = utils.abstractFunction;\r\nLogicalType.prototype._resolve = utils.abstractFunction;\r\n\r\n\r\n// General helpers.\r\n\r\n/**\r\n * Customizable long.\r\n *\r\n * This allows support of arbitrarily large long (e.g. larger than\r\n * `Number.MAX_SAFE_INTEGER`). See `LongType.__with` method above. Note that we\r\n * can't use a logical type because we need a \"lower-level\" hook here: passing\r\n * through through the standard long would cause a loss of precision.\r\n */\r\nfunction AbstractLongType(noUnpack) {\r\n  this._concreteTypeName = 'long';\r\n  PrimitiveType.call(this, true);\r\n  // Note that this type \"inherits\" `LongType` (i.e. gain its prototype\r\n  // methods) but only \"subclasses\" `PrimitiveType` to avoid being prematurely\r\n  // frozen.\r\n  this._noUnpack = !!noUnpack;\r\n}\r\nutil.inherits(AbstractLongType, LongType);\r\n\r\nAbstractLongType.prototype.typeName = 'abstract:long';\r\n\r\nAbstractLongType.prototype._check = function (val, flags, hook) {\r\n  var b = this._isValid(val);\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nAbstractLongType.prototype._read = function (tap) {\r\n  var buf, pos;\r\n  if (this._noUnpack) {\r\n    pos = tap.pos;\r\n    tap.skipLong();\r\n    buf = tap.buf.slice(pos, tap.pos);\r\n  } else {\r\n    buf = tap.unpackLongBytes(tap);\r\n  }\r\n  if (tap.isValid()) {\r\n    return this._fromBuffer(buf);\r\n  }\r\n};\r\n\r\nAbstractLongType.prototype._write = function (tap, val) {\r\n  if (!this._isValid(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  var buf = this._toBuffer(val);\r\n  if (this._noUnpack) {\r\n    tap.writeFixed(buf);\r\n  } else {\r\n    tap.packLongBytes(buf);\r\n  }\r\n};\r\n\r\nAbstractLongType.prototype._copy = function (val, opts) {\r\n  switch (opts && opts.coerce) {\r\n    case 3: // To string.\r\n      return this._toJSON(val);\r\n    case 2: // From string.\r\n      return this._fromJSON(val);\r\n    default: // Normal copy.\r\n      // Slow but guarantees most consistent results. Faster alternatives would\r\n      // require assumptions on the long class used (e.g. immutability).\r\n      return this._fromJSON(this._toJSON(val));\r\n  }\r\n};\r\n\r\nAbstractLongType.prototype._deref = function () { return 'long'; };\r\n\r\nAbstractLongType.prototype._update = function (resolver, type) {\r\n  var self = this;\r\n  switch (type.typeName) {\r\n    case 'int':\r\n      resolver._read = function (tap) {\r\n        return self._fromJSON(type._read(tap));\r\n      };\r\n      break;\r\n    case 'abstract:long':\r\n    case 'long':\r\n      resolver._read = function (tap) { return self._read(tap); };\r\n  }\r\n};\r\n\r\nAbstractLongType.prototype.random = function () {\r\n  return this._fromJSON(LongType.prototype.random());\r\n};\r\n\r\n// Methods to be implemented by the user.\r\nAbstractLongType.prototype._fromBuffer = utils.abstractFunction;\r\nAbstractLongType.prototype._toBuffer = utils.abstractFunction;\r\nAbstractLongType.prototype._fromJSON = utils.abstractFunction;\r\nAbstractLongType.prototype._toJSON = utils.abstractFunction;\r\nAbstractLongType.prototype._isValid = utils.abstractFunction;\r\nAbstractLongType.prototype.compare = utils.abstractFunction;\r\n\r\n/** A record field. */\r\nfunction Field(schema, opts) {\r\n  var name = schema.name;\r\n  if (typeof name != 'string' || !utils.isValidName(name)) {\r\n    throw new Error(f('invalid field name: %s', name));\r\n  }\r\n\r\n  this.name = name;\r\n  this.type = Type.forSchema(schema.type, opts);\r\n  this.aliases = schema.aliases || [];\r\n  this.doc = schema.doc !== undefined ? '' + schema.doc : undefined;\r\n\r\n  this._order = (function (order) {\r\n    switch (order) {\r\n      case 'ascending':\r\n        return 1;\r\n      case 'descending':\r\n        return -1;\r\n      case 'ignore':\r\n        return 0;\r\n      default:\r\n        throw new Error(f('invalid order: %j', order));\r\n    }\r\n  })(schema.order === undefined ? 'ascending' : schema.order);\r\n\r\n  var value = schema['default'];\r\n  if (value !== undefined) {\r\n    // We need to convert defaults back to a valid format (unions are\r\n    // disallowed in default definitions, only the first type of each union is\r\n    // allowed instead).\r\n    // http://apache-avro.679487.n3.nabble.com/field-union-default-in-Java-td1175327.html\r\n    var type = this.type;\r\n    var val = type._copy(value, {coerce: 2, wrap: 2});\r\n    // The clone call above will throw an error if the default is invalid.\r\n    if (isPrimitive(type.typeName) && type.typeName !== 'bytes') {\r\n      // These are immutable.\r\n      this.defaultValue = function () { return val; };\r\n    } else {\r\n      this.defaultValue = function () { return type._copy(val); };\r\n    }\r\n  }\r\n\r\n  Object.freeze(this);\r\n}\r\n\r\nField.prototype.defaultValue = function () {}; // Undefined default.\r\n\r\nObject.defineProperty(Field.prototype, 'order', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return ['descending', 'ignore', 'ascending'][this._order + 1];\r\n  }\r\n});\r\n\r\nField.prototype.getAliases = function () { return this.aliases; };\r\n\r\nField.prototype.getDefault = Field.prototype.defaultValue;\r\n\r\nField.prototype.getName = function () { return this.name; };\r\n\r\nField.prototype.getOrder = function () { return this.order; };\r\n\r\nField.prototype.getType = function () { return this.type; };\r\n\r\n/**\r\n * Resolver to read a writer's schema as a new schema.\r\n *\r\n * @param readerType {Type} The type to convert to.\r\n */\r\nfunction Resolver(readerType) {\r\n  // Add all fields here so that all resolvers share the same hidden class.\r\n  this._readerType = readerType;\r\n  this._read = null;\r\n  this.itemsType = null;\r\n  this.size = 0;\r\n  this.symbols = null;\r\n  this.valuesType = null;\r\n}\r\n\r\nResolver.prototype._peek = Type.prototype._peek;\r\n\r\nResolver.prototype.inspect = function () { return '<Resolver>'; };\r\n\r\n/** Mutable hash container. */\r\nfunction Hash() {\r\n  this.str = undefined;\r\n}\r\n\r\n/**\r\n * Read a value from a tap.\r\n *\r\n * @param type {Type} The type to decode.\r\n * @param tap {Tap} The tap to read from. No checks are performed here.\r\n * @param resolver {Resolver} Optional resolver. It must match the input type.\r\n * @param lazy {Boolean} Skip trailing fields when using a resolver.\r\n */\r\nfunction readValue(type, tap, resolver, lazy) {\r\n  if (resolver) {\r\n    if (resolver._readerType !== type) {\r\n      throw new Error('invalid resolver');\r\n    }\r\n    return resolver._read(tap, lazy);\r\n  } else {\r\n    return type._read(tap);\r\n  }\r\n}\r\n\r\n/**\r\n * Get all aliases for a type (including its name).\r\n *\r\n * @param obj {Type|Object} Typically a type or a field. Its aliases property\r\n * must exist and be an array.\r\n */\r\nfunction getAliases(obj) {\r\n  var names = {};\r\n  if (obj.name) {\r\n    names[obj.name] = true;\r\n  }\r\n  var aliases = obj.aliases;\r\n  var i, l;\r\n  for (i = 0, l = aliases.length; i < l; i++) {\r\n    names[aliases[i]] = true;\r\n  }\r\n  return Object.keys(names);\r\n}\r\n\r\n/** Checks if a type can be read as another based on name resolution rules. */\r\nfunction hasCompatibleName(reader, writer, strict) {\r\n  if (!writer.name) {\r\n    return true;\r\n  }\r\n  var name = strict ? writer.name : utils.unqualify(writer.name);\r\n  var aliases = getAliases(reader);\r\n  var i, l, alias;\r\n  for (i = 0, l = aliases.length; i < l; i++) {\r\n    alias = aliases[i];\r\n    if (!strict) {\r\n      alias = utils.unqualify(alias);\r\n    }\r\n    if (alias === name) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Check whether a type's name is a primitive.\r\n *\r\n * @param name {String} Type name (e.g. `'string'`, `'array'`).\r\n */\r\nfunction isPrimitive(typeName) {\r\n  // Since we use this module's own `TYPES` object, we can use `instanceof`.\r\n  var type = TYPES[typeName];\r\n  return type && type.prototype instanceof PrimitiveType;\r\n}\r\n\r\n/**\r\n * Return a type's class name from its Avro type name.\r\n *\r\n * We can't simply use `constructor.name` since it isn't supported in all\r\n * browsers.\r\n *\r\n * @param typeName {String} Type name.\r\n */\r\nfunction getClassName(typeName) {\r\n  if (typeName === 'error') {\r\n    typeName = 'record';\r\n  } else {\r\n    var match = /^([^:]+):(.*)$/.exec(typeName);\r\n    if (match) {\r\n      if (match[1] === 'union') {\r\n        typeName = match[2] + 'Union';\r\n      } else {\r\n        // Logical type.\r\n        typeName = match[1];\r\n      }\r\n    }\r\n  }\r\n  return utils.capitalize(typeName) + 'Type';\r\n}\r\n\r\n/**\r\n * Get the number of elements in an array block.\r\n *\r\n * @param tap {Tap} A tap positioned at the beginning of an array block.\r\n */\r\nfunction readArraySize(tap) {\r\n  var n = tap.readLong();\r\n  if (n < 0) {\r\n    n = -n;\r\n    tap.skipLong(); // Skip size.\r\n  }\r\n  return n;\r\n}\r\n\r\n/**\r\n * Check whether a long can be represented without precision loss.\r\n *\r\n * @param n {Number} The number.\r\n *\r\n * Two things to note:\r\n *\r\n * + We are not using the `Number` constants for compatibility with older\r\n *   browsers.\r\n * + We must remove one from each bound because of rounding errors.\r\n */\r\nfunction isSafeLong(n) {\r\n  return n >= -9007199254740990 && n <= 9007199254740990;\r\n}\r\n\r\n/**\r\n * Check whether an object is the JSON representation of a buffer.\r\n */\r\nfunction isJsonBuffer(obj) {\r\n  return obj && obj.type === 'Buffer' && Array.isArray(obj.data);\r\n}\r\n\r\n/**\r\n * Throw a somewhat helpful error on invalid object.\r\n *\r\n * @param path {Array} Passed from hook, but unused (because empty where this\r\n * function is used, since we aren't keeping track of it for effiency).\r\n * @param val {...} The object to reject.\r\n * @param type {Type} The type to check against.\r\n *\r\n * This method is mostly used from `_write` to signal an invalid object for a\r\n * given type. Note that this provides less information than calling `isValid`\r\n * with a hook since the path is not propagated (for efficiency reasons).\r\n */\r\nfunction throwInvalidError(val, type) {\r\n  throw new Error(f('invalid %j: %j', type.schema(), val));\r\n}\r\n\r\nfunction maybeQualify(name, ns) {\r\n  var unqualified = utils.unqualify(name);\r\n  // Primitives are always in the global namespace.\r\n  return isPrimitive(unqualified) ? unqualified : utils.qualify(name, ns);\r\n}\r\n\r\n/**\r\n * Get a type's bucket when included inside an unwrapped union.\r\n *\r\n * @param type {Type} Any type.\r\n */\r\nfunction getTypeBucket(type) {\r\n  var typeName = type.typeName;\r\n  switch (typeName) {\r\n    case 'double':\r\n    case 'float':\r\n    case 'int':\r\n    case 'long':\r\n      return 'number';\r\n    case 'bytes':\r\n    case 'fixed':\r\n      return 'buffer';\r\n    case 'enum':\r\n      return 'string';\r\n    case 'map':\r\n    case 'error':\r\n    case 'record':\r\n      return 'object';\r\n    default:\r\n      return typeName;\r\n  }\r\n}\r\n\r\n/**\r\n * Infer a value's bucket (see unwrapped unions for more details).\r\n *\r\n * @param val {...} Any value.\r\n */\r\nfunction getValueBucket(val) {\r\n  if (val === null) {\r\n    return 'null';\r\n  }\r\n  var bucket = typeof val;\r\n  if (bucket === 'object') {\r\n    // Could be bytes, fixed, array, map, or record.\r\n    if (Array.isArray(val)) {\r\n      return 'array';\r\n    } else if (Buffer.isBuffer(val)) {\r\n      return 'buffer';\r\n    }\r\n  }\r\n  return bucket;\r\n}\r\n\r\n/**\r\n * Check whether a collection of types leads to an ambiguous union.\r\n *\r\n * @param types {Array} Array of types.\r\n */\r\nfunction isAmbiguous(types) {\r\n  var buckets = {};\r\n  var i, l, bucket, type;\r\n  for (i = 0, l = types.length; i < l; i++) {\r\n    type = types[i];\r\n    if (!Type.isType(type, 'logical')) {\r\n      bucket = getTypeBucket(type);\r\n      if (buckets[bucket]) {\r\n        return true;\r\n      }\r\n      buckets[bucket] = true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Combine number types.\r\n *\r\n * Note that never have to create a new type here, we are guaranteed to be able\r\n * to reuse one of the input types as super-type.\r\n */\r\nfunction combineNumbers(types) {\r\n  var typeNames = ['int', 'long', 'float', 'double'];\r\n  var superIndex = -1;\r\n  var superType = null;\r\n  var i, l, type, index;\r\n  for (i = 0, l = types.length; i < l; i++) {\r\n    type = types[i];\r\n    index = typeNames.indexOf(type.typeName);\r\n    if (index > superIndex) {\r\n      superIndex = index;\r\n      superType = type;\r\n    }\r\n  }\r\n  return superType;\r\n}\r\n\r\n/**\r\n * Combine enums and strings.\r\n *\r\n * The order of the returned symbols is undefined and the returned enum is\r\n *\r\n */\r\nfunction combineStrings(types, opts) {\r\n  var symbols = {};\r\n  var i, l, type, typeSymbols;\r\n  for (i = 0, l = types.length; i < l; i++) {\r\n    type = types[i];\r\n    if (type.typeName === 'string') {\r\n      // If at least one of the types is a string, it will be the supertype.\r\n      return type;\r\n    }\r\n    typeSymbols = type.symbols;\r\n    var j, m;\r\n    for (j = 0, m = typeSymbols.length; j < m; j++) {\r\n      symbols[typeSymbols[j]] = true;\r\n    }\r\n  }\r\n  return Type.forSchema({type: 'enum', symbols: Object.keys(symbols)}, opts);\r\n}\r\n\r\n/**\r\n * Combine bytes and fixed.\r\n *\r\n * This function is optimized to avoid creating new types when possible: in\r\n * case of a size mismatch between fixed types, it will continue looking\r\n * through the array to find an existing bytes type (rather than exit early by\r\n * creating one eagerly).\r\n */\r\nfunction combineBuffers(types, opts) {\r\n  var size = -1;\r\n  var i, l, type;\r\n  for (i = 0, l = types.length; i < l; i++) {\r\n    type = types[i];\r\n    if (type.typeName === 'bytes') {\r\n      return type;\r\n    }\r\n    if (size === -1) {\r\n      size = type.size;\r\n    } else if (type.size !== size) {\r\n      // Don't create a bytes type right away, we might be able to reuse one\r\n      // later on in the types array. Just mark this for now.\r\n      size = -2;\r\n    }\r\n  }\r\n  return size < 0 ? Type.forSchema('bytes', opts) : types[0];\r\n}\r\n\r\n/**\r\n * Combine maps and records.\r\n *\r\n * Field defaults are kept when possible (i.e. when no coercion to a map\r\n * happens), with later definitions overriding previous ones.\r\n */\r\nfunction combineObjects(types, opts) {\r\n  var allTypes = []; // Field and value types.\r\n  var fieldTypes = {}; // Record field types grouped by field name.\r\n  var fieldDefaults = {};\r\n  var isValidRecord = true;\r\n\r\n  // Check whether the final type will be a map or a record.\r\n  var i, l, type, fields;\r\n  for (i = 0, l = types.length; i < l; i++) {\r\n    type = types[i];\r\n    if (type.typeName === 'map') {\r\n      isValidRecord = false;\r\n      allTypes.push(type.valuesType);\r\n    } else {\r\n      fields = type.fields;\r\n      var j, m, field, fieldDefault, fieldName, fieldType;\r\n      for (j = 0, m = fields.length; j < m; j++) {\r\n        field = fields[j];\r\n        fieldName = field.name;\r\n        fieldType = field.type;\r\n        allTypes.push(fieldType);\r\n        if (isValidRecord) {\r\n          if (!fieldTypes[fieldName]) {\r\n            fieldTypes[fieldName] = [];\r\n          }\r\n          fieldTypes[fieldName].push(fieldType);\r\n          fieldDefault = field.defaultValue();\r\n          if (fieldDefault !== undefined) {\r\n            // Later defaults will override any previous ones.\r\n            fieldDefaults[fieldName] = fieldDefault;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (isValidRecord) {\r\n    // Check that no fields are missing and that we have the approriate\r\n    // defaults for those which are.\r\n    var fieldNames = Object.keys(fieldTypes);\r\n    for (i = 0, l = fieldNames.length; i < l; i++) {\r\n      fieldName = fieldNames[i];\r\n      if (\r\n        fieldTypes[fieldName].length < types.length &&\r\n        fieldDefaults[fieldName] === undefined\r\n      ) {\r\n        // At least one of the records is missing a field with no default.\r\n        if (opts && opts.strictDefaults) {\r\n          isValidRecord = false;\r\n        } else {\r\n          fieldTypes[fieldName].unshift(Type.forSchema('null', opts));\r\n          fieldDefaults[fieldName] = null;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  var schema;\r\n  if (isValidRecord) {\r\n    schema = {\r\n      type: 'record',\r\n      fields: fieldNames.map(function (s) {\r\n        var fieldType = Type.forTypes(fieldTypes[s], opts);\r\n        var fieldDefault = fieldDefaults[s];\r\n        if (\r\n          fieldDefault !== undefined &&\r\n          ~fieldType.typeName.indexOf('union')\r\n        ) {\r\n          // Ensure that the default's corresponding type is first.\r\n          var unionTypes = fieldType.types.slice();\r\n          var i, l;\r\n          for (i = 0, l = unionTypes.length; i < l; i++) {\r\n            if (unionTypes[i].isValid(fieldDefault)) {\r\n              break;\r\n            }\r\n          }\r\n          if (i > 0) {\r\n            var unionType = unionTypes[0];\r\n            unionTypes[0] = unionTypes[i];\r\n            unionTypes[i] = unionType;\r\n            fieldType = Type.forSchema(unionTypes, opts);\r\n          }\r\n        }\r\n        return {\r\n          name: s,\r\n          type: fieldType,\r\n          'default': fieldDefaults[s]\r\n        };\r\n      })\r\n    };\r\n  } else {\r\n    schema = {\r\n      type: 'map',\r\n      values: Type.forTypes(allTypes, opts)\r\n    };\r\n  }\r\n  return Type.forSchema(schema, opts);\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  Type: Type,\r\n  getTypeBucket: getTypeBucket,\r\n  getValueBucket: getValueBucket,\r\n  isPrimitive: isPrimitive,\r\n  builtins: (function () {\r\n    var types = {\r\n      LogicalType: LogicalType,\r\n      UnwrappedUnionType: UnwrappedUnionType,\r\n      WrappedUnionType: WrappedUnionType\r\n    };\r\n    var typeNames = Object.keys(TYPES);\r\n    var i, l, typeName;\r\n    for (i = 0, l = typeNames.length; i < l; i++) {\r\n      typeName = typeNames[i];\r\n      types[getClassName(typeName)] = TYPES[typeName];\r\n    }\r\n    return types;\r\n  })()\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/types.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/utils.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/utils.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\r\n\r\n// TODO: Make long comparison impervious to precision loss.\r\n// TODO: Optimize binary comparison methods.\r\n\r\n\r\n\r\n/** Various utilities used across this library. */\r\n\r\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\r\nvar util = __webpack_require__(/*! util */ \"util\");\r\n\r\n// Shared buffer pool for all taps.\r\nvar POOL = new BufferPool(4096);\r\n\r\n// Valid (field, type, and symbol) name regex.\r\nvar NAME_PATTERN = /^[A-Za-z_][A-Za-z0-9_]*$/;\r\n\r\n// Convenience imports.\r\nvar f = util.format;\r\n\r\n/**\r\n * Create a new empty buffer.\r\n *\r\n * @param size {Number} The buffer's size.\r\n */\r\nfunction newBuffer(size) {\r\n  if (typeof Buffer.alloc == 'function') {\r\n    return Buffer.alloc(size);\r\n  } else {\r\n    return new Buffer(size);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new buffer with the input contents.\r\n *\r\n * @param data {Array|String} The buffer's data.\r\n * @param enc {String} Encoding, used if data is a string.\r\n */\r\nfunction bufferFrom(data, enc) {\r\n  if (typeof Buffer.from == 'function') {\r\n    return Buffer.from(data, enc);\r\n  } else {\r\n    return new Buffer(data, enc);\r\n  }\r\n}\r\n\r\n/**\r\n * Uppercase the first letter of a string.\r\n *\r\n * @param s {String} The string.\r\n */\r\nfunction capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }\r\n\r\n/**\r\n * Compare two numbers.\r\n *\r\n * @param n1 {Number} The first one.\r\n * @param n2 {Number} The second one.\r\n */\r\nfunction compare(n1, n2) { return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1); }\r\n\r\n/**\r\n * Get option or default if undefined.\r\n *\r\n * @param opts {Object} Options.\r\n * @param key {String} Name of the option.\r\n * @param def {...} Default value.\r\n *\r\n * This is useful mostly for true-ish defaults and false-ish values (where the\r\n * usual `||` idiom breaks down).\r\n */\r\nfunction getOption(opts, key, def) {\r\n  var value = opts[key];\r\n  return value === undefined ? def : value;\r\n}\r\n\r\n/**\r\n * Compute a string's hash.\r\n *\r\n * @param str {String} The string to hash.\r\n * @param algorithm {String} The algorithm used. Defaults to MD5.\r\n */\r\nfunction getHash(str, algorithm) {\r\n  algorithm = algorithm || 'md5';\r\n  var hash = crypto.createHash(algorithm);\r\n  hash.end(str);\r\n  return hash.read();\r\n}\r\n\r\n/**\r\n * Find index of value in array.\r\n *\r\n * @param arr {Array} Can also be a false-ish value.\r\n * @param v {Object} Value to find.\r\n *\r\n * Returns -1 if not found, -2 if found multiple times.\r\n */\r\nfunction singleIndexOf(arr, v) {\r\n  var pos = -1;\r\n  var i, l;\r\n  if (!arr) {\r\n    return -1;\r\n  }\r\n  for (i = 0, l = arr.length; i < l; i++) {\r\n    if (arr[i] === v) {\r\n      if (pos >= 0) {\r\n        return -2;\r\n      }\r\n      pos = i;\r\n    }\r\n  }\r\n  return pos;\r\n}\r\n\r\n/**\r\n * Convert array to map.\r\n *\r\n * @param arr {Array} Elements.\r\n * @param fn {Function} Function returning an element's key.\r\n */\r\nfunction toMap(arr, fn) {\r\n  var obj = {};\r\n  var i, elem;\r\n  for (i = 0; i < arr.length; i++) {\r\n    elem = arr[i];\r\n    obj[fn(elem)] = elem;\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Convert map to array of values (polyfill for `Object.values`).\r\n *\r\n * @param obj {Object} Map.\r\n */\r\nfunction objectValues(obj) {\r\n  return Object.keys(obj).map(function (key) { return obj[key]; });\r\n}\r\n\r\n/**\r\n * Check whether an array has duplicates.\r\n *\r\n * @param arr {Array} The array.\r\n * @param fn {Function} Optional function to apply to each element.\r\n */\r\nfunction hasDuplicates(arr, fn) {\r\n  var obj = Object.create(null);\r\n  var i, l, elem;\r\n  for (i = 0, l = arr.length; i < l; i++) {\r\n    elem = arr[i];\r\n    if (fn) {\r\n      elem = fn(elem);\r\n    }\r\n    if (obj[elem]) {\r\n      return true;\r\n    }\r\n    obj[elem] = true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Copy properties from one object to another.\r\n *\r\n * @param src {Object} The source object.\r\n * @param dst {Object} The destination object.\r\n * @param overwrite {Boolean} Whether to overwrite existing destination\r\n * properties. Defaults to false.\r\n */\r\nfunction copyOwnProperties(src, dst, overwrite) {\r\n  var names = Object.getOwnPropertyNames(src);\r\n  var i, l, name;\r\n  for (i = 0, l = names.length; i < l; i++) {\r\n    name = names[i];\r\n    if (!dst.hasOwnProperty(name) || overwrite) {\r\n      var descriptor = Object.getOwnPropertyDescriptor(src, name);\r\n      Object.defineProperty(dst, name, descriptor);\r\n    }\r\n  }\r\n  return dst;\r\n}\r\n\r\n/**\r\n * Check whether a string is a valid Avro identifier.\r\n */\r\nfunction isValidName(str) { return NAME_PATTERN.test(str); }\r\n\r\n/**\r\n * Verify and return fully qualified name.\r\n *\r\n * @param name {String} Full or short name. It can be prefixed with a dot to\r\n * force global namespace.\r\n * @param namespace {String} Optional namespace.\r\n */\r\nfunction qualify(name, namespace) {\r\n  if (~name.indexOf('.')) {\r\n    name = name.replace(/^\\./, ''); // Allow absolute referencing.\r\n  } else if (namespace) {\r\n    name = namespace + '.' + name;\r\n  }\r\n  name.split('.').forEach(function (part) {\r\n    if (!isValidName(part)) {\r\n      throw new Error(f('invalid name: %j', name));\r\n    }\r\n  });\r\n  return name;\r\n}\r\n\r\n/**\r\n * Remove namespace from a name.\r\n *\r\n * @param name {String} Full or short name.\r\n */\r\nfunction unqualify(name) {\r\n  var parts = name.split('.');\r\n  return parts[parts.length - 1];\r\n}\r\n\r\n/**\r\n * Return the namespace implied by a name.\r\n *\r\n * @param name {String} Full or short name. If short, the returned namespace\r\n *  will be empty.\r\n */\r\nfunction impliedNamespace(name) {\r\n  var match = /^(.*)\\.[^.]+$/.exec(name);\r\n  return match ? match[1] : undefined;\r\n}\r\n\r\n/**\r\n * Returns offset in the string of the end of JSON object (-1 if past the end).\r\n *\r\n * To keep the implementation simple, this function isn't a JSON validator. It\r\n * will gladly return a result for invalid JSON (which is OK since that will be\r\n * promptly rejected by the JSON parser). What matters is that it is guaranteed\r\n * to return the correct end when presented with valid JSON.\r\n *\r\n * @param str {String} Input string containing serialized JSON..\r\n * @param pos {Number} Starting position.\r\n */\r\nfunction jsonEnd(str, pos) {\r\n  pos = pos | 0;\r\n\r\n  // Handle the case of a simple literal separately.\r\n  var c = str.charAt(pos++);\r\n  if (/[\\d-]/.test(c)) {\r\n    while (/[eE\\d.+-]/.test(str.charAt(pos))) {\r\n      pos++;\r\n    }\r\n    return pos;\r\n  } else if (/true|null/.test(str.slice(pos - 1, pos + 3))) {\r\n    return pos + 3;\r\n  } else if (/false/.test(str.slice(pos - 1, pos + 4))) {\r\n    return pos + 4;\r\n  }\r\n\r\n  // String, object, or array.\r\n  var depth = 0;\r\n  var literal = false;\r\n  do {\r\n    switch (c) {\r\n    case '{':\r\n    case '[':\r\n      if (!literal) { depth++; }\r\n      break;\r\n    case '}':\r\n    case ']':\r\n      if (!literal && !--depth) {\r\n        return pos;\r\n      }\r\n      break;\r\n    case '\"':\r\n      literal = !literal;\r\n      if (!depth && !literal) {\r\n        return pos;\r\n      }\r\n      break;\r\n    case '\\\\':\r\n      pos++; // Skip the next character.\r\n    }\r\n  } while ((c = str.charAt(pos++)));\r\n\r\n  return -1;\r\n}\r\n\r\n/** \"Abstract\" function to help with \"subclassing\". */\r\nfunction abstractFunction() { throw new Error('abstract'); }\r\n\r\n/** Batch-deprecate \"getters\" from an object's prototype. */\r\nfunction addDeprecatedGetters(obj, props) {\r\n  var proto = obj.prototype;\r\n  var i, l, prop, getter;\r\n  for (i = 0, l = props.length; i < l; i++) {\r\n    prop = props[i];\r\n    getter = 'get' + capitalize(prop);\r\n    proto[getter] = util.deprecate(\r\n      createGetter(prop),\r\n      'use `.' + prop + '` instead of `.' + getter + '()`'\r\n    );\r\n  }\r\n\r\n  function createGetter(prop) {\r\n    return function () {\r\n      var delegate = this[prop];\r\n      return typeof delegate == 'function' ?\r\n        delegate.apply(this, arguments) :\r\n        delegate;\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Simple buffer pool to avoid allocating many small buffers.\r\n *\r\n * This provides significant speedups in recent versions of node (6+).\r\n */\r\nfunction BufferPool(len) {\r\n  this._len = len | 0;\r\n  this._pos = 0;\r\n  this._slab = newBuffer(this._len);\r\n}\r\n\r\nBufferPool.prototype.alloc = function (len) {\r\n  if (len < 0) {\r\n    throw new Error('negative length');\r\n  }\r\n  var maxLen = this._len;\r\n  if (len > maxLen) {\r\n    return newBuffer(len);\r\n  }\r\n  if (this._pos + len > maxLen) {\r\n    this._slab = newBuffer(maxLen);\r\n    this._pos = 0;\r\n  }\r\n  return this._slab.slice(this._pos, this._pos += len);\r\n};\r\n\r\n/**\r\n * Generator of random things.\r\n *\r\n * Inspired by: http://stackoverflow.com/a/424445/1062617\r\n */\r\nfunction Lcg(seed) {\r\n  var a = 1103515245;\r\n  var c = 12345;\r\n  var m = Math.pow(2, 31);\r\n  var state = Math.floor(seed || Math.random() * (m - 1));\r\n\r\n  this._max = m;\r\n  this._nextInt = function () { return state = (a * state + c) % m; };\r\n}\r\n\r\nLcg.prototype.nextBoolean = function () {\r\n  // jshint -W018\r\n  return !!(this._nextInt() % 2);\r\n};\r\n\r\nLcg.prototype.nextInt = function (start, end) {\r\n  if (end === undefined) {\r\n    end = start;\r\n    start = 0;\r\n  }\r\n  end = end === undefined ? this._max : end;\r\n  return start + Math.floor(this.nextFloat() * (end - start));\r\n};\r\n\r\nLcg.prototype.nextFloat = function (start, end) {\r\n  if (end === undefined) {\r\n    end = start;\r\n    start = 0;\r\n  }\r\n  end = end === undefined ? 1 : end;\r\n  return start + (end - start) * this._nextInt() / this._max;\r\n};\r\n\r\nLcg.prototype.nextString = function(len, flags) {\r\n  len |= 0;\r\n  flags = flags || 'aA';\r\n  var mask = '';\r\n  if (flags.indexOf('a') > -1) {\r\n    mask += 'abcdefghijklmnopqrstuvwxyz';\r\n  }\r\n  if (flags.indexOf('A') > -1) {\r\n    mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n  }\r\n  if (flags.indexOf('#') > -1) {\r\n    mask += '0123456789';\r\n  }\r\n  if (flags.indexOf('!') > -1) {\r\n    mask += '~`!@#$%^&*()_+-={}[]:\";\\'<>?,./|\\\\';\r\n  }\r\n  var result = [];\r\n  for (var i = 0; i < len; i++) {\r\n    result.push(this.choice(mask));\r\n  }\r\n  return result.join('');\r\n};\r\n\r\nLcg.prototype.nextBuffer = function (len) {\r\n  var arr = [];\r\n  var i;\r\n  for (i = 0; i < len; i++) {\r\n    arr.push(this.nextInt(256));\r\n  }\r\n  return bufferFrom(arr);\r\n};\r\n\r\nLcg.prototype.choice = function (arr) {\r\n  var len = arr.length;\r\n  if (!len) {\r\n    throw new Error('choosing from empty array');\r\n  }\r\n  return arr[this.nextInt(len)];\r\n};\r\n\r\n/**\r\n * Ordered queue which returns items consecutively.\r\n *\r\n * This is actually a heap by index, with the added requirements that elements\r\n * can only be retrieved consecutively.\r\n */\r\nfunction OrderedQueue() {\r\n  this._index = 0;\r\n  this._items = [];\r\n}\r\n\r\nOrderedQueue.prototype.push = function (item) {\r\n  var items = this._items;\r\n  var i = items.length | 0;\r\n  var j;\r\n  items.push(item);\r\n  while (i > 0 && items[i].index < items[j = ((i - 1) >> 1)].index) {\r\n    item = items[i];\r\n    items[i] = items[j];\r\n    items[j] = item;\r\n    i = j;\r\n  }\r\n};\r\n\r\nOrderedQueue.prototype.pop = function () {\r\n  var items = this._items;\r\n  var len = (items.length - 1) | 0;\r\n  var first = items[0];\r\n  if (!first || first.index > this._index) {\r\n    return null;\r\n  }\r\n  this._index++;\r\n  if (!len) {\r\n    items.pop();\r\n    return first;\r\n  }\r\n  items[0] = items.pop();\r\n  var mid = len >> 1;\r\n  var i = 0;\r\n  var i1, i2, j, item, c, c1, c2;\r\n  while (i < mid) {\r\n    item = items[i];\r\n    i1 = (i << 1) + 1;\r\n    i2 = (i + 1) << 1;\r\n    c1 = items[i1];\r\n    c2 = items[i2];\r\n    if (!c2 || c1.index <= c2.index) {\r\n      c = c1;\r\n      j = i1;\r\n    } else {\r\n      c = c2;\r\n      j = i2;\r\n    }\r\n    if (c.index >= item.index) {\r\n      break;\r\n    }\r\n    items[j] = item;\r\n    items[i] = c;\r\n    i = j;\r\n  }\r\n  return first;\r\n};\r\n\r\n/**\r\n * A tap is a buffer which remembers what has been already read.\r\n *\r\n * It is optimized for performance, at the cost of failing silently when\r\n * overflowing the buffer. This is a purposeful trade-off given the expected\r\n * rarity of this case and the large performance hit necessary to enforce\r\n * validity. See `isValid` below for more information.\r\n */\r\nfunction Tap(buf, pos) {\r\n  this.buf = buf;\r\n  this.pos = pos | 0;\r\n  if (this.pos < 0) {\r\n    throw new Error('negative offset');\r\n  }\r\n}\r\n\r\n/**\r\n * Check that the tap is in a valid state.\r\n *\r\n * For efficiency reasons, none of the methods below will fail if an overflow\r\n * occurs (either read, skip, or write). For this reason, it is up to the\r\n * caller to always check that the read, skip, or write was valid by calling\r\n * this method.\r\n */\r\nTap.prototype.isValid = function () { return this.pos <= this.buf.length; };\r\n\r\nTap.prototype._invalidate = function () { this.pos = this.buf.length + 1; };\r\n\r\n// Read, skip, write methods.\r\n//\r\n// These should fail silently when the buffer overflows. Note this is only\r\n// required to be true when the functions are decoding valid objects. For\r\n// example errors will still be thrown if a bad count is read, leading to a\r\n// negative position offset (which will typically cause a failure in\r\n// `readFixed`).\r\n\r\nTap.prototype.readBoolean = function () { return !!this.buf[this.pos++]; };\r\n\r\nTap.prototype.skipBoolean = function () { this.pos++; };\r\n\r\nTap.prototype.writeBoolean = function (b) { this.buf[this.pos++] = !!b; };\r\n\r\nTap.prototype.readInt = Tap.prototype.readLong = function () {\r\n  var n = 0;\r\n  var k = 0;\r\n  var buf = this.buf;\r\n  var b, h, f, fk;\r\n\r\n  do {\r\n    b = buf[this.pos++];\r\n    h = b & 0x80;\r\n    n |= (b & 0x7f) << k;\r\n    k += 7;\r\n  } while (h && k < 28);\r\n\r\n  if (h) {\r\n    // Switch to float arithmetic, otherwise we might overflow.\r\n    f = n;\r\n    fk = 268435456; // 2 ** 28.\r\n    do {\r\n      b = buf[this.pos++];\r\n      f += (b & 0x7f) * fk;\r\n      fk *= 128;\r\n    } while (b & 0x80);\r\n    return (f % 2 ? -(f + 1) : f) / 2;\r\n  }\r\n\r\n  return (n >> 1) ^ -(n & 1);\r\n};\r\n\r\nTap.prototype.skipInt = Tap.prototype.skipLong = function () {\r\n  var buf = this.buf;\r\n  while (buf[this.pos++] & 0x80) {}\r\n};\r\n\r\nTap.prototype.writeInt = Tap.prototype.writeLong = function (n) {\r\n  var buf = this.buf;\r\n  var f, m;\r\n\r\n  if (n >= -1073741824 && n < 1073741824) {\r\n    // Won't overflow, we can use integer arithmetic.\r\n    m = n >= 0 ? n << 1 : (~n << 1) | 1;\r\n    do {\r\n      buf[this.pos] = m & 0x7f;\r\n      m >>= 7;\r\n    } while (m && (buf[this.pos++] |= 0x80));\r\n  } else {\r\n    // We have to use slower floating arithmetic.\r\n    f = n >= 0 ? n * 2 : (-n * 2) - 1;\r\n    do {\r\n      buf[this.pos] = f & 0x7f;\r\n      f /= 128;\r\n    } while (f >= 1 && (buf[this.pos++] |= 0x80));\r\n  }\r\n  this.pos++;\r\n};\r\n\r\nTap.prototype.readFloat = function () {\r\n  var buf = this.buf;\r\n  var pos = this.pos;\r\n  this.pos += 4;\r\n  if (this.pos > buf.length) {\r\n    return 0;\r\n  }\r\n  return this.buf.readFloatLE(pos);\r\n};\r\n\r\nTap.prototype.skipFloat = function () { this.pos += 4; };\r\n\r\nTap.prototype.writeFloat = function (f) {\r\n  var buf = this.buf;\r\n  var pos = this.pos;\r\n  this.pos += 4;\r\n  if (this.pos > buf.length) {\r\n    return;\r\n  }\r\n  return this.buf.writeFloatLE(f, pos);\r\n};\r\n\r\nTap.prototype.readDouble = function () {\r\n  var buf = this.buf;\r\n  var pos = this.pos;\r\n  this.pos += 8;\r\n  if (this.pos > buf.length) {\r\n    return 0;\r\n  }\r\n  return this.buf.readDoubleLE(pos);\r\n};\r\n\r\nTap.prototype.skipDouble = function () { this.pos += 8; };\r\n\r\nTap.prototype.writeDouble = function (d) {\r\n  var buf = this.buf;\r\n  var pos = this.pos;\r\n  this.pos += 8;\r\n  if (this.pos > buf.length) {\r\n    return;\r\n  }\r\n  return this.buf.writeDoubleLE(d, pos);\r\n};\r\n\r\nTap.prototype.readFixed = function (len) {\r\n  var pos = this.pos;\r\n  this.pos += len;\r\n  if (this.pos > this.buf.length) {\r\n    return;\r\n  }\r\n  var fixed = POOL.alloc(len);\r\n  this.buf.copy(fixed, 0, pos, pos + len);\r\n  return fixed;\r\n};\r\n\r\nTap.prototype.skipFixed = function (len) { this.pos += len; };\r\n\r\nTap.prototype.writeFixed = function (buf, len) {\r\n  len = len || buf.length;\r\n  var pos = this.pos;\r\n  this.pos += len;\r\n  if (this.pos > this.buf.length) {\r\n    return;\r\n  }\r\n  buf.copy(this.buf, pos, 0, len);\r\n};\r\n\r\nTap.prototype.readBytes = function () {\r\n  var len = this.readLong();\r\n  if (len < 0) {\r\n    this._invalidate();\r\n    return;\r\n  }\r\n  return this.readFixed(len);\r\n};\r\n\r\nTap.prototype.skipBytes = function () {\r\n  var len = this.readLong();\r\n  if (len < 0) {\r\n    this._invalidate();\r\n    return;\r\n  }\r\n  this.pos += len;\r\n};\r\n\r\nTap.prototype.writeBytes = function (buf) {\r\n  var len = buf.length;\r\n  this.writeLong(len);\r\n  this.writeFixed(buf, len);\r\n};\r\n\r\n/* istanbul ignore else */\r\nif (typeof Buffer.prototype.utf8Slice == 'function') {\r\n  // Use this optimized function when available.\r\n  Tap.prototype.readString = function () {\r\n    var len = this.readLong();\r\n    if (len < 0) {\r\n      this._invalidate();\r\n      return '';\r\n    }\r\n    var pos = this.pos;\r\n    var buf = this.buf;\r\n    this.pos += len;\r\n    if (this.pos > buf.length) {\r\n      return;\r\n    }\r\n    return this.buf.utf8Slice(pos, pos + len);\r\n  };\r\n} else {\r\n  Tap.prototype.readString = function () {\r\n    var len = this.readLong();\r\n    if (len < 0) {\r\n      this._invalidate();\r\n      return '';\r\n    }\r\n    var pos = this.pos;\r\n    var buf = this.buf;\r\n    this.pos += len;\r\n    if (this.pos > buf.length) {\r\n      return;\r\n    }\r\n    return this.buf.slice(pos, pos + len).toString();\r\n  };\r\n}\r\n\r\nTap.prototype.skipString = function () {\r\n  var len = this.readLong();\r\n  if (len < 0) {\r\n    this._invalidate();\r\n    return;\r\n  }\r\n  this.pos += len;\r\n};\r\n\r\nTap.prototype.writeString = function (s) {\r\n  var len = Buffer.byteLength(s);\r\n  var buf = this.buf;\r\n  this.writeLong(len);\r\n  var pos = this.pos;\r\n  this.pos += len;\r\n  if (this.pos > buf.length) {\r\n    return;\r\n  }\r\n  if (len > 64 && typeof Buffer.prototype.utf8Write == 'function') {\r\n    // This method is roughly 50% faster than the manual implementation below\r\n    // for long strings (which is itself faster than the generic `Buffer#write`\r\n    // at least in most browsers, where `utf8Write` is not available).\r\n    buf.utf8Write(s, pos, len);\r\n  } else {\r\n    var i, l, c1, c2;\r\n    for (i = 0, l = len; i < l; i++) {\r\n      c1 = s.charCodeAt(i);\r\n      if (c1 < 0x80) {\r\n        buf[pos++] = c1;\r\n      } else if (c1 < 0x800) {\r\n        buf[pos++] = c1 >> 6 | 0xc0;\r\n        buf[pos++] = c1 & 0x3f | 0x80;\r\n      } else if (\r\n        (c1 & 0xfc00) === 0xd800 &&\r\n        ((c2 = s.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\r\n      ) {\r\n        c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\r\n        i++;\r\n        buf[pos++] = c1 >> 18 | 0xf0;\r\n        buf[pos++] = c1 >> 12 & 0x3f | 0x80;\r\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\r\n        buf[pos++] = c1 & 0x3f | 0x80;\r\n      } else {\r\n        buf[pos++] = c1 >> 12 | 0xe0;\r\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\r\n        buf[pos++] = c1 & 0x3f | 0x80;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/* istanbul ignore else */\r\nif (typeof Buffer.prototype.latin1Write == 'function') {\r\n  // `binaryWrite` has been renamed to `latin1Write` in Node v6.4.0, see\r\n  // https://github.com/nodejs/node/pull/7111. Note that the `'binary'`\r\n  // encoding argument still works however.\r\n  Tap.prototype.writeBinary = function (str, len) {\r\n    var pos = this.pos;\r\n    this.pos += len;\r\n    if (this.pos > this.buf.length) {\r\n      return;\r\n    }\r\n    this.buf.latin1Write(str, pos, len);\r\n  };\r\n} else if (typeof Buffer.prototype.binaryWrite == 'function') {\r\n  Tap.prototype.writeBinary = function (str, len) {\r\n    var pos = this.pos;\r\n    this.pos += len;\r\n    if (this.pos > this.buf.length) {\r\n      return;\r\n    }\r\n    this.buf.binaryWrite(str, pos, len);\r\n  };\r\n} else {\r\n  // Slowest implementation.\r\n  Tap.prototype.writeBinary = function (s, len) {\r\n    var pos = this.pos;\r\n    this.pos += len;\r\n    if (this.pos > this.buf.length) {\r\n      return;\r\n    }\r\n    this.buf.write(s, pos, len, 'binary');\r\n  };\r\n}\r\n\r\n// Binary comparison methods.\r\n//\r\n// These are not guaranteed to consume the objects they are comparing when\r\n// returning a non-zero result (allowing for performance benefits), so no other\r\n// operations should be done on either tap after a compare returns a non-zero\r\n// value. Also, these methods do not have the same silent failure requirement\r\n// as read, skip, and write since they are assumed to be called on valid\r\n// buffers.\r\n\r\nTap.prototype.matchBoolean = function (tap) {\r\n  return this.buf[this.pos++] - tap.buf[tap.pos++];\r\n};\r\n\r\nTap.prototype.matchInt = Tap.prototype.matchLong = function (tap) {\r\n  var n1 = this.readLong();\r\n  var n2 = tap.readLong();\r\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\r\n};\r\n\r\nTap.prototype.matchFloat = function (tap) {\r\n  var n1 = this.readFloat();\r\n  var n2 = tap.readFloat();\r\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\r\n};\r\n\r\nTap.prototype.matchDouble = function (tap) {\r\n  var n1 = this.readDouble();\r\n  var n2 = tap.readDouble();\r\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\r\n};\r\n\r\nTap.prototype.matchFixed = function (tap, len) {\r\n  return this.readFixed(len).compare(tap.readFixed(len));\r\n};\r\n\r\nTap.prototype.matchBytes = Tap.prototype.matchString = function (tap) {\r\n  var l1 = this.readLong();\r\n  var p1 = this.pos;\r\n  this.pos += l1;\r\n  var l2 = tap.readLong();\r\n  var p2 = tap.pos;\r\n  tap.pos += l2;\r\n  var b1 = this.buf.slice(p1, this.pos);\r\n  var b2 = tap.buf.slice(p2, tap.pos);\r\n  return b1.compare(b2);\r\n};\r\n\r\n// Functions for supporting custom long classes.\r\n//\r\n// The two following methods allow the long implementations to not have to\r\n// worry about Avro's zigzag encoding, we directly expose longs as unpacked.\r\n\r\nTap.prototype.unpackLongBytes = function () {\r\n  var res = newBuffer(8);\r\n  var n = 0;\r\n  var i = 0; // Byte index in target buffer.\r\n  var j = 6; // Bit offset in current target buffer byte.\r\n  var buf = this.buf;\r\n  var b, neg;\r\n\r\n  b = buf[this.pos++];\r\n  neg = b & 1;\r\n  res.fill(0);\r\n\r\n  n |= (b & 0x7f) >> 1;\r\n  while (b & 0x80) {\r\n    b = buf[this.pos++];\r\n    n |= (b & 0x7f) << j;\r\n    j += 7;\r\n    if (j >= 8) {\r\n      // Flush byte.\r\n      j -= 8;\r\n      res[i++] = n;\r\n      n >>= 8;\r\n    }\r\n  }\r\n  res[i] = n;\r\n\r\n  if (neg) {\r\n    invert(res, 8);\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\nTap.prototype.packLongBytes = function (buf) {\r\n  var neg = (buf[7] & 0x80) >> 7;\r\n  var res = this.buf;\r\n  var j = 1;\r\n  var k = 0;\r\n  var m = 3;\r\n  var n;\r\n\r\n  if (neg) {\r\n    invert(buf, 8);\r\n    n = 1;\r\n  } else {\r\n    n = 0;\r\n  }\r\n\r\n  var parts = [\r\n    buf.readUIntLE(0, 3),\r\n    buf.readUIntLE(3, 3),\r\n    buf.readUIntLE(6, 2)\r\n  ];\r\n  // Not reading more than 24 bits because we need to be able to combine the\r\n  // \"carry\" bits from the previous part and JavaScript only supports bitwise\r\n  // operations on 32 bit integers.\r\n  while (m && !parts[--m]) {} // Skip trailing 0s.\r\n\r\n  // Leading parts (if any), we never bail early here since we need the\r\n  // continuation bit to be set.\r\n  while (k < m) {\r\n    n |= parts[k++] << j;\r\n    j += 24;\r\n    while (j > 7) {\r\n      res[this.pos++] = (n & 0x7f) | 0x80;\r\n      n >>= 7;\r\n      j -= 7;\r\n    }\r\n  }\r\n\r\n  // Final part, similar to normal packing aside from the initial offset.\r\n  n |= parts[m] << j;\r\n  do {\r\n    res[this.pos] = n & 0x7f;\r\n    n >>= 7;\r\n  } while (n && (res[this.pos++] |= 0x80));\r\n  this.pos++;\r\n\r\n  // Restore original buffer (could make this optional?).\r\n  if (neg) {\r\n    invert(buf, 8);\r\n  }\r\n};\r\n\r\n// Helpers.\r\n\r\n/**\r\n * Invert all bits in a buffer.\r\n *\r\n * @param buf {Buffer} Non-empty buffer to invert.\r\n * @param len {Number} Buffer length (must be positive).\r\n */\r\nfunction invert(buf, len) {\r\n  while (len--) {\r\n    buf[len] = ~buf[len];\r\n  }\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  abstractFunction: abstractFunction,\r\n  addDeprecatedGetters: addDeprecatedGetters,\r\n  bufferFrom: bufferFrom,\r\n  capitalize: capitalize,\r\n  copyOwnProperties: copyOwnProperties,\r\n  getHash: getHash,\r\n  compare: compare,\r\n  getOption: getOption,\r\n  impliedNamespace: impliedNamespace,\r\n  isValidName: isValidName,\r\n  jsonEnd: jsonEnd,\r\n  newBuffer: newBuffer,\r\n  objectValues: objectValues,\r\n  qualify: qualify,\r\n  toMap: toMap,\r\n  singleIndexOf: singleIndexOf,\r\n  hasDuplicates: hasDuplicates,\r\n  unqualify: unqualify,\r\n  BufferPool: BufferPool,\r\n  Lcg: Lcg,\r\n  OrderedQueue: OrderedQueue,\r\n  Tap: Tap\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/utils.js?");

/***/ }),

/***/ "./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"./node_modules/ws/lib/websocket.js\");\n\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"./node_modules/ws/lib/stream.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"./node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"./node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"./node_modules/ws/lib/sender.js\");\n\nWebSocket.WebSocket = WebSocket;\nWebSocket.WebSocketServer = WebSocket.Server;\n\nmodule.exports = WebSocket;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/index.js?");

/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) return target.slice(0, offset);\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"?c908\");\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/buffer-util.js?");

/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/constants.js?");

/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener, options = {}) {\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = listener;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/event-target.js?");

/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/extension.js?");

/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/limiter.js?");

/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"./node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/permessage-deflate.js?");

/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(\n              RangeError,\n              'Max payload size exceeded',\n              false,\n              1009,\n              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n            )\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n        }\n\n        this.emit('message', buf, false);\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else if (data.length === 1) {\n        return error(\n          RangeError,\n          'invalid payload length 1',\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n        }\n\n        const buf = data.slice(2);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n        }\n\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @param {String} errorCode The exposed error code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode] = statusCode;\n  return err;\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/receiver.js?");

/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n\n\n\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        randomFillSync(mask, 0, 4);\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/sender.js?");

/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/stream.js?");

/***/ }),

/***/ "./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/subprotocol.js?");

/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = {\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?bb17\");\n\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/validation.js?");

/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst extension = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"./node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"./node_modules/ws/lib/websocket.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!key || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/websocket-server.js?");

/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"./node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"./node_modules/ws/lib/sender.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = __webpack_require__(/*! ./event-target */ \"./node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    this._sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n\n    websocket._url = address;\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n  let invalidURLMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {\n    invalidURLMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"';\n  } else if (isUnixSocket && !parsedUrl.pathname) {\n    invalidURLMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidURLMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidURLMessage) {\n    const err = new SyntaxError(invalidURLMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalUnixSocket = isUnixSocket;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isUnixSocket\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isUnixSocket\n        ? websocket._originalUnixSocket\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalUnixSocket\n        ? false\n        : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    if (res.headers.upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  req.end();\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ws/lib/websocket.js?");

/***/ }),

/***/ "./src/server/index.js":
/*!*****************************!*\
  !*** ./src/server/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const avsc = __webpack_require__(/*! ../shared_modules/serialize */ \"./src/shared_modules/serialize.js\")\r\nconst util = __webpack_require__(/*! ../shared_modules/util */ \"./src/shared_modules/util.js\");\r\nconst ServerHandler = __webpack_require__(/*! ./serverHandler */ \"./src/server/serverHandler.js\");\r\nconst WebSocket = __webpack_require__(/*! ws */ \"./node_modules/ws/index.js\");\r\n\r\nlet game = new ServerHandler();\r\n\r\nwss = new WebSocket.Server({ port: process.env.PORT || 8181 });\r\n\r\nwss.on(\"connection\", socket => {\r\n    processConnection(socket);\r\n\r\n    socket.on(\"message\", processMessage);\r\n    socket.on(\"close\", processClose);\r\n});\r\n\r\nfunction processConnection(socket) {\r\n    const num_spectators = wss.clients.size - game.numPlayers - 1;\r\n    const isSpectator = game.scene == \"race\" || num_spectators > 0;\r\n    let id;\r\n\r\n    if(isSpectator) {\r\n        id = util.min_missing_id(wss.clients, util.MAX_PLAYERS, game.numPlayers); \r\n    } else {\r\n        id = util.min_missing_id(wss.clients); \r\n    }\r\n\r\n    addPlayer(socket, id);\r\n\r\n    console.log(`New client connected: ID - ${id}`);\r\n}\r\n\r\nfunction updateLatency(socket, timestamp) {\r\n    const BUFFER_SIZE = 10;\r\n    let latency = (util.getTime() - timestamp) / 2;\r\n\r\n    socket.pingBuffer.push(latency);\r\n\r\n    if(socket.pingBuffer.length > BUFFER_SIZE)\r\n        socket.pingBuffer.splice(0, 1);\r\n\r\n    socket.latency = 0;\r\n    \r\n    socket.pingBuffer.forEach(val => socket.latency += val / socket.pingBuffer.length);\r\n}\r\n\r\nasync function processMessage(buffer) {\r\n    let message = await avsc.decode(buffer);\r\n    \r\n    if(message.packets.ping) {\r\n        updateLatency(this, message.packets.ping.timestamp);\r\n    } else if(message.packets.inputs) {\r\n        // console.log(game.tick - message.tick);\r\n        util.setBuffer(this.inputBuffer, message.tick, message);\r\n    }\r\n}\r\n\r\nfunction handleInputs(socket, inputs) {\r\n    if(socket.id < util.MAX_PLAYERS && !(game.scene == \"race\" && socket.car.ready)) {\r\n        socket.car.inputs = inputs;\r\n    }\r\n\r\n    if(game.scene == \"lobby\" && inputs.enter) {\r\n        if(socket.id < util.MAX_PLAYERS) {\r\n            socket.car.ready = !socket.car.ready;\r\n        } else {\r\n            const id = util.min_missing_id(wss.clients);\r\n            \r\n            if(id < util.MAX_PLAYERS) {\r\n                console.log(`Client ${socket.id} changed ID to ${id}`);\r\n                addPlayer(socket, id);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction processClose() {\r\n    console.log(`Client disconnected: ID - ${this.id}`);\r\n\r\n    if(this.id < util.MAX_PLAYERS) {\r\n        game.removeCar(this.id);\r\n    }\r\n}\r\n\r\nfunction broadcast(data, pingFlag) {\r\n    let buffer;\r\n\r\n    if(pingFlag) {\r\n        data.packets.ping = {\r\n            timestamp: util.getTime(),\r\n            latency: null,\r\n        };\r\n    } else {\r\n        buffer = avsc.encode(data);  \r\n    }\r\n\r\n    for(const client of wss.clients) {\r\n        if(pingFlag) {\r\n            data.packets.ping.latency = client.latency;\r\n            buffer = avsc.encode(data);\r\n        }\r\n\r\n        client.send(buffer);\r\n    }\r\n}\r\n\r\nfunction addPlayer(socket, id) {\r\n    socket.id = id;\r\n    socket.car = null;\r\n    socket.inputBuffer = [];\r\n\r\n    socket.latency = 100;\r\n    socket.pingBuffer = [100];\r\n\r\n    if(id < util.MAX_PLAYERS) {\r\n        socket.car = game.createCar(id);\r\n    }\r\n\r\n    let bundle = {\r\n        packets: {},\r\n        tick: game.tick,\r\n    };\r\n\r\n    game.addPacket(bundle.packets, 'id', id);\r\n    game.addPacket(bundle.packets, 'dynamic');\r\n    game.addPacket(bundle.packets, 'static');\r\n\r\n    socket.send(avsc.encode(bundle));\r\n}\r\n\r\nlet pingTimer = 0;\r\nvar timer = new util.interval(16, () => { \r\n    const curTick = Math.floor(util.getTime() / 16);\r\n    // const loopTime = util.getTime() - timer.baseline;\r\n    const dt = .016;\r\n\r\n    while(game.tick < curTick) {\r\n        for(const socket of wss.clients) {\r\n            let message = util.getBuffer(socket.inputBuffer, game.tick);\r\n\r\n            // console.log(\"inputs\", message);\r\n\r\n            if(message && message.tick == game.tick) {\r\n                handleInputs(socket, message.packets.inputs);\r\n            }\r\n        }\r\n\r\n        let bundle = game.update(dt);\r\n\r\n        pingTimer += dt;\r\n        const pingFlag = pingTimer > .1;\r\n\r\n        if(pingTimer > .1)\r\n            pingTimer = 0;\r\n\r\n        broadcast(bundle, pingFlag);\r\n        \r\n        game.simulate(dt);\r\n\r\n        game.tick++;\r\n    }\r\n});\r\n\r\ngame.tick = Math.floor(util.getTime() / 16);\r\ntimer.run();\n\n//# sourceURL=webpack://js-kart/./src/server/index.js?");

/***/ }),

/***/ "./src/server/serverHandler.js":
/*!*************************************!*\
  !*** ./src/server/serverHandler.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Track = __webpack_require__(/*! ../shared_modules/trackGenerator */ \"./src/shared_modules/trackGenerator.js\");\r\nconst Car = __webpack_require__(/*! ../shared_modules/car */ \"./src/shared_modules/car.js\");\r\nconst util = __webpack_require__(/*! ../shared_modules/util */ \"./src/shared_modules/util.js\");\r\nconst PhysX = __webpack_require__(/*! ../shared_modules/physx */ \"./src/shared_modules/physx.js\");\r\nconst Vec2D = PhysX.Vec2D;\r\nconst PhysObject = PhysX.PhysObject;\r\nconst PhysEnv = PhysX.PhysEnv;\r\n\r\nconst wall = {\r\n    density: Infinity,\r\n    restitution: .5,\r\n    sFriction: .24,\r\n    dFriction: .16,\r\n};\r\n\r\nconst cp_material = {\r\n    density: 0,\r\n    restitution: 0,\r\n    sFriction: 0,\r\n    dFriction: 0,\r\n};\r\n\r\nconst cw = util.CANVAS_WIDTH;\r\nconst ch = util.CANVAS_HEIGHT;\r\n\r\nconst lobby_walls = [\r\n    [new Vec2D(-cw / 2 + 5,  -ch / 2 + 5),\r\n     new Vec2D(-cw / 2 + 30, -ch / 2 + 30),\r\n     new Vec2D( cw / 2 - 30, -ch / 2 + 30),\r\n     new Vec2D( cw / 2 - 5,  -ch / 2 + 5),],\r\n\r\n    [new Vec2D(-cw / 2 + 5,   ch / 2 - 5),\r\n     new Vec2D(-cw / 2 + 30,  ch / 2 - 30),\r\n     new Vec2D(-cw / 2 + 30, -ch / 2 + 30),\r\n     new Vec2D(-cw / 2 + 5,  -ch / 2 + 5),],\r\n\r\n    [new Vec2D( cw / 2 - 5,  ch / 2 - 5),\r\n     new Vec2D( cw / 2 - 30, ch / 2 - 30),\r\n     new Vec2D(-cw / 2 + 30, ch / 2 - 30),\r\n     new Vec2D(-cw / 2 + 5,  ch / 2 - 5),],\r\n\r\n    [new Vec2D(cw / 2 - 5,  -ch / 2 + 5),\r\n     new Vec2D(cw / 2 - 30, -ch / 2 + 30),\r\n     new Vec2D(cw / 2 - 30,  ch / 2 - 30),\r\n     new Vec2D(cw / 2 - 5,   ch / 2 - 5),],\r\n]\r\n\r\nclass ServerHandler {\r\n    constructor() {\r\n        this.scene = \"lobby\";\r\n        this.tick = Math.floor(util.getTime() / 16);\r\n        this.numPlayers = 0;\r\n\r\n        this.env = new PhysEnv();\r\n\r\n        this.cars = {};\r\n        this.track = null;\r\n        this.walls = [];\r\n        this.place = 1;\r\n        this.freezeTime = 0;\r\n\r\n        this.initLobby();\r\n    }\r\n\r\n    reset() {\r\n        this.env.clearObjects();\r\n        this.track = null;\r\n        this.walls = [];\r\n    }\r\n\r\n    initLobby() {\r\n        this.scene = \"lobby\";\r\n\r\n        let carArr = Object.entries(this.cars);\r\n        carArr.sort((a, b) => { return b[1].lap - a[1].lap });\r\n\r\n        for(const [id, car] of carArr) {\r\n            const int_id = parseInt(id);\r\n\r\n            car.pos = new Vec2D(0, ch * .6 / (util.MAX_PLAYERS + 1) * (int_id + 1) - ch * .3);\r\n            car.vel.x = car.vel.y = car.rotVel = car.angle = 0;\r\n            car.ready = false;\r\n\r\n            this.env.addObject(car);\r\n        }\r\n\r\n        let wallPoints = lobby_walls;\r\n        this.walls = [[]];\r\n\r\n        for(const points of wallPoints) {\r\n            let pos = new Vec2D(0, 0);\r\n            let new_pts = [];\r\n\r\n            for(let point of points) {\r\n                pos.add(point);\r\n                new_pts.push(new Vec2D(point.x, point.y));\r\n            }\r\n    \r\n            pos = pos.div(points.length);\r\n    \r\n            let obj = new PhysObject(pos, new_pts, wall);\r\n            this.env.addObject(obj);\r\n\r\n            this.walls[0].push(obj);\r\n        }\r\n    }\r\n\r\n    initRace() {\r\n        this.scene = \"race\";\r\n        this.place = 1;\r\n        this.freezeTime = 5;\r\n\r\n        this.env.clearObjects();\r\n        this.track = new Track(new Vec2D(0, 0));\r\n        Track.genMesh(this.track);\r\n\r\n        const scale = 15;\r\n        this.walls = [[], []];\r\n        this.createWalls(scale);\r\n        this.createCheckpoints();\r\n\r\n        let id = 0;\r\n\r\n        for(const car of Object.values(this.cars)) {\r\n            car.ready = false;\r\n            car.lap = 0;\r\n            car.lastCheckpoint = 0;\r\n\r\n            let dx = ((this.numPlayers-1)/2 - id) * 50 * Math.sin(this.track.spawn.d);\r\n            let dy = ((this.numPlayers-1)/2 - id) * 50 * -Math.cos(this.track.spawn.d);\r\n\r\n            car.pos.x = this.track.spawn.x * scale + dx;\r\n            car.pos.y = this.track.spawn.y * scale + dy;\r\n            car.angle = this.track.spawn.d;\r\n\r\n            car.vel.x = car.vel.y = car.rotVel = 0;\r\n\r\n            this.env.addObject(car);\r\n\r\n            id++;\r\n        }\r\n\r\n    }\r\n\r\n    createCheckpoints() {\r\n        for(let curr = 0; curr < this.walls[0].length; curr++) {\r\n            const next = (curr + 1) % this.walls[0].length;\r\n            \r\n\r\n            let points = [this.walls[1][next].points[2].mult(1),\r\n                          this.walls[1][curr].points[2].mult(1),\r\n                          this.walls[0][curr].points[3].mult(1),\r\n                          this.walls[0][next].points[3].mult(1)]; \r\n\r\n            let pos = new Vec2D(0, 0);\r\n\r\n            for(let point of points) {\r\n                pos.add(point);\r\n            }\r\n    \r\n            pos = pos.div(points.length);\r\n    \r\n            let cp = new PhysObject(pos, points, cp_material);\r\n\r\n            cp.id = (curr + 2 + this.walls[0].length) % this.walls[0].length;\r\n            cp.func = (A, B) => {\r\n                if(B instanceof Car) {\r\n                    if(Math.abs(A.id - B.lastCheckpoint) == 1)\r\n                        B.lastCheckpoint = A.id;\r\n\r\n                    if(A.id == 0 && B.lastCheckpoint > 5) {\r\n                        B.lastCheckpoint = 0;\r\n                        B.lap++;\r\n\r\n                        if(B.lap >= 3) {\r\n                            B.lap = -1;\r\n                            B.ready = true;\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n    \r\n            this.env.addObject(cp);\r\n        }\r\n    }\r\n\r\n    createWalls(scale) {\r\n        let wallArr = [...this.track.innerWall, ...this.track.outerWall];\r\n\r\n        for(const [idx, pts] of wallArr.entries()) {\r\n\r\n            let pos = new Vec2D(0, 0);\r\n            let objPts = [];\r\n                \r\n            for(let [i, point] of pts.entries()) {\r\n                objPts[i] = point.mult(scale);\r\n                pos.add(objPts[i]);\r\n            }\r\n\r\n            pos.x /= pts.length;\r\n            pos.y /= pts.length;\r\n            \r\n            let obj = new PhysObject(pos, objPts, wall);\r\n\r\n            const wall_idx = Math.floor(idx * 2 / wallArr.length);\r\n\r\n            this.env.addObject(obj);\r\n            this.walls[wall_idx].push(obj);\r\n        }\r\n    }\r\n\r\n    createCar(id) {\r\n        const pos = new Vec2D(0, ch * .6 / (util.MAX_PLAYERS + 1) * (id + 1) - ch * .3);\r\n        const hue = 360 / util.MAX_PLAYERS * id;\r\n        const car = new Car(pos, hue);\r\n\r\n        this.env.addObject(car);\r\n        this.cars[id] = car;\r\n        this.numPlayers++;\r\n\r\n        return car;\r\n    }\r\n\r\n    removeCar(id) {\r\n        this.env.removeObject(this.cars[id]);\r\n        \r\n        delete this.cars[id];\r\n        this.numPlayers--;\r\n    }\r\n\r\n    addPacket(packets, event, data = null) {\r\n        switch(event) {\r\n            case 'id':\r\n                packets.id = data;\r\n                break;\r\n            case 'dynamic':\r\n                packets.dynamic = {\r\n                    cars: this.cars,\r\n                };\r\n                break;\r\n            case 'static':\r\n                packets.static = {\r\n                    scene: this.scene,\r\n                    walls: this.walls,\r\n                };\r\n                break;\r\n            default:\r\n        }\r\n    }\r\n\r\n    lobbyUpdate(packets) {\r\n        let ready = true;\r\n    \r\n        for(const car of Object.values(this.cars)) {\r\n            if(!car.ready) {\r\n                ready = false;\r\n            }\r\n        }\r\n\r\n        this.addPacket(packets, 'dynamic');\r\n    \r\n        if(ready && this.numPlayers > 0) {\r\n            this.reset();\r\n            this.initRace();\r\n            packets[2] = this.addPacket(packets, 'static');\r\n        }\r\n\r\n        return packets;\r\n    }\r\n\r\n    raceUpdate(packets) {\r\n        let ready = true;\r\n        for(const car of Object.values(this.cars)) {\r\n            if(!car.ready) {\r\n                ready = false;\r\n            } else if(car.lap == -1) {\r\n                car.lap = this.place;\r\n                this.place++;\r\n                car.inputs.up = car.inputs.down = car.inputs.right = car.inputs.left = false;\r\n            }\r\n        }\r\n\r\n        this.addPacket(packets, 'dynamic');\r\n\r\n        if(this.numPlayers == 0 || ready) {\r\n            this.reset();\r\n            this.initLobby();\r\n            this.addPacket(packets, 'static');\r\n        }\r\n\r\n        return packets;\r\n    }\r\n\r\n    update(dt) {\r\n        let bundle = {\r\n            packets: {\r\n                id: null,\r\n                dynamic: null,\r\n                static: null,\r\n            },\r\n            tick: this.tick, \r\n        };\r\n\r\n        if(this.scene == \"lobby\") {\r\n            this.lobbyUpdate(bundle.packets);\r\n        } else {\r\n            this.raceUpdate(bundle.packets);\r\n        }\r\n\r\n        return bundle;\r\n    }\r\n\r\n    simulate(dt) {\r\n        if(this.freezeTime > 0) {\r\n            this.freezeTime -= dt;\r\n            return;\r\n        }\r\n\r\n        for(const car of Object.values(this.cars))\r\n            car.controlPlayer(dt);\r\n\r\n        this.env.update(dt);\r\n    }\r\n}\r\n\r\nmodule.exports = ServerHandler;\n\n//# sourceURL=webpack://js-kart/./src/server/serverHandler.js?");

/***/ }),

/***/ "./src/shared_modules/car.js":
/*!***********************************!*\
  !*** ./src/shared_modules/car.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const PhysX = __webpack_require__(/*! ./physx */ \"./src/shared_modules/physx.js\");\r\nconst Vec2D = PhysX.Vec2D;\r\nconst PhysObject = PhysX.PhysObject;\r\nconst PhysEnv = PhysX.PhysEnv;\r\n\r\nclass Car extends PhysObject {\r\n    constructor(pos, hue, material = null) {\r\n        const pts = [new Vec2D(0, 1),\r\n                     new Vec2D(0, 19),\r\n                     new Vec2D(12, 22),\r\n                     new Vec2D(40, 19),\r\n                     new Vec2D(40, 1),\r\n                     new Vec2D(12, -2),];\r\n\r\n        if(!material) {\r\n            material = {\r\n                density: 2.5,\r\n                restitution: .35,\r\n                sFriction: .06,\r\n                dFriction: .04,\r\n            };\r\n        }\r\n\r\n        super(pos, pts, material);\r\n        this.moi *= 10;\r\n        // this.masks = ['car-car'];\r\n\r\n        this.inputs = {\r\n            left: false,\r\n            right: false,\r\n            up: false,\r\n            down: false,\r\n            shift: false,\r\n            enter: false,\r\n        }\r\n\r\n        this.ready = false;\r\n        this.hue = hue;\r\n        this.lap = -1;\r\n        this.lastCheckpoint = 0;\r\n    }\r\n\r\n    controlPlayer(dt) {\r\n        const speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);\r\n        const maxSpeed = 1000;\r\n        const isDrifting = false;\r\n\r\n        const accFactor = 600 * dt;\r\n        const maxRotFactor = 2.5;\r\n        const maxRot = maxRotFactor * Math.min(speed / 100, 1)\r\n        const rotFactor = 14 * dt;\r\n        const driftFactor = isDrifting ? .96 : .8;\r\n        \r\n        const dx = Math.cos(this.angle);\r\n        const dy = Math.sin(this.angle);\r\n\r\n        const dir = new Vec2D(dx, dy);\r\n        const orth = new Vec2D(-dy, dx);\r\n\r\n        const fwdSpeed = dir.dot(this.vel);\r\n        const fwdVel = dir.mult(fwdSpeed);\r\n\r\n        const orthSpeed = orth.dot(this.vel);\r\n        const orthVel = orth.mult(orthSpeed * driftFactor);\r\n\r\n        this.vel = fwdVel.addRet(orthVel);\r\n\r\n        if(this.inputs.up && !this.inputs.down && fwdSpeed < maxSpeed) {\r\n            const dx = Math.cos(this.angle) * accFactor;\r\n            const dy = Math.sin(this.angle) * accFactor;\r\n    \r\n            this.vel.add(new Vec2D(dx, dy));\r\n        } else if(this.inputs.down && !this.inputs.up && fwdSpeed > -maxSpeed / 2) {\r\n            const dx = Math.cos(this.angle) * accFactor;\r\n            const dy = Math.sin(this.angle) * accFactor;\r\n    \r\n            this.vel.sub(new Vec2D(dx, dy));\r\n        } else {\r\n            this.vel.x *= isDrifting ? .999 : .99;\r\n            this.vel.y *= isDrifting ? .999 : .99;\r\n        }\r\n    \r\n        const turningLeft = this.inputs.left && !this.inputs.right; \r\n        const turningRight = !this.inputs.left && this.inputs.right;\r\n\r\n        if((turningLeft && fwdSpeed > 0) || (turningRight && fwdSpeed < 0)) {\r\n            if(this.rotVel > 0) this.rotVel = 0;\r\n            if(this.rotVel < -maxRot) this.rotVel = -maxRot;\r\n\r\n            this.rotVel -= rotFactor;\r\n        } else if((turningRight && fwdSpeed > 0) || (turningLeft && fwdSpeed < 0)) {\r\n            if(this.rotVel < 0) this.rotVel = 0;\r\n            if(this.rotVel > maxRot) this.rotVel = maxRot;\r\n\r\n            this.rotVel += rotFactor;\r\n        } else {\r\n            this.rotVel *= .92;\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = Car;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/car.js?");

/***/ }),

/***/ "./src/shared_modules/physx.js":
/*!*************************************!*\
  !*** ./src/shared_modules/physx.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("function clip(v1, v2, n, o) {\r\n    let points = [];\r\n    const d1 = n.dot(v1) - o;\r\n    const d2 = n.dot(v2) - o;\r\n\r\n    if(d1 >= 0) points.push(v1);\r\n\r\n    if(d2 >= 0) points.push(v2);\r\n\r\n    if(d1 * d2 < 0) {\r\n        let e = Vec2D.dif(v1, v2);\r\n        const u = d1 / (d1 - d2);\r\n        e = e.mult(u);\r\n        e.add(v1);\r\n\r\n        points.push(e);\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\nfunction debugLine(p1, p2, ctx, color = \"red\") {\r\n    ctx.strokeStyle = color;\r\n    ctx.beginPath()\r\n    ctx.moveTo(p1.x, p1.y);\r\n    ctx.lineTo(p2.x, p2.y);\r\n    ctx.stroke();\r\n}\r\n\r\nfunction insertionSort(arr, lambda = (x) => x) {\r\n    let val, j, i;\r\n    for(i = 1; i < arr.length; i++) {\r\n        val = arr[i];\r\n        j = i - 1;\r\n\r\n        while(j >= 0 && lambda(arr[j]) > lambda(val)) {\r\n            arr[j + 1] = arr[j];\r\n            j--;\r\n        }\r\n        arr[j + 1] = val;\r\n    }\r\n}\r\n\r\nfunction polygonSupport(points, d) {\r\n    let furthest = null;\r\n    let dot = -Infinity;\r\n\r\n    for(const point of points) {\r\n        const proj = point.dot(d);\r\n        if(proj > dot) {\r\n            furthest = point;\r\n            dot = proj;\r\n        }\r\n    }\r\n\r\n    return furthest;\r\n}\r\n\r\nfunction minkowskiDifSupport(s1, s2, d) {\r\n    return Vec2D.dif(polygonSupport(s2.points, d.mult(-1)), polygonSupport(s1.points, d));\r\n}\r\n\r\nfunction mean(arr) {\r\n    let sum = 0;\r\n    for(const el of arr) {\r\n        sum += el;\r\n    }\r\n    return sum / arr.length;\r\n}\r\n\r\nfunction variance(arr) {\r\n    let variance = 0;\r\n    const mean = mean(arr);\r\n    for(const el of arr) {\r\n        const dif = el - mean;\r\n        variance += dif * dif;\r\n    }\r\n    return variance / arr.length;\r\n}\r\n\r\nfunction calculateMassAndMoi(obj) {\r\n    if(obj.material.density == Infinity)\r\n        return [Infinity, Infinity];\r\n\r\n    let mass = 0;\r\n    // let center = new Vec2D(0, 0);\r\n    let moi = 0;\r\n\r\n    let prev = obj.shape.length - 1;\r\n    for(let cur = 0; cur < obj.shape.length; cur++) {\r\n        const a = obj.shape[prev];\r\n        const b = obj.shape[cur];\r\n\r\n        const areaStep = Math.abs(Vec2D.cross(a, b) / 2);\r\n        const massStep = areaStep * obj.material.density;\r\n        // const centerStep = a.addRet(b).div(3);\r\n        const moiStep = massStep / 6 * (a.dot(a) + b.dot(b) + a.dot(b));\r\n\r\n        mass += massStep\r\n        // center.add(centerStep);\r\n        moi += moiStep;\r\n    }\r\n\r\n    return [mass, moi];\r\n}\r\n\r\nconst wood = {\r\n    density: 1,\r\n    restitution: .45,\r\n    sFriction: .3,\r\n    dFriction: .2,\r\n};\r\n\r\nconst rubber = {\r\n    density: 2.5,\r\n    restitution: .95,\r\n    sFriction: .6,\r\n    dFriction: .4,\r\n};\r\n\r\nconst wall = {\r\n    density: Infinity,\r\n    restitution: .5,\r\n    sFriction: .24,\r\n    dFriction: .16,\r\n};\r\n\r\nclass Vec2D {\r\n    static rotate(pivot, point, rad) {\r\n        const dx = (point.x - pivot.x);\r\n        const dy = (point.y - pivot.y);\r\n\r\n        const sin = Math.sin(rad);\r\n        const cos = Math.cos(rad);\r\n\r\n        const nx = dx * cos - dy * sin; \r\n        const ny = dx * sin + dy * cos;\r\n\r\n        return new Vec2D(nx, ny);\r\n    }\r\n\r\n    static mag(vec) {\r\n        return Math.sqrt(vec.x * vec.x + vec.y * vec.y);\r\n    }\r\n    \r\n    static distance(v1, v2) {\r\n        return Vec2D.mag(Vec2D.dif(v1, v2));\r\n    }\r\n\r\n    static normalize(vec) {\r\n        if(vec.x == 0 && vec.y == 0) return new Vec2D(0, 0);\r\n        const mag = Vec2D.mag(vec);\r\n        return new Vec2D(vec.x / mag, vec.y / mag);\r\n    }\r\n\r\n    static dif(v1, v2) {\r\n        return new Vec2D(v2.x - v1.x, v2.y - v1.y);\r\n    }\r\n\r\n    static tripleProd(v1, v2, v3) {\r\n        const k = v1.x * v2.y - v1.y * v2.x;\r\n        const nx = -v3.y * k;\r\n        const ny = v3.x * k;\r\n        return new Vec2D(nx, ny, 0);\r\n    }\r\n\r\n    static cross(A, B) {\r\n        if(A.x == undefined) {\r\n            // scalar x vector\r\n            return new Vec2D(-A * B.y, A * B.x);\r\n        } else if(B.x == undefined) {\r\n            // vector x scalar\r\n            return new Vec2D(B * A.y, -B * A.x);\r\n        } else {\r\n            // vector x vector\r\n            return A.x * B.y - A.y * B.x;\r\n        }\r\n    }\r\n\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    add(other) {\r\n        this.x += other.x;\r\n        this.y += other.y;\r\n    }\r\n\r\n    sub(other) {\r\n        this.x -= other.x;\r\n        this.y -= other.y;\r\n    }\r\n\r\n    scale(num) {\r\n        this.x *= num;\r\n        this.y *= num;\r\n    }\r\n    \r\n    addRet(other) {\r\n        return new Vec2D(this.x + other.x, this.y + other.y);\r\n    }\r\n\r\n    subRet(other) {\r\n        return new Vec2D(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    mult(num) {\r\n        return new Vec2D(this.x * num, this.y * num);\r\n    }\r\n\r\n    div(num) {\r\n        return new Vec2D(this.x / num, this.y / num);\r\n    }\r\n\r\n    dot(other) {\r\n        return this.x * other.x + this.y * other.y;\r\n    }\r\n}\r\n\r\nclass AABB {\r\n\r\n    static findAABB(obj) {\r\n        let b = new Vec2D(Infinity, Infinity);\r\n        let e = new Vec2D(-Infinity, -Infinity);\r\n\r\n        for(const point of obj.points) {\r\n            b.x = Math.min(point.x, b.x);\r\n            b.y = Math.min(point.y, b.y);\r\n\r\n            e.x = Math.max(point.x, e.x);\r\n            e.y = Math.max(point.y, e.y);\r\n        }\r\n\r\n        return new AABB(b, e);\r\n    }\r\n\r\n    constructor(b, e) {\r\n        this.b = b;\r\n        this.e = e;\r\n    }\r\n\r\n    update(obj) {\r\n        this.b.add(new Vec2D(Infinity, Infinity));\r\n        this.e.add(new Vec2D(-Infinity, -Infinity));\r\n\r\n        for(const point of obj.points) {\r\n            this.b.x = Math.min(point.x, this.b.x);\r\n            this.b.y = Math.min(point.y, this.b.y);\r\n\r\n            this.e.x = Math.max(point.x, this.e.x);\r\n            this.e.y = Math.max(point.y, this.e.y);\r\n        }\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.strokeStyle = this.color;\r\n        ctx.strokeRect(this.b.x, this.b.y, this.e.x - this.b.x, this.e.y - this.b.y);\r\n    }\r\n}\r\n\r\nclass PhysObject {\r\n\r\n    static findCOM(points) {\r\n        let COM = new Vec2D(0, 0);\r\n        \r\n        for(const point of points) {\r\n            COM.add(point);\r\n        }\r\n\r\n        COM.x /= points.length;\r\n        COM.y /= points.length;\r\n\r\n        return COM;\r\n    }\r\n\r\n    constructor(pos, points, material = wood) {\r\n        this.force = new Vec2D(0, 0);\r\n        this.acc = new Vec2D(0, 0);\r\n        this.vel = new Vec2D(0, 0);\r\n        this.pos = pos;\r\n\r\n        this.torque = 0;\r\n        this.rotAcc = 0;\r\n        this.rotVel = 0;\r\n        this.angle = 0;\r\n\r\n        this.masks = [];\r\n\r\n        const center = PhysObject.findCOM(points);\r\n        points.forEach((p) => p.sub(center));\r\n        this.shape = points;\r\n        this.points = [];\r\n        for(let i = 0; i < points.length; i++) {\r\n            this.points[i] = Vec2D.rotate(new Vec2D(0, 0), this.shape[i], this.angle);\r\n            this.points[i].add(this.pos);\r\n        }\r\n\r\n        this.material = material;\r\n        const [mass, moi] = calculateMassAndMoi(this);\r\n\r\n        this.mass = mass;\r\n        this.moi = moi;\r\n        \r\n        this.AABB = AABB.findAABB(this);\r\n        this.func = null;\r\n    }\r\n\r\n    // a force consists of a position vector and a direction vector\r\n    applyForce(force) {\r\n        const r = new Vec2D(force.pos.x - this.pos.x, force.pos.y - this.pos.y);\r\n\r\n        this.force.add(force.dir);\r\n        this.torque += r.x * force.dir.y - r.y * force.dir.x;\r\n    }\r\n\r\n    stepForces(dt) {\r\n        this.acc = this.force.div(this.mass);\r\n        \r\n        if(this.mass == 0)\r\n            this.acc = new Vec2D(0, 0);\r\n        \r\n        this.vel.add(this.acc.mult(dt));\r\n        \r\n        this.pos.add(this.vel.mult(dt));\r\n        \r\n        this.rotAcc = this.torque / this.moi;\r\n\r\n        if(this.moi == 0)\r\n            this.rotAcc = 0;\r\n        \r\n        this.rotVel += this.rotAcc * dt;\r\n\r\n        this.angle += this.rotVel * dt;\r\n\r\n        this.force = new Vec2D(0, 0);\r\n        this.torque = 0;\r\n    }\r\n\r\n    update() {\r\n        for(let i = 0; i < this.points.length; i++) {\r\n            this.points[i] = Vec2D.rotate(new Vec2D(0, 0), this.shape[i], this.angle);\r\n            this.points[i].add(this.pos);\r\n        }\r\n\r\n        this.AABB.update(this);\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.strokeStyle = \"white\";\r\n        ctx.lineWidth = 1.5;\r\n\r\n        ctx.beginPath();\r\n        for(const point of this.points) {\r\n            ctx.lineTo(point.x, point.y);\r\n        }\r\n        ctx.closePath();\r\n\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\nclass PhysEnv {\r\n    constructor(iterations = 1) {\r\n        this.objects = [];\r\n        this.intervals = [];\r\n        this.sweepX = true;\r\n\r\n        this.iterations = iterations;\r\n    }\r\n\r\n    addObject(obj) {\r\n        let start = [obj.AABB.b, this.objects.length];\r\n        let end = [obj.AABB.e, this.objects.length];\r\n        \r\n        this.intervals.push(start, end);\r\n        this.objects.push(obj);\r\n    }\r\n\r\n    removeObject(obj) {\r\n        let idx = -1;\r\n        \r\n        for(let i = 0; i < this.objects.length; i++) {\r\n            if(obj == this.objects[i]) {\r\n                idx = i;\r\n                this.objects.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        for(let i = this.intervals.length - 1; i >= 0; i--) {\r\n            if(idx == this.intervals[i][1]) {\r\n                this.intervals.splice(i, 1);\r\n            } else if(this.intervals[i][1] > idx) {\r\n                this.intervals[i][1]--;\r\n            }\r\n        }\r\n    }\r\n\r\n    clearObjects() {\r\n        this.objects = [];\r\n        this.intervals = [];\r\n    }\r\n\r\n    sweepAndPrune() {\r\n        let overlaps = [];\r\n        let activeObjects = {};\r\n\r\n        if(this.sweepX) {\r\n            insertionSort(this.intervals, (x) => x[0].x);\r\n        } else {\r\n            insertionSort(this.intervals, (x) => x[0].y);\r\n        }\r\n\r\n        for(let i = this.intervals.length - 1; i >= 0; i--) {\r\n            const node = this.intervals[i];\r\n            if(activeObjects[node[1]] != null) {\r\n                delete activeObjects[node[1]];\r\n            } else {\r\n                for(const key in activeObjects) {\r\n                    if((this.objects[node[1]].mass == Infinity &&\r\n                        this.objects[activeObjects[key]].mass == Infinity) || \r\n                       (this.objects[node[1]].mass == 0 &&\r\n                        this.objects[activeObjects[key]].mass == 0))\r\n                        continue;\r\n                    overlaps.push([this.objects[node[1]], this.objects[activeObjects[key]]]);\r\n                }\r\n\r\n                activeObjects[node[1]] = node[1];\r\n            }\r\n        }\r\n\r\n        // for(const node of this.intervals) {\r\n        //     if(activeObjects[node[1]] != null) {\r\n        //         delete activeObjects[node[1]];\r\n        //     } else {\r\n        //         for(const key in activeObjects) {\r\n        //             overlaps.push([this.objects[node[1]], this.objects[activeObjects[key]]]);\r\n        //         }\r\n\r\n        //         activeObjects[node[1]] = node[1];\r\n        //     }\r\n        // }\r\n\r\n        return overlaps;\r\n    }\r\n\r\n    update(dt) {\r\n        this.stepForces(dt);\r\n        for(let i = 0; i < this.iterations; i++) {\r\n            this.detectCollisions();\r\n        }\r\n    }\r\n\r\n    stepForces(dt) {\r\n        for(const obj of this.objects) {\r\n            obj.stepForces(dt);\r\n            obj.update();\r\n        }\r\n    }\r\n\r\n    detectCollisions() {\r\n        let simplex = [];\r\n        let possibleCollisions = this.sweepAndPrune();\r\n        for(let [s1, s2] of possibleCollisions) {\r\n            if((simplex = this.GJK(s1, s2))) {\r\n                if(s1.func) s1.func(s1, s2);\r\n                if(s2.func) s2.func(s2, s1);\r\n                \r\n                if(s1.mass == 0 || s2.mass == 0)\r\n                    continue;\r\n\r\n                let masked = false;\r\n\r\n                for(let i = 0; i < s1.masks.length; i++) {\r\n                    for(let j = 0; j < s2.masks.length; j++) {\r\n                        if(s1.masks[i] == s2.masks[j]) {\r\n                            masked = true;\r\n                            \r\n                            i = s1.masks.length;\r\n                            j = s2.masks.length;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(masked)\r\n                    continue;\r\n\r\n                let [normal, depth] = this.EPA(s1, s2, simplex);\r\n                \r\n                let contacts = this.findContacts(s1, s2, normal);\r\n\r\n                if(contacts == null)\r\n                    continue;\r\n\r\n                for(const contact of contacts)\r\n                    this.applyImpulses(s1, s2, normal, contact);\r\n\r\n                this.resolveIntersections(s1, s2, normal, depth);\r\n\r\n                s1.update();\r\n                s2.update();\r\n            }\r\n        }\r\n    }\r\n\r\n    resolveIntersections(s1, s2, normal, depth) {\r\n        const slop = .1;\r\n        const percent = .85;\r\n        const correction = Math.max(depth - slop, 0) * percent;\r\n        const totalMass = s1.mass + s2.mass;\r\n        if(s1.mass == Infinity && s2.mass == Infinity) {\r\n            return;\r\n        } else if(s1.mass == Infinity) {\r\n            s2.pos.x += normal.x * correction;\r\n            s2.pos.y += normal.y * correction;\r\n        } else if(s2.mass == Infinity) {\r\n            s1.pos.x -= normal.x * correction;\r\n            s1.pos.y -= normal.y * correction;\r\n        } else {\r\n            s1.pos.x -= normal.x * correction * s2.mass / totalMass;\r\n            s1.pos.y -= normal.y * correction * s2.mass / totalMass;\r\n            \r\n            s2.pos.x += normal.x * correction * s1.mass / totalMass;\r\n            s2.pos.y += normal.y * correction * s1.mass / totalMass;\r\n        }\r\n    }\r\n\r\n    applyImpulses(s1, s2, normal, contact) {\r\n        const r1 = Vec2D.dif(s1.pos, contact);\r\n        const v1 = s1.vel.addRet(Vec2D.cross(s1.rotVel, r1));\r\n\r\n        const r2 = Vec2D.dif(s2.pos, contact);\r\n        const v2 = s2.vel.addRet(Vec2D.cross(s2.rotVel, r2));\r\n\r\n        const abVel = Vec2D.dif(v1, v2);\r\n        const contactVel = abVel.dot(normal);\r\n\r\n        if(contactVel >= 0)\r\n            return;\r\n\r\n        const armA = Vec2D.cross(r1, normal);\r\n        const armB = Vec2D.cross(r2, normal);\r\n\r\n        const rest = Math.min(s1.material.restitution, s2.material.restitution);\r\n\r\n        const m = 1 / s1.mass + 1 / s2.mass + armA * armA / s1.moi + armB * armB / s2.moi; \r\n        const j = (-(rest + 1) * contactVel) / m;\r\n        const impulse = normal.mult(j);\r\n\r\n        s1.vel.sub(impulse.div(s1.mass));\r\n        s2.vel.add(impulse.div(s2.mass));\r\n        \r\n        const r1CrossI = Vec2D.cross(r1, impulse);\r\n        const r2CrossI = Vec2D.cross(r2, impulse);\r\n\r\n        s1.rotVel -= r1CrossI / s1.moi;\r\n        s2.rotVel += r2CrossI / s2.moi;\r\n\r\n        const tangent = Vec2D.normalize(abVel.subRet(normal.mult(contactVel)));\r\n        const jt = -abVel.dot(tangent) / m;\r\n\r\n        const mu = Math.sqrt(s1.material.sFriction * s1.material.sFriction + s2.material.sFriction * s2.material.sFriction);\r\n\r\n        if(Math.abs(jt) < j * mu) {\r\n            var impulset = tangent.mult(jt);\r\n        } else {\r\n            const dFriction = Math.sqrt(s1.material.dFriction * s1.material.dFriction + s2.material.dFriction * s2.material.dFriction);\r\n            var impulset = tangent.mult(-j * dFriction);\r\n        }\r\n\r\n        if(!isFinite(impulset.x) || !isFinite(impulset.y))\r\n            return;\r\n\r\n        s1.vel.sub(impulset.div(s1.mass));\r\n        s2.vel.add(impulset.div(s2.mass));\r\n\r\n        const r1CrossIt = Vec2D.cross(r1, impulset);\r\n        const r2CrossIt = Vec2D.cross(r2, impulset);\r\n\r\n        s1.rotVel -= r1CrossIt / s1.moi;\r\n        s2.rotVel += r2CrossIt / s2.moi;\r\n    }\r\n\r\n    findContacts(s1, s2, normal) {\r\n        const [p1, e1] = this.findCollisionEdge(s1, normal);\r\n        const [p2, e2] = this.findCollisionEdge(s2, normal.mult(-1));\r\n\r\n        const e1Dif = Vec2D.dif(e1[1], e1[0]);\r\n        const e2Dif = Vec2D.dif(e2[1], e2[0]);\r\n\r\n        let ref, pRef, eRef, inc, pInc, eInc;\r\n        if(Math.abs(e1Dif.dot(normal)) <= Math.abs(e2Dif.dot(normal))) {\r\n            pRef = p1;\r\n            eRef = e1;\r\n            ref = e1Dif;\r\n\r\n            pInc = p2;\r\n            eInc = e2;\r\n            inc = e2Dif;\r\n        } else {\r\n            pRef = p2;\r\n            eRef = e2;\r\n            ref = e2Dif;\r\n\r\n            pInc = p1;\r\n            eInc = e1;\r\n            inc = e1Dif;\r\n        }\r\n\r\n        const refV = Vec2D.normalize(ref).mult(-1);\r\n        const o1 = refV.dot(eRef[0]);\r\n\r\n        let cp = clip(eInc[0], eInc[1], refV, o1);\r\n\r\n        if(cp.length < 2) return;\r\n\r\n        const o2 = refV.dot(eRef[1]);\r\n        \r\n        cp = clip(cp[0], cp[1], refV.mult(-1), -o2);\r\n        \r\n        if(cp.length < 2) return;\r\n\r\n        let refNorm = Vec2D.cross(ref, -1);\r\n        \r\n        const max = refNorm.dot(pRef);\r\n\r\n        if(refNorm.dot(cp[1]) - max < 0)\r\n            cp.splice(1, 1);\r\n\r\n        if(refNorm.dot(cp[0]) - max < 0)\r\n            cp.splice(0, 1);\r\n    \r\n        return cp;\r\n    }\r\n\r\n    findCollisionEdge(s, normal) {\r\n        let v = null;\r\n        let idx = null;\r\n        let dot = -Infinity;\r\n    \r\n        for(const [i, point] of s.points.entries()) {\r\n            const proj = point.dot(normal);\r\n            if(proj > dot) {\r\n                v = point;\r\n                idx = i;\r\n                dot = proj;\r\n            }\r\n        }\r\n    \r\n        const v0 = s.points[(idx - 1 + s.points.length) % s.points.length];\r\n        const v1 = s.points[(idx + 1) % s.points.length];\r\n\r\n        const leftEdge = Vec2D.dif(v, v0);\r\n        const rightEdge = Vec2D.dif(v, v1);\r\n\r\n        if(Vec2D.normalize(rightEdge).dot(normal) <= Vec2D.normalize(leftEdge).dot(normal)) {\r\n            return [v, [v0, v], leftEdge];\r\n        } else {\r\n            return [v, [v, v1], rightEdge];\r\n        }\r\n    }\r\n\r\n    GJK(s1, s2) {\r\n        let d = Vec2D.normalize(Vec2D.dif(s1.pos, s2.pos));\r\n        let simplex = [minkowskiDifSupport(s1, s2, d)];\r\n        d = Vec2D.dif(simplex[0], new Vec2D(0, 0));\r\n\r\n        while(true) {\r\n            d = Vec2D.normalize(d);\r\n            const A = minkowskiDifSupport(s1, s2, d);\r\n            if(A.dot(d) < 0)\r\n                return false;\r\n            simplex.push(A);\r\n            if(this.handleSimplex(simplex, d))\r\n                return simplex;\r\n        }\r\n    }\r\n\r\n    handleSimplex(simplex, d) {\r\n        if(simplex.length == 2)\r\n            return this.lineCase(simplex, d);\r\n        return this.triangleCase(simplex, d);\r\n    }\r\n\r\n    lineCase(simplex, d) {\r\n        let [B, A] = simplex;\r\n        let AB = Vec2D.dif(A, B);\r\n        let AO = Vec2D.dif(A, new Vec2D(0, 0));\r\n        let ABperp = Vec2D.tripleProd(AB, AO, AB);\r\n        d.x = ABperp.x;\r\n        d.y = ABperp.y;\r\n        return false;\r\n    }\r\n\r\n    triangleCase(simplex, d) {\r\n        let [C, B, A] = simplex;\r\n\r\n        let AB = Vec2D.dif(A, B);\r\n        let AC = Vec2D.dif(A, C);\r\n        let AO = Vec2D.dif(A, new Vec2D(0, 0));\r\n\r\n        let ABperp = Vec2D.tripleProd(AC, AB, AB);\r\n        let ACperp = Vec2D.tripleProd(AB, AC, AC);\r\n\r\n        if(ABperp.dot(AO) > 0) {\r\n\r\n            simplex.splice(0, 1);\r\n\r\n            d.x = ABperp.x;\r\n            d.y = ABperp.y;\r\n\r\n            return false;\r\n        } else if(ACperp.dot(AO) > 0) {\r\n\r\n            simplex.splice(1, 1);\r\n\r\n            d.x = ACperp.x;\r\n            d.y = ACperp.y;\r\n\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // expanding polytope algorithm\r\n    EPA(s1, s2, simplex) {\r\n        while(true) {\r\n            let [edgeDist, edgeNorm, edgeIDX] = this.findClosestEdge(simplex);\r\n            let sup = minkowskiDifSupport(s1, s2, edgeNorm);\r\n\r\n            const d = sup.dot(edgeNorm);\r\n            \r\n            if(d - edgeDist <= 0.01) {\r\n                return [edgeNorm, edgeDist];\r\n            } else {\r\n                simplex.splice(edgeIDX, 0, sup);\r\n            }\r\n        }\r\n    }\r\n\r\n    findClosestEdge(simplex) {\r\n        let dist = Infinity;\r\n        let normal, idx;\r\n\r\n        for(let i = 0; i < simplex.length; i++) {\r\n            const j = (i + 1) % simplex.length;\r\n\r\n            const edge = Vec2D.dif(simplex[i], simplex[j]);\r\n            const n = Vec2D.normalize(Vec2D.tripleProd(edge, simplex[i], edge));\r\n\r\n            const d = n.dot(simplex[i]);\r\n\r\n            if(d < dist) {\r\n                dist = d;\r\n                normal = n;\r\n                idx = j;\r\n            }\r\n        }\r\n\r\n        return [dist, normal, idx];\r\n    }\r\n\r\n    drawObjects(ctx) {\r\n        for(const obj of this.objects) {\r\n            obj.draw(ctx);\r\n        }\r\n    }\r\n}\r\n\r\nexports.Vec2D = Vec2D;\r\nexports.PhysEnv = PhysEnv;\r\nexports.PhysObject = PhysObject;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/physx.js?");

/***/ }),

/***/ "./src/shared_modules/serialize.js":
/*!*****************************************!*\
  !*** ./src/shared_modules/serialize.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("let avro = __webpack_require__(/*! avsc */ \"./node_modules/avsc/lib/index.js\");\r\nlet util = __webpack_require__(/*! ./util */ \"./src/shared_modules/util.js\");\r\n\r\n\r\nlet car_schema = {\r\n    name: '_0',\r\n    default: null,\r\n    type: [ 'null', {\r\n        type: 'record',\r\n        fields: [\r\n            { name: 'ready', type: 'boolean' },\r\n            { name: 'lap', type: 'int' },\r\n            { name: 'hue', type: 'int' },\r\n            { name: 'angle', type: 'double' },\r\n            { name: 'rotVel', type: 'double' },\r\n            { \r\n                name: 'pos',\r\n                type: {\r\n                    type: 'record',\r\n                    fields: [\r\n                        { name: 'x', type: 'double' },\r\n                        { name: 'y', type: 'double' }\r\n                    ]\r\n                }\r\n            },\r\n            { \r\n                name: 'vel', \r\n                type: {\r\n                    type: 'record',\r\n                    fields: [\r\n                        { name: 'x', type: 'double' },\r\n                        { name: 'y', type: 'double' }\r\n                    ]\r\n                }\r\n            },\r\n            {\r\n                name: 'inputs',\r\n                type: ['null', {\r\n                    type: 'record',\r\n                    fields: [\r\n                        { name: 'left',  type: 'boolean' },\r\n                        { name: 'right', type: 'boolean' },\r\n                        { name: 'up',    type: 'boolean' },\r\n                        { name: 'down',  type: 'boolean' },\r\n                        { name: 'shift', type: 'boolean' },\r\n                        { name: 'enter', type: 'boolean' },\r\n                    ]\r\n                }]\r\n            }\r\n        ]\r\n    }]\r\n};\r\n\r\ncar_schema_list = [];\r\n\r\nfor(let id = 0; id < util.MAX_PLAYERS; id++) {\r\n    let new_schema = util.copyObj(car_schema);\r\n    new_schema.name = \"_\" + id;\r\n\r\n    car_schema_list.push(new_schema);\r\n}\r\n\r\nconst BUNDLE_TYPE = avro.Type.forSchema({\r\n    type: 'record',\r\n    fields: [\r\n        { name: 'tick', type: 'long' },\r\n        {\r\n            name: 'packets', \r\n            type: {\r\n                type: 'record',\r\n                fields: [\r\n                    { name: 'id', default: null, type: ['null', 'int'] },\r\n                    {\r\n                        name: 'dynamic',\r\n                        default: null,\r\n                        type: [ 'null', {\r\n                            type: 'record',\r\n                            fields: [\r\n                                { \r\n                                    name: 'cars', \r\n                                    type: {\r\n                                        type: 'record',\r\n                                        fields: car_schema_list,\r\n                                    }\r\n                                }\r\n                            ]\r\n                        }]\r\n                    },\r\n                    {\r\n                        name: 'static',\r\n                        default: null,\r\n                        type: [ 'null', {\r\n                            type: 'record',\r\n                            fields: [\r\n                                { name: 'scene', type: 'string' },\r\n                                { \r\n                                    name: 'walls', \r\n                                    type: {\r\n                                        type: 'array',\r\n                                        items: [\r\n                                            {\r\n                                                type: 'array', \r\n                                                items: [\r\n                                                    {\r\n                                                        type: 'record',\r\n                                                        fields: [\r\n                                                            {\r\n                                                                name: 'pos',\r\n                                                                type: {\r\n                                                                    type: 'record',\r\n                                                                    fields: [\r\n                                                                        { name: 'x', type: 'double' },\r\n                                                                        { name: 'y', type: 'double' }\r\n                                                                    ]\r\n                                                                }\r\n                                                            },\r\n                                                            {\r\n                                                                name: 'points',\r\n                                                                type: {\r\n                                                                    type: 'array',\r\n                                                                    items: [\r\n                                                                        {\r\n                                                                            type: 'record',\r\n                                                                            fields: [\r\n                                                                                { name: 'x', type: 'double' },\r\n                                                                                { name: 'y', type: 'double' }\r\n                                                                            ]\r\n                                                                        }\r\n                                                                    ]\r\n                                                                }\r\n                                                            }\r\n                                                        ]\r\n                                                    }\r\n                                                ]\r\n                                            }\r\n                                        ]\r\n                                    }\r\n                                },\r\n                            ]\r\n                        }]\r\n                    },\r\n                    {\r\n                        name: 'inputs',\r\n                        default: null,\r\n                        type: ['null', {\r\n                            type: 'record',\r\n                            fields: [\r\n                                { name: 'left',  type: 'boolean' },\r\n                                { name: 'right', type: 'boolean' },\r\n                                { name: 'up',    type: 'boolean' },\r\n                                { name: 'down',  type: 'boolean' },\r\n                                { name: 'shift', type: 'boolean' },\r\n                                { name: 'enter', type: 'boolean' },\r\n                            ]\r\n                        }]\r\n                    },\r\n                    { \r\n                        name: 'ping', \r\n                        default: null, \r\n                        type: ['null', {\r\n                            type: 'record',\r\n                            fields: [\r\n                                { name: 'timestamp', type: ['long'] },\r\n                                { name: 'latency', type: ['double'] },\r\n                            ]\r\n                        }]\r\n                    },\r\n                ]\r\n            }\r\n        },\r\n    ]\r\n});\r\n\r\nlet encode = (data) => {\r\n    if(data.packets.dynamic) {\r\n        var cars = data.packets.dynamic.cars;\r\n        let temp = {};\r\n\r\n        for(const [id, car] of Object.entries(cars))\r\n            temp['_'+id] = car;\r\n\r\n        data.packets.dynamic.cars = temp;\r\n    }\r\n\r\n    const buffer = BUNDLE_TYPE.toBuffer(data);\r\n\r\n    if(cars)\r\n        data.packets.dynamic.cars = cars;\r\n    \r\n    return buffer;\r\n}\r\n\r\nlet decode = (buf) => {\r\n    const buffer = Buffer.from(buf, 'utf8')\r\n    const data = BUNDLE_TYPE.fromBuffer(buffer);\r\n\r\n    if(data.packets.dynamic) {\r\n        let cars = data.packets.dynamic.cars;\r\n\r\n        for(const [id, car] of Object.entries(cars)) {\r\n            delete cars[id];\r\n\r\n            if(car)\r\n                cars[id.substr(1)] = car;\r\n        }\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\n// let vec = new Vec2D(-1, 1);\r\n// let car = new Car(vec, 60);\r\n// let cars = {\r\n//     '2': car,\r\n//     '4': car,\r\n// };\r\n\r\n// let walls = [\r\n//     [[new Vec2D(0, 0), new Vec2D(0, 1), new Vec2D(1, 1), new Vec2D(1, 0)], [new Vec2D(0, 0), new Vec2D(0, -1), new Vec2D(1, -1), new Vec2D(1, 0)]],\r\n//     [[new Vec2D(0, 0), new Vec2D(0, 1), new Vec2D(-1, 1), new Vec2D(-1, 0)], [new Vec2D(0, 0), new Vec2D(0, -1), new Vec2D(-1, -1), new Vec2D(-1, 0)]],\r\n// ];\r\n\r\n// let bundle = {\r\n//     tick: 16000000,\r\n//     packets: {\r\n//         id: 4,\r\n//         dynamic: {\r\n//             cars: cars,\r\n//         },\r\n//         static: {\r\n//             scene: 'lobby',\r\n//             walls: walls,\r\n//         },\r\n//     },\r\n// };\r\n\r\n// const buff = encode(bundle); \r\n\r\n// console.log(buff);\r\n// console.log(decode(buff).packets.dynamic.cars);\r\n// console.log(bundle.packets.dynamic.cars)\r\n\r\nexports.encode = encode;\r\nexports.decode = decode;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/serialize.js?");

/***/ }),

/***/ "./src/shared_modules/trackGenerator.js":
/*!**********************************************!*\
  !*** ./src/shared_modules/trackGenerator.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const PhysX = __webpack_require__(/*! ./physx */ \"./src/shared_modules/physx.js\");\r\nconst Vec2D = PhysX.Vec2D;\r\n\r\n//https://github.com/josephg/noisejs/blob/master/perlin.js\r\n\r\n/*\r\n * A speed-improved perlin and simplex noise algorithms for 2D.\r\n *\r\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\r\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\r\n * Better rank ordering method by Stefan Gustavson in 2012.\r\n * Converted to Javascript by Joseph Gentle.\r\n *\r\n * Version 2012-03-09\r\n *\r\n * This code was placed in the public domain by its original author,\r\n * Stefan Gustavson. You may use it as you see fit, but\r\n * attribution is appreciated.\r\n *\r\n */\r\n\r\nvar mod = global.noise = {};\r\n\r\nfunction Grad(x, y, z) {\r\n    this.x = x; this.y = y; this.z = z;\r\n}\r\n\r\nGrad.prototype.dot2 = function(x, y) {\r\n    return this.x*x + this.y*y;\r\n};\r\n\r\nGrad.prototype.dot3 = function(x, y, z) {\r\n    return this.x*x + this.y*y + this.z*z;\r\n};\r\n\r\nvar grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\r\n                new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\r\n                new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];\r\n\r\nvar p = [151,160,137,91,90,15,\r\n131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\r\n190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\r\n88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\r\n77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\r\n102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\r\n135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\r\n5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\r\n223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\r\n129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\r\n251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\r\n49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\r\n138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\r\n// To remove the need for index wrapping, double the permutation table length\r\nvar perm = new Array(512);\r\nvar gradP = new Array(512);\r\n\r\n// This isn't a very good seeding function, but it works ok. It supports 2^16\r\n// different seed values. Write something better if you need more seeds.\r\nmod.seed = function(seed) {\r\n    if(seed > 0 && seed < 1) {\r\n        // Scale the seed out\r\n        seed *= 65536;\r\n    }\r\n\r\n    seed = Math.floor(seed);\r\n    if(seed < 256) {\r\n        seed |= seed << 8;\r\n    }\r\n\r\n    for(var i = 0; i < 256; i++) {\r\n        var v;\r\n        if (i & 1) {\r\n            v = p[i] ^ (seed & 255);\r\n        } else {\r\n            v = p[i] ^ ((seed>>8) & 255);\r\n        }\r\n\r\n        perm[i] = perm[i + 256] = v;\r\n        gradP[i] = gradP[i + 256] = grad3[v % 12];\r\n    }\r\n};\r\n\r\nmod.seed(0);\r\n\r\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\r\nvar F2 = 0.5*(Math.sqrt(3)-1);\r\nvar G2 = (3-Math.sqrt(3))/6;\r\n\r\nvar F3 = 1/3;\r\nvar G3 = 1/6;\r\n\r\n// 2D simplex noise\r\nmod.simplex2 = function(xin, yin) {\r\n    var n0, n1, n2; // Noise contributions from the three corners\r\n    // Skew the input space to determine which simplex cell we're in\r\n    var s = (xin+yin)*F2; // Hairy factor for 2D\r\n    var i = Math.floor(xin+s);\r\n    var j = Math.floor(yin+s);\r\n    var t = (i+j)*G2;\r\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\r\n    var y0 = yin-j+t;\r\n    // For the 2D case, the simplex shape is an equilateral triangle.\r\n    // Determine which simplex we are in.\r\n    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\r\n    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\r\n        i1=1; j1=0;\r\n    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\r\n        i1=0; j1=1;\r\n    }\r\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\r\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\r\n    // c = (3-sqrt(3))/6\r\n    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\r\n    var y1 = y0 - j1 + G2;\r\n    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\r\n    var y2 = y0 - 1 + 2 * G2;\r\n    // Work out the hashed gradient indices of the three simplex corners\r\n    i &= 255;\r\n    j &= 255;\r\n    var gi0 = gradP[i+perm[j]];\r\n    var gi1 = gradP[i+i1+perm[j+j1]];\r\n    var gi2 = gradP[i+1+perm[j+1]];\r\n    // Calculate the contribution from the three corners\r\n    var t0 = 0.5 - x0*x0-y0*y0;\r\n    if(t0<0) {\r\n        n0 = 0;\r\n    } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\r\n    }\r\n    var t1 = 0.5 - x1*x1-y1*y1;\r\n    if(t1<0) {\r\n        n1 = 0;\r\n    } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * gi1.dot2(x1, y1);\r\n    }\r\n    var t2 = 0.5 - x2*x2-y2*y2;\r\n    if(t2<0) {\r\n        n2 = 0;\r\n    } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * gi2.dot2(x2, y2);\r\n    }\r\n    // Add contributions from each corner to get the final noise value.\r\n    // The result is scaled to return values in the interval [-1,1].\r\n    return 70 * (n0 + n1 + n2);\r\n};\r\n\r\n// 3D simplex noise\r\nmod.simplex3 = function(xin, yin, zin) {\r\n    var n0, n1, n2, n3; // Noise contributions from the four corners\r\n\r\n    // Skew the input space to determine which simplex cell we're in\r\n    var s = (xin+yin+zin)*F3; // Hairy factor for 2D\r\n    var i = Math.floor(xin+s);\r\n    var j = Math.floor(yin+s);\r\n    var k = Math.floor(zin+s);\r\n\r\n    var t = (i+j+k)*G3;\r\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\r\n    var y0 = yin-j+t;\r\n    var z0 = zin-k+t;\r\n\r\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\r\n    // Determine which simplex we are in.\r\n    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\r\n    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\r\n    if(x0 >= y0) {\r\n        if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }\r\n        else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }\r\n        else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }\r\n    } else {\r\n        if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }\r\n        else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }\r\n        else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }\r\n    }\r\n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\r\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\r\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\r\n    // c = 1/6.\r\n    var x1 = x0 - i1 + G3; // Offsets for second corner\r\n    var y1 = y0 - j1 + G3;\r\n    var z1 = z0 - k1 + G3;\r\n\r\n    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\r\n    var y2 = y0 - j2 + 2 * G3;\r\n    var z2 = z0 - k2 + 2 * G3;\r\n\r\n    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\r\n    var y3 = y0 - 1 + 3 * G3;\r\n    var z3 = z0 - 1 + 3 * G3;\r\n\r\n    // Work out the hashed gradient indices of the four simplex corners\r\n    i &= 255;\r\n    j &= 255;\r\n    k &= 255;\r\n    var gi0 = gradP[i+   perm[j+   perm[k   ]]];\r\n    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];\r\n    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];\r\n    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];\r\n\r\n    // Calculate the contribution from the four corners\r\n    var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\r\n    if(t0<0) {\r\n        n0 = 0;\r\n    } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\r\n    }\r\n    var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\r\n    if(t1<0) {\r\n        n1 = 0;\r\n    } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\r\n    }\r\n    var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\r\n    if(t2<0) {\r\n        n2 = 0;\r\n    } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\r\n    }\r\n    var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\r\n    if(t3<0) {\r\n        n3 = 0;\r\n    } else {\r\n        t3 *= t3;\r\n        n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\r\n    }\r\n    // Add contributions from each corner to get the final noise value.\r\n    // The result is scaled to return values in the interval [-1,1].\r\n    return 32 * (n0 + n1 + n2 + n3);\r\n\r\n};\r\n\r\n// ##### Perlin noise stuff\r\n\r\nfunction fade(t) {\r\n    return t*t*t*(t*(t*6-15)+10);\r\n}\r\n\r\nfunction lerp(a, b, t) {\r\n    return (1-t)*a + t*b;\r\n}\r\n\r\n// 2D Perlin Noise\r\nmod.perlin2 = function(x, y) {\r\n    // Find unit grid cell containing point\r\n    var X = Math.floor(x), Y = Math.floor(y);\r\n    // Get relative xy coordinates of point within that cell\r\n    x = x - X; y = y - Y;\r\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n    X = X & 255; Y = Y & 255;\r\n\r\n    // Calculate noise contributions from each of the four corners\r\n    var n00 = gradP[X+perm[Y]].dot2(x, y);\r\n    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);\r\n    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);\r\n    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);\r\n\r\n    // Compute the fade curve value for x\r\n    var u = fade(x);\r\n\r\n    // Interpolate the four results\r\n    return lerp(\r\n        lerp(n00, n10, u),\r\n        lerp(n01, n11, u),\r\n        fade(y));\r\n};\r\n\r\n// 3D Perlin Noise\r\nmod.perlin3 = function(x, y, z) {\r\n    // Find unit grid cell containing point\r\n    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\r\n    // Get relative xyz coordinates of point within that cell\r\n    x = x - X; y = y - Y; z = z - Z;\r\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n    X = X & 255; Y = Y & 255; Z = Z & 255;\r\n\r\n    // Calculate noise contributions from each of the eight corners\r\n    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);\r\n    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);\r\n    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);\r\n    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);\r\n    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);\r\n    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);\r\n    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);\r\n    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);\r\n\r\n    // Compute the fade curve value for x, y, z\r\n    var u = fade(x);\r\n    var v = fade(y);\r\n    var w = fade(z);\r\n\r\n    // Interpolate\r\n    return lerp(\r\n        lerp(\r\n        lerp(n000, n100, u),\r\n        lerp(n001, n101, u), w),\r\n        lerp(\r\n        lerp(n010, n110, u),\r\n        lerp(n011, n111, u), w),\r\n        v);\r\n};\r\n\r\nfunction getAngle(vertex, point1, point2) {\r\n    const theta1 = Math.atan2(point1.y - vertex.y, point1.x - vertex.x);\r\n    const theta2 = Math.atan2(point2.y - vertex.y, point2.x - vertex.x);\r\n\r\n    let diff = modulo(theta2 - theta1 + Math.PI, Math.PI * 2) - Math.PI;\r\n    diff = diff < -Math.PI ? diff + Math.PI * 2 : diff;\r\n    return diff < -Math.PI ? diff + Math.PI * 2 : diff;\r\n}\r\n\r\nfunction modulo(n, m) {\r\n    return ((n % m) + m) % m;\r\n}\r\n\r\nclass Straightaway {\r\n    constructor(startPoint, endPoint) {\r\n        this.p1 = startPoint;\r\n        this.p2 = endPoint;\r\n        this.length = Vec2D.distance(this.p1, this.p2);\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.moveTo(this.p1.x, this.p1.y);\r\n        ctx.lineTo(this.p2.x, this.p2.y);\r\n    }\r\n}\r\n\r\nclass Corner {\r\n    constructor(startPoint, endPoint, focus) {\r\n        this.p1 = startPoint;\r\n        this.p2 = endPoint;\r\n        this.focus = focus;\r\n\r\n        this.radius = Vec2D.distance(startPoint, focus);\r\n        this.theta = getAngle(focus, startPoint, endPoint);\r\n        this.length = this.radius * this.theta;\r\n\r\n        this.startAngle = Math.atan2(startPoint.y - focus.y, startPoint.x - focus.x);\r\n        this.endAngle = this.startAngle + this.theta;\r\n        this.counterClockwise = Math.sign(this.theta) < 0;\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.arc(this.focus.x, this.focus.y, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\r\n    }\r\n}\r\n\r\nclass Track {\r\n    constructor(center = new Vec2D(0, 0)) {\r\n        this.parts = [];\r\n        this.width = 18;\r\n        this.center = center;\r\n\r\n        this.innerWall = [];\r\n        this.outerWall = [];\r\n\r\n        let success = false;\r\n        while(!success) {\r\n            this.seedPoints = this.generateSeedPoints(20);\r\n            success = this.generateTrack();\r\n        }\r\n\r\n        const spawnPart = this.parts[this.parts.length - 1];\r\n\r\n        this.spawn = {\r\n            x: spawnPart.p1.x,\r\n            y: spawnPart.p1.y,\r\n            d: Math.atan2(spawnPart.p2.y - spawnPart.p1.y, spawnPart.p2.x - spawnPart.p1.x),\r\n        };\r\n    }\r\n\r\n    generateTrack() {\r\n        let lastPoint = null;\r\n\r\n        for(let i = 0; i < this.seedPoints.length; i++) {\r\n            const vertex = this.seedPoints[i];\r\n            const p1 = this.seedPoints[modulo(i - 1, this.seedPoints.length)];\r\n            const p2 = this.seedPoints[modulo(i + 1, this.seedPoints.length)];\r\n\r\n            const theta1 = Math.atan2(p1.y - vertex.y, p1.x - vertex.x);\r\n            const theta2 = Math.atan2(p2.y - vertex.y, p2.x - vertex.x);\r\n            const bisector = getAngle(vertex, p1, p2) / 2;\r\n            \r\n            // const dist = Math.min(Point.distance(vertex, p1), Point.distance(vertex, p2));\r\n            const leg = 20;//Math.max(Math.random() * dist/2, 20);\r\n\r\n            const middle = Math.abs(leg / Math.cos(bisector));\r\n\r\n            const x1 = Math.cos(theta1) * leg + vertex.x;\r\n            const y1 = Math.sin(theta1) * leg + vertex.y;\r\n            const startPoint = new Vec2D(x1, y1);\r\n\r\n            const x2 = Math.cos(theta2) * leg + vertex.x;\r\n            const y2 = Math.sin(theta2) * leg + vertex.y;\r\n            const endPoint = new Vec2D(x2, y2);\r\n\r\n            const x3 = Math.cos(theta1 + bisector) * middle + vertex.x;\r\n            const y3 = Math.sin(theta1 + bisector) * middle + vertex.y;\r\n            const focus = new Vec2D(x3, y3);\r\n\r\n            if(lastPoint) {\r\n                this.parts.push(new Straightaway(lastPoint, startPoint));\r\n            }\r\n\r\n            this.parts.push(new Corner(startPoint, endPoint, focus));\r\n\r\n            lastPoint = endPoint;\r\n        }\r\n\r\n        if(this.parts.length == 0)\r\n            return false;\r\n\r\n        this.parts.push(new Straightaway(lastPoint, this.parts[0].p1));\r\n\r\n        return true;\r\n    }\r\n\r\n    generateSeedPoints(turns) {\r\n        let points = [];\r\n        let radius = 100;\r\n        let minTheta = Math.PI/10;\r\n        \r\n        for(let i = 0; i < turns; i++) {\r\n            let theta = Math.random() * Math.PI * 2;\r\n\r\n            let distanced = false;\r\n            let depth = 0;\r\n\r\n            while(!distanced) {\r\n                depth++;\r\n                distanced = true;\r\n                for(const element of points) {\r\n                    if(Math.abs(element[1] - theta) < minTheta) {\r\n                        distanced = false;\r\n                        theta = Math.random() * Math.PI * 2;\r\n                    }\r\n                }\r\n\r\n                if(depth > 50) {\r\n                    break;\r\n                }\r\n            }\r\n            if(!distanced) {\r\n                break;\r\n            }\r\n\r\n            let nx = Math.cos(theta) * radius + this.center.x;\r\n            let ny = Math.sin(theta) * radius + this.center.y;\r\n\r\n            points.push([new Vec2D(nx, ny), theta]);\r\n        }\r\n\r\n        points.sort((a, b) => a[1] - b[1]);\r\n        points = points.map(x => x[0]);\r\n\r\n        //warp points\r\n        points = Track.perlinIterate(points, 10, 20, .001);\r\n        points = Track.perlinIterate(points, 10, 4, .01);\r\n        points = Track.perlinIterate(points, 10, 1, .1);\r\n\r\n        //recenter points\r\n        let offset = Track.getCenter(points);\r\n        for(const point of points) {\r\n            point.x += this.center.x - offset.x;\r\n            point.y += this.center.y - offset.y;\r\n        }\r\n\r\n        //apply separation forces\r\n        let separated = false;\r\n        while(!separated) {\r\n            separated = true;\r\n            for(const point of points) {\r\n                const v = Track.getSeparationVector(point, points);\r\n                point.x += v.x;\r\n                point.y += v.y;\r\n\r\n                if(v.x != 0 || v.y != 0) {\r\n                    separated = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        //straighten edges\r\n        points = Track.cleanTrack(points);\r\n\r\n        return points;\r\n    }\r\n\r\n    static cleanTrack(points) {\r\n        let straight = false;\r\n\r\n        while(!straight) {\r\n            straight = true;\r\n            for(let i = 0; i < points.length; i++) {\r\n                const vertex = points[i];\r\n                const p1 = points[modulo(i - 1, points.length)];\r\n                const p2 = points[modulo(i + 1, points.length)];\r\n                \r\n                const theta = Math.abs(getAngle(vertex, p1, p2));\r\n\r\n                if(theta > Math.PI * .9 || theta < 1.1) {\r\n                    points.splice(i, 1);\r\n                    straight = false;\r\n                    i--;\r\n                }\r\n            }\r\n        }\r\n\r\n        return points;\r\n    }\r\n\r\n    static getCenter(points) {\r\n        let center = new Vec2D(0, 0);\r\n        \r\n        for(const point of points) {\r\n            center.x += point.x / points.length;\r\n            center.y += point.y / points.length;\r\n        }\r\n\r\n        return center;\r\n    }\r\n\r\n    static perlinIterate(points, iterations, steps, warpFactor) {\r\n        noise.seed(Math.random());\r\n\r\n        for (let i = 0; i < iterations; i++) {\r\n            for (const point of points) {\r\n                point.x += noise.simplex2(point.x * warpFactor, point.y * warpFactor) * steps;\r\n                point.y += noise.simplex2(-point.x * warpFactor, -point.y * warpFactor) * steps;\r\n            }\r\n        }\r\n\r\n        return points;\r\n    }\r\n    \r\n\tstatic normalize (x, y) {\r\n\t\tconst dist = Math.sqrt(x*x + y*y);\r\n\r\n\t\tif(dist == 0) return [0, 0];\r\n\r\n\t\treturn [x/dist, y/dist];\r\n    }\r\n    \r\n    static getSeparationVector(point, cluster) {\r\n\t\tlet neighbors = 0;\r\n\t\tlet xForce = 0;\r\n\t\tlet yForce = 0;\r\n\r\n\t\tfor(let i = 0; i < cluster.length; i++) {\r\n\t\t\tconst xDif = point.x - cluster[i].x;\r\n\t\t\tconst yDif = point.y - cluster[i].y;\r\n\t\t\tconst dist = xDif*xDif + yDif*yDif;\r\n\t\t\tconst minDist = 50;\r\n\r\n\t\t\tif(cluster[i] != point && dist < minDist*minDist) {\r\n\t\t\t\tneighbors++;\r\n\r\n\t\t\t\txForce += xDif;\r\n\t\t\t\tyForce += yDif;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(neighbors == 0) return new Vec2D(0, 0);\r\n\t\t \r\n\t\txForce /= neighbors;\t\r\n        yForce /= neighbors;\r\n        \r\n        const vector = this.normalize(xForce, yForce);\r\n\r\n\t\treturn new Vec2D(vector[0], vector[1]);\r\n\t}\r\n\r\n    static genMeshCorner(corner, offset) {\r\n        let points = [];\r\n    \r\n        const radius = (corner.theta > 0) ? corner.radius + offset : corner.radius - offset;\r\n        const freq = 24 / (2 * Math.PI);\r\n        const pointAmt = Math.ceil(Math.abs(corner.theta) * freq);\r\n        const dtheta = corner.theta / pointAmt;\r\n        let theta = corner.startAngle;\r\n    \r\n        for(let i = 0; i <= pointAmt; i++) {\r\n            const nx = corner.focus.x + radius * Math.cos(theta);\r\n            const ny = corner.focus.y + radius * Math.sin(theta);\r\n    \r\n            points.push(new Vec2D(nx, ny));\r\n    \r\n            theta += dtheta;\r\n        }\r\n    \r\n        return points;\r\n    }\r\n    \r\n    static genMesh(track) {\r\n        const offset = track.width / 2;\r\n        const wallThickness = 2;\r\n        let innerShape = [[], []];\r\n        let outerShape = [[], []];\r\n    \r\n        for(const part of track.parts) {\r\n            if(part instanceof Corner) {\r\n                innerShape[0].push(...Track.genMeshCorner(part, -offset));\r\n                innerShape[1].push(...Track.genMeshCorner(part, -offset - wallThickness));\r\n\r\n                outerShape[1].push(...Track.genMeshCorner(part, offset));\r\n                outerShape[0].push(...Track.genMeshCorner(part, offset + wallThickness));\r\n            }\r\n        }\r\n\r\n        let innerWallPts = [];\r\n        let outerWallPts = [];\r\n        \r\n        const length = innerShape[0].length;\r\n        for(let cur = 0; cur < length; cur++) {\r\n            let next = cur + 1 < length ? cur + 1 : 0;\r\n            innerWallPts[cur] = [innerShape[0][cur],\r\n                                 innerShape[1][cur],\r\n                                 innerShape[1][next],\r\n                                 innerShape[0][next]];\r\n        }\r\n        \r\n        for(let cur = 0; cur < length; cur++) {\r\n            let next = cur + 1 < length ? cur + 1 : 0;\r\n            outerWallPts[cur] = [outerShape[0][cur],\r\n                                 outerShape[1][cur],\r\n                                 outerShape[1][next],\r\n                                 outerShape[0][next]];\r\n        }\r\n\r\n        track.innerWall = innerWallPts;\r\n        track.outerWall = outerWallPts;\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.strokeStyle = \"#080F0F\";\r\n        ctx.lineWidth = this.width;\r\n\r\n        let h = 0;\r\n        for(const part of this.parts) {\r\n            h += 360 / this.parts.length;\r\n            ctx.strokeStyle = \"hsl(\"+h+\", 50%, 50%)\";\r\n            ctx.beginPath();\r\n            part.draw(ctx);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawMesh(ctx) {\r\n        ctx.strokeStyle = \"cyan\";\r\n        ctx.lineWidth = 1;\r\n\r\n        for(const pts of this.innerWall) {\r\n            ctx.beginPath();\r\n            for(const point of pts) {\r\n                ctx.lineTo(point.x, point.y);\r\n            }\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n        }\r\n\r\n        for(const pts of this.outerWall) {\r\n            ctx.beginPath();\r\n            for(const point of pts) {\r\n                ctx.lineTo(point.x, point.y);\r\n            }\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = Track;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/trackGenerator.js?");

/***/ }),

/***/ "./src/shared_modules/util.js":
/*!************************************!*\
  !*** ./src/shared_modules/util.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("this.CANVAS_WIDTH = 480;\r\nthis.CANVAS_HEIGHT = 720;\r\nthis.BUFFER_SIZE = 1024\r\nthis.MAX_PLAYERS = 5;\r\n\r\nthis.getTime = () => {\r\n    let d = new Date();\r\n    let t = d.getTime();\r\n    return t;\r\n}\r\n\r\nfunction interval (duration, fn) {\r\n    var _this = this\r\n    this.baseline = undefined\r\n    \r\n    this.run = function(){\r\n        if(_this.baseline === undefined){\r\n            _this.baseline = new Date().getTime()\r\n        }\r\n        fn()\r\n        var end = new Date().getTime()\r\n        _this.baseline += duration\r\n    \r\n        var nextTick = duration - (end - _this.baseline)\r\n        if(nextTick<0){\r\n            nextTick = 0\r\n        }\r\n        \r\n        _this.timer = setTimeout(function(){\r\n            _this.run(end)\r\n        }, nextTick)\r\n    }\r\n  \r\n    this.stop = function(){\r\n        clearTimeout(_this.timer)\r\n    }\r\n}\r\n\r\nthis.min_missing_id = (clients, min = 0, offset = 0) => {\r\n    let arr = Array.from(clients).sort((a, b) => a.id - b.id);\r\n\r\n    for(var i = 0; i < arr.length - 1; i++) {\r\n        if(arr[i + offset].id != i + min) {\r\n            break;\r\n        }\r\n    }\r\n    return i + min;\r\n}\r\n\r\nthis.getBuffer = (buffer, id) => {\r\n    return buffer[(id + this.BUFFER_SIZE) % this.BUFFER_SIZE];\r\n}\r\n\r\nthis.setBuffer = (buffer, id, data) => {\r\n    buffer[(id + this.BUFFER_SIZE) % this.BUFFER_SIZE] = data;\r\n}\r\n\r\nthis.copyObj = (obj) => {\r\n    return JSON.parse(JSON.stringify(obj));\r\n}\r\n\r\nexports = this;\r\nexports.interval = interval;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/util.js?");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "?c908":
/*!****************************!*\
  !*** bufferutil (ignored) ***!
  \****************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/bufferutil_(ignored)?");

/***/ }),

/***/ "?bb17":
/*!********************************!*\
  !*** utf-8-validate (ignored) ***!
  \********************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/utf-8-validate_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/server/index.js");
/******/ 	
/******/ })()
;